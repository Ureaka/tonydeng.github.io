<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[etcd4j阻塞排查和解除过程]]></title>
      <url>http://tonydeng.github.io/2016/11/03/etcd4j-blocking-investigation-and-lifting-process/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/etcd4j/debug.jpg" alt="debug"></p>
<h2 id="先说一下背景"><a href="#先说一下背景" class="headerlink" title="先说一下背景"></a>先说一下背景</h2><p>最近将整个微服务的体系从原来的通过使用<a href="https://github.com/tonydeng/tcp4j" target="_blank" rel="external">TCP4J</a>加上固定的<code>HOST+PORT</code>的方式转成使用<a href="https://github.com/coreos/etcd" target="_blank" rel="external">ETCD</a>的服务发现体系（大家想了解ETCD可以关注我之前的两篇博文<a href="/2015/11/24/etcd-the-first-using/">初试ETCD</a>,<a href="/2015/10/19/etcd-application-scenarios/">ETCD应用场景 </a>）。</p>
<a id="more"></a>
<h3 id="基于ETCD的注册-amp-服务发现架构"><a href="#基于ETCD的注册-amp-服务发现架构" class="headerlink" title="基于ETCD的注册 &amp; 服务发现架构"></a>基于ETCD的注册 &amp; 服务发现架构</h3><p><img src="/images/blog/etcd4j/etcd-registry.png" alt="etcd registry"></p>
<ol>
<li>etcd registry 做为服务中心，提供注册与服务发现。</li>
<li>资源服务在准备完毕之后将服务实例注册到服务中心。</li>
<li>客户端到服务注册中心根据服务名称获取资源服务的地址。</li>
<li>客户端获取资源服务的地址后，调用资源服务。</li>
<li>资源服务在关闭时需要将服务实例在服务中心进行注销操作。</li>
</ol>
<p>我们使用<a href="https://github.com/jurmous/etcd4j" target="_blank" rel="external">etcd4j</a>这个etcd的java client实现，在使用的过程中，etcd4j-client会首先去请求一下etcd server，看看当前etcd server的版本是多少。</p>
<p>比如这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">http <span class="string">http:</span><span class="comment">//etcd.dev.cim.in:2379/version</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">44</span></span><br><span class="line">Content-<span class="string">Type:</span> application/json</span><br><span class="line"><span class="string">Date:</span> Wed, <span class="number">02</span> Nov <span class="number">2016</span> <span class="number">08</span>:<span class="number">21</span>:<span class="number">34</span> GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"etcdcluster"</span>: <span class="string">"2.3.0"</span>,</span><br><span class="line">   <span class="string">"etcdserver"</span>: <span class="string">"2.3.7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="看看问题"><a href="#看看问题" class="headerlink" title="看看问题"></a>看看问题</h2><p>看起来貌似很简单的情况，但是在改造某个项目的时候，在这个简单的场景下，出现了一个问题，让@webwyz同学头疼了一下午。</p>
<p>在启动项目时，就停在get version这儿死活过不去了。</p>
<p>日志如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">06</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connected to etcd.dev.cim.in/<span class="number">192.168</span>.1.86:<span class="number">2379</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">06</span> DEBUG i.n.u.i.JavassistTypeParameterMatcherGenerator - Generated: io.netty.util.internal.__matchers__.io.netty.handler.codec.http.FullHttpResponseMatcher</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">07</span> DEBUG m.e.transport.EtcdResponseHandler - Received <span class="number">200</span> <span class="keyword">for</span> GET /version</span><br></pre></td></tr></table></figure>
<p>正确的启动日志应该如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connected to etcd.dev.cim.in/<span class="number">192.168</span>.1.86:<span class="number">2379</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.e.transport.EtcdResponseHandler - Received <span class="number">200</span> <span class="keyword">for</span> GET /version</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> DEBUG m.etcd4j.transport.EtcdNettyClient - Connection closed <span class="keyword">for</span> request GET on uri /version</span><br><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">02</span> <span class="number">15</span>:<span class="number">59</span>:<span class="number">05</span> INFO  c.c.a.k.etcd.EtcdAutoConfiguration - etcd version is <span class="number">2.3</span>.0 , urls are [ http:<span class="comment">//etcd.dev.cim.in:2379 ]</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<h2 id="排查异常"><a href="#排查异常" class="headerlink" title="排查异常"></a>排查异常</h2><h3 id="是否是网络连接问题？"><a href="#是否是网络连接问题？" class="headerlink" title="是否是网络连接问题？"></a>是否是网络连接问题？</h3><p>当时我查看网络状况，网络连接也是正常的。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">lsof -nP -iTCP:<span class="number">2379</span></span><br><span class="line">COMMAND   PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">java     <span class="number">7142</span> tonydeng  317u  IPv6 <span class="number">0x235c7b856fde6855</span>      <span class="number">0t0</span>  TCP <span class="number">192.168</span><span class="meta">.2</span><span class="meta">.231</span>:<span class="number">50774</span>-&gt;<span class="number">192.168</span><span class="meta">.1</span><span class="meta">.86</span>:<span class="number">2379</span> (ESTABLISHED)</span><br><span class="line">java    <span class="number">12179</span> tonydeng  293u  IPv6 <span class="number">0x235c7b857295c315</span>      <span class="number">0t0</span>  TCP <span class="number">192.168</span><span class="meta">.2</span><span class="meta">.231</span>:<span class="number">52504</span>-&gt;<span class="number">192.168</span><span class="meta">.1</span><span class="meta">.86</span>:<span class="number">2379</span> (ESTABLISHED)</span><br></pre></td></tr></table></figure>
<p>甚至通过tcpdump来进行抓包也没有发现什么问题。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">tcpdump</span> <span class="selector-tag">host</span> 192<span class="selector-class">.168</span><span class="selector-class">.2</span><span class="selector-class">.231</span> <span class="selector-tag">and</span> 192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.86</span> <span class="selector-tag">and</span> <span class="selector-tag">tcp</span> <span class="selector-tag">port</span> 2379 <span class="selector-tag">-vv</span></span><br></pre></td></tr></table></figure>
<p>看来不是在网络层面的问题。</p>
<h3 id="追追代码"><a href="#追追代码" class="headerlink" title="追追代码"></a>追追代码</h3><p>从日志上看，最后的输出应该是<a href="https://github.com/jurmous/etcd4j/blob/release-2.12.0/src/main/java/mousio/etcd4j/transport/EtcdResponseHandler.java#L100" target="_blank" rel="external">mousio.etcd4j.transport.EtcdResponseHandler</a>，先看看这个类的代码(有兴趣的同学，可以在Github上查看<a href="https://github.com/jurmous/etcd4j/blob/release-2.12.0/src/main/java/mousio/etcd4j/transport/EtcdResponseHandler.java" target="_blank" rel="external">相关代码</a>，就不列出所有代码了)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">"Received &#123;&#125; for &#123;&#125; &#123;&#125;"</span>, <span class="keyword">new</span> Object[]&#123;Integer.valueOf(status.code()), <span class="keyword">this</span>.request.getMethod().name(), <span class="keyword">this</span>.request.getUri()&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!status.equals(HttpResponseStatus.MOVED_PERMANENTLY) &amp;&amp; !status.equals(HttpResponseStatus.TEMPORARY_REDIRECT)) &#123;</span><br><span class="line">    EtcdResponseDecoder failureDecoder = (EtcdResponseDecoder)failureDecoders.get(status);</span><br><span class="line">    <span class="keyword">if</span>(failureDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.promise.setFailure((Throwable)failureDecoder.decode(headers, content));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!content.isReadable()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!status.equals(HttpResponseStatus.OK) &amp;&amp; !status.equals(HttpResponseStatus.ACCEPTED) &amp;&amp; !status.equals(HttpResponseStatus.CREATED)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.promise.setFailure(<span class="keyword">new</span> IOException(<span class="string">"Content was not readable. HTTP Status: "</span> + status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.promise.setSuccess(<span class="keyword">this</span>.request.getResponseDecoder().decode(headers, content));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var10) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var10 <span class="keyword">instanceof</span> EtcdException) &#123;</span><br><span class="line">                <span class="keyword">this</span>.promise.setFailure(var10);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.promise.setFailure((Throwable)EtcdException.DECODER.decode(headers, content));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.promise.setFailure(var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看，应该是阻塞在<code>decode</code>过程中了（如果大家看到上面的代码和github上不一样，请不要奇怪，这个是用过java工具反编译出来的）。</p>
<h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(failureDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.promise.setFailure((Throwable)failureDecoder.decode(headers, content));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是这样，那应该是在进行version信息的序列化时出现的问题，看看etcd4j使用的json序列化包是什么？</p>
<p>通过<code>mvn dependency:tree</code>命令查看，这里果然有问题。</p>
<p>正常启动项目的jackson相关的依赖及版本</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[INFO]</span> |  |  |  \<span class="selector-tag">-</span> <span class="selector-tag">org</span><span class="selector-class">.mousio</span><span class="selector-pseudo">:etcd4j</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.12.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-core</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-databind</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-annotations</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.module</span><span class="selector-pseudo">:jackson-module-afterburner</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br></pre></td></tr></table></figure>
<p>异常启动项目的jackson相关的依赖及版本</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[INFO]</span> +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-databind</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.4</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  +<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-annotations</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.core</span><span class="selector-pseudo">:jackson-core</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.7.4</span><span class="selector-pseudo">:compile</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |  \<span class="selector-tag">-</span> <span class="selector-tag">org</span><span class="selector-class">.mousio</span><span class="selector-pseudo">:etcd4j</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.12.0</span><span class="selector-pseudo">:compile</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> |  |  |     \<span class="selector-tag">-</span> <span class="selector-tag">com</span><span class="selector-class">.fasterxml</span><span class="selector-class">.jackson</span><span class="selector-class">.module</span><span class="selector-pseudo">:jackson-module-afterburner</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.8.0</span><span class="selector-pseudo">:compile</span></span><br></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>既然知道，这儿有问题，那就简单了，在启动异常的项目中去掉不一致的jackson依赖，一切问题就都解决了。</p>
<blockquote>
<p>etcd4j项目中也有人提到类似的问题<a href="https://github.com/jurmous/etcd4j/issues/116" target="_blank" rel="external">i update version to 2.12.0 my programmer has been blocked #116</a>。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为ZSH实现Fish Shell的效果]]></title>
      <url>http://tonydeng.github.io/2016/08/05/zsh-plugins-like-fish-shell/</url>
      <content type="html"><![CDATA[<p><img src="http://cdn.makeuseof.com/wp-content/uploads/2016/02/fish-shell-644x250.jpg" alt=""></p>
<p>很久之前就见过同事用过<a href="https://fishshell.com" target="_blank" rel="external"><code>Fish Shell</code></a>，看到几个非常棒的特性和效果，比如下面两个特性就非常吸引我。</p>
<a id="more"></a>
<h2 id="Fish-Shell的炫酷"><a href="#Fish-Shell的炫酷" class="headerlink" title="Fish Shell的炫酷"></a>Fish Shell的炫酷</h2><p><img src="https://fishshell.com/assets/img/screenshots/autosuggestion.png" alt="智能提示"></p>
<p><img src="https://fishshell.com/assets/img/screenshots/colors.png" alt="语法高亮"></p>
<p><code>Fish Shell</code>的<strong>智能提示</strong>和<strong>语法高亮</strong>，是我觉得非常酷炫的功能，让我眼馋，为此我也试用过多次<code>Fish Shell</code>，但是每次都坚持不了多久，因为还是有很多地方不习惯：</p>
<ul>
<li>无插件系统，功能上还是比<a href="http://ohmyz.sh/" target="_blank" rel="external"><code>Oh My ZSH</code></a>少了很多</li>
<li>不兼容<code>bash</code>语法，导致我之前的很多脚本无法运行</li>
</ul>
<blockquote>
<p><a href="http://ohmyz.sh/" target="_blank" rel="external"><code>Oh My ZSH</code></a>才是我的真爱！</p>
</blockquote>
<h2 id="Oh-My-ZSH"><a href="#Oh-My-ZSH" class="headerlink" title="Oh My ZSH"></a>Oh My ZSH</h2><p>那么问题来了，<code>oh-my-zsh</code>中有没有插件可以实现类似的功能？</p>
<p>我先是在oh-my-zsh官方插件库里找了一下，但是没找到，后来发现了这样一个项目：</p>
<blockquote>
<p>zsh-users</p>
</blockquote>
<p>上面的介绍说是：<code>Zsh community projects</code>，感觉是非官方的项目。</p>
<p>里面有两个插件：</p>
<ol>
<li><a href="https://github.com/zsh-users/zsh-autosuggestions" target="_blank" rel="external">zsh-autosuggestions</a></li>
<li><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="external">zsh-syntax-highlighting</a></li>
</ol>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>这两个插件安装起来非常简单。</p>
<p>创建一个目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.zsh/plugins</span><br></pre></td></tr></table></figure>
<p>clone这两个项目到刚刚创建的目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/zsh-users/zsh-autosuggestions.git ~/.zsh/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:zsh-users/zsh-syntax-highlighting.git ~/.zsh/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p>设置<code>.zshrc</code>中的<code>$ZSH_CUTOM</code>变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Would you like to use another custom folder than $ZSH/custom?</span></span><br><span class="line"><span class="comment"># ZSH_CUSTOM=/path/to/new-custom-folder</span></span><br><span class="line">ZSH_CUSTOM=~/.zsh</span><br></pre></td></tr></table></figure>
<p>添加插件配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<p>最终效果图如下：</p>
<p><img src="/images/blog/zsh-like-fish-shell/autosuggestions.png" alt="autosuggestions"></p>
<p>途中可以看到git是绿色的，代表存在这个命令，如果打错了，它就是红色的：</p>
<p><img src="/images/blog/zsh-like-fish-shell/color.png" alt="color"></p>
<p>一目了然，不用等出错了再去修正错误了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Tesseract图片文字识别初探]]></title>
      <url>http://tonydeng.github.io/2016/07/28/on-the-use-of-tesseract-picture-text-recognition/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/tesseract-to-pages.png" alt="tesseract-to-pages"></p>
<p>一直以来都想尝试一下图片的中文识别，直到最近才有点空闲时间，主要目的是证实一下到底可不可行，正确率能否达到 95% 以上。自己从头写起十分费时间，因为图片处理很麻烦，所以我选用了<code>Tesseract OCR</code>。</p>
<p>所谓 <code>OCR</code>(Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字和版面信息的过程。<code>OCR</code>是图像识别领域中的一个子领域，该领域专注于对图片中的文字信息进行识别并转换成能被常规文本编辑器编辑的文本。</p>
<a id="more"></a>
<h2 id="Tesseract介绍"><a href="#Tesseract介绍" class="headerlink" title="Tesseract介绍"></a>Tesseract介绍</h2><p><code>Tesseract</code>(/‘tesərækt/) 这个词的意思是”超立方体”，指的是几何学里的四维标准方体，又称”正八胞体”，是一款被广泛使用的开源 <code>OCR</code> 工具。</p>
<p><img src="http://linusp.github.io/assets/img/tesseract.gif" alt="tesseract"></p>
<p><code>Tesseract</code> 已经有 30 年历史，开始它是惠普实验室于1985年开始研发的一款专利软件，到1995年一件成为OCR业界内最准确的识别引擎之一。然而，HP不久便决定放弃OCR业务，<code>Tesseract</code>从此尘封。数年之后，HP意识到与其将Tesseract束之高阁，还不如贡献给开源，让其重焕新生。在 2005 年，<code>Tesseract</code>由美国内华达州信息技术研究所获得，并求助于<code>Google</code>对<code>Tesseract</code>进行改进、消除Bug、优化工作，并开源，其后一直由 <code>Google</code> 赞助进行后续的开发和维护。因为其免费与较好的效果，许多的个人开发者以及一些较小的团队在使用着 <code>Tesseract</code> ，诸如验证码识别、车牌号识别等应用中，不难见到 <code>Tesseract</code> 的身影。</p>
<p>现在<code>Tesseract</code>托管在<code>Github</code>上，大家有兴趣可以上<code>Github</code>上<code>Star</code>或<code>Frok</code><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="external">该项目</a>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h3><p>在<code>Mac</code>上安装<code>Tesseract</code>是一件非常简单的事情，我们还是使用<code>brew</code>来进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tesseract</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ tesseract --version</span><br><span class="line">tesseract 3.04.01</span><br><span class="line"> leptonica-1.73</span><br><span class="line">  libjpeg 8d : libpng 1.6.23 : libtiff 4.0.6 : zlib 1.2.5</span><br></pre></td></tr></table></figure>
<p>不过，如果你只是用上述命令来安装Tesseract的话，就会发现，只支持英文，因为它只默认安装了<code>eng</code>的语言包。如果我们需要识别其他的语言该如何来办呢？</p>
<p>安装指定的语言包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew intsall tesseract</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Cellar/tesseract/&#123;version&#125;/share/tessdata</span><br><span class="line">wget https://github.com/tesseract-ocr/tessdata/raw/master/chi_sim.traineddata</span><br></pre></td></tr></table></figure>
<p>使用<code>brew</code>安装所有语言包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tesseract --all-languages</span><br></pre></td></tr></table></figure>
<h3 id="其他平台安装"><a href="#其他平台安装" class="headerlink" title="其他平台安装"></a>其他平台安装</h3><p>更多Tesseract的安装可以查看这儿<a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="external">Install Tesseract via pre-built binary package</a>或 <a href="https://github.com/tesseract-ocr/tesseract/wiki/Compiling" target="_blank" rel="external">build it from source</a></p>
<h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><p>这里只见到讲一下Tesseract识别图像的基本用法，关于训练和开发将来在另开新篇来专门讲述。</p>
<p>由于Tesseract只提供命令行工具，这里讲的用法对于Linux和Windows平台都适用。</p>
<p>首先可以通过<code>&quot;--list-langs&quot;</code>来查看哪些可用的“语言”，如果之前的<code>TESSDATA_PREFIX</code>环境变量没有设置错误，将看到这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~tesseract --list-langs</span><br><span class="line">List of available languages (107):</span><br><span class="line">afr</span><br><span class="line">amh</span><br><span class="line">ara</span><br><span class="line">asm</span><br><span class="line">aze</span><br><span class="line">aze_cyrl</span><br><span class="line">bel</span><br><span class="line">ben</span><br><span class="line">bod</span><br><span class="line">bos</span><br><span class="line">bul</span><br><span class="line">cat</span><br><span class="line">ceb</span><br><span class="line">ces</span><br><span class="line">chi_sim</span><br><span class="line">chi_tra</span><br><span class="line">chr</span><br><span class="line">cym</span><br><span class="line">dan</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>大家可以看到，我安装了107个语言包，其中,<code>eng</code>和<code>chi_sim</code>是<code>Tesseract</code>提供的英文和简体中文的语言文件。</p>
<p>另外，要说明的是，这里的 “语言文件” 的本质是包含了某种 “自然语言” 的文字的特征等辅助识别的一些资源，但像 <code>chi_sim</code> 这个中文简体里也包含了英文字母与阿拉伯数字的资源。而我们也可以为了特定的用途而去训练产生对应的资源，并且可以给这个资源自定义一个名字。</p>
<p>如果发现以上命令的输出为空，那应该去检查一下 <code>TESSDATA_PREFIX</code> 这个环境变量。在这个环境变量无误且 “语言文件” 存在的情况下，假设我们有一张名为 <code>paper.png</code> 的图片，则通过以下命令对图片进行识别，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper <span class="_">-l</span> chi_sim</span><br></pre></td></tr></table></figure>
<ol>
<li>第一个参数是待识别的图像的文件名</li>
<li>第二个参数用于指定输出，如果希望直接输出而不是保存到文件，那么就使用 <code>stdout</code>，否则这个参数将会作为保存结果的文件的前缀</li>
<li>-l <code>chi_sim</code> 这个应该很好理解，就是用来指定使用哪个 “语言文件”，如果是使用 英文(<code>eng</code>) ，这个参数可以不加，因为默认就是使用英文的 “语言文件” 来进行识别</li>
</ol>
<blockquote>
<p>以上命令如不出错，结果将会保存到 paper.txt 这个文本文件中。</p>
</blockquote>
<p>此外 <code>Tesseract</code> 还提供非常丰富的可选参数来对识别过程进行调整，可用的参数及其默认值可以通过以下命令进行查看:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract --print-parameters</span><br></pre></td></tr></table></figure>
<p>参数的使用有两种:</p>
<ul>
<li>使用 -c 选项来设定单项参数的值，比如:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper <span class="_">-l</span> chi_sim -c language_model_ngram_on=1</span><br></pre></td></tr></table></figure>
<p>允许使用多个 -c 选项来设置多个参数的值。</p>
<ul>
<li>将多项参数设置写入文件，然后在识别时使用该文件，比如:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper <span class="_">-l</span> chi_sim tess.conf</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果使用配置文件，用作参数的配置文件名要放在最后面——这里也支持多个配置文件，但它们必须要在最后面。假如我有两个配置文件 tess_1.conf 和 tess_2.conf，那么这样是正确的:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper <span class="_">-l</span> chi_sim tess_1.conf tess_2.conf</span><br></pre></td></tr></table></figure></p>
<p>而这样则是错误的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tesseract paper.png paper tess_1.conf <span class="_">-l</span> chi_sim tess_2.conf</span><br></pre></td></tr></table></figure>
<p>至于 <code>Tesseract</code> 那些参数各有什么含义，官方没有提供任何文档来进行解释，这里有一个<a href="http://www.sk-spell.sk.cx/tesseract-ocr-parameters-in-302-version" target="_blank" rel="external">链接</a>提供了部分参数的用处说明，应该是阅读了 <code>Tesseract</code> 源代码后得到的结论。</p>
<h2 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h2><p>关于<code>Tesseract</code>的文档，可以查看<a href="http://tesseract-ocr.github.io/index.html" target="_blank" rel="external">Tetesseract官方Blog</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[看看程序猿是如何来下载和处理视频]]></title>
      <url>http://tonydeng.github.io/2016/07/19/how-the-program-ape-is-coming-to-download-and-process-video/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/ffmpeg-youtube-dl.png" alt="FFMpeg and Youtube-dl"></p>
<p>我们经常在各大视频网站上看到一些很不错的视频，希望能够下载收藏起来，但是无法在网站上找到下载的按钮或者入口，很是郁闷。</p>
<p>那么来看看程序猿是如何来下载和处理视频的。</p>
<a id="more"></a>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>今天我看到了一个英国拍的工程师吐槽的视频，准备下载拿来做分享的素材。但是你如果在优酷上遍寻不到可以直接下载的链接，只有使用优酷的客户端才能给下载。</p>
<p>对于程序猿来说，这个事情实在是太让人不爽了，那我们该怎么办？</p>
<h3 id="YouTube-DL"><a href="#YouTube-DL" class="headerlink" title="YouTube-DL"></a>YouTube-DL</h3><p>那就该视频下载神器<code>youtube-dl</code>入场。别看名字和youtube相关，其实它支持大部分的视频网站。比如，我们现在要下载视频的优酷。</p>
<p>我们来试试<code>youtube-dl</code>的使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ youtube-dl http://v.youku.com/v_show/id_XNzE1NTk3Mzky.html</span><br><span class="line"></span><br><span class="line">[youku] XNzE1NTk3Mzky: Downloading JSON metadata</span><br><span class="line">[download] Downloading playlist: 工程师的痛只有工程师能懂_高清</span><br><span class="line">[youku] playlist 工程师的痛只有工程师能懂_高清: Collected 2 video ids (downloading 2 of them)</span><br><span class="line">[download] Downloading video 1 of 2</span><br><span class="line">[download] Destination: 工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part1.flv</span><br><span class="line">[download] 100% of 7.82MiB <span class="keyword">in</span> 00:07</span><br><span class="line">[download] Downloading video 2 of 2</span><br><span class="line">[download] Destination: 工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part2.flv</span><br><span class="line">[download] 100% of 7.73MiB <span class="keyword">in</span> 00:10</span><br><span class="line">[download] Finished downloading playlist: 工程师的痛只有工程师能懂_高清</span><br></pre></td></tr></table></figure>
<h3 id="FFMpeg"><a href="#FFMpeg" class="headerlink" title="FFMpeg"></a>FFMpeg</h3><p>很简单就下载了这个视频，不过新的问题就来了，我下载下来的视频有两个，怎么能合并成一个文件呢？</p>
<p>嗯，应该引入我们另外一个神器<code>FFMpeg</code>,这是一个在视频领域里面家喻户晓的类库+工具，我之前做的视频相关的应用就是利用了<code>FFMpeg</code>。有兴趣的同学可以去看看我开源的项目<a href="https://github.com/tonydeng/fmj" target="_blank" rel="external">FMJ</a>。</p>
<p>那继续看看，我们怎么利用<code>FFMpeg</code>合并视频的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i <span class="string">"工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part1.flv"</span> -c copy -bsf:v h264_mp4toannexb <span class="_">-f</span> mpegts 1.ts</span><br><span class="line">ffmpeg -i <span class="string">"工程师的痛只有工程师能懂_高清-XNzE1NTk3Mzky_part2.flv"</span> -c copy -bsf:v h264_mp4toannexb <span class="_">-f</span> mpegts 2.ts</span><br><span class="line">ffmpeg -i <span class="string">"concat:1.ts|2.ts"</span> -c copy -bsf:a aac_adtstoasc <span class="string">"工程师的痛只有工程师能懂.mp4"</span></span><br></pre></td></tr></table></figure>
<p>这样我们就解决了下载和视频处理的需求，看起来是不是和使用鼠标点点点来完成这些事情不一样呢？</p>
<p>其实，我这儿还只是粗浅的演示，更多的方式可以，去<a href="http://youtube-dl.org/" target="_blank" rel="external">Youtube-DL官网</a>、<a href="https://github.com/rg3/youtube-dl/" target="_blank" rel="external">youtube-dl的开源项目地址</a>,<a href="http://ffmpeg.org/" target="_blank" rel="external">FFMpeg官网</a>看看更详细的介绍和使用说明。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>另外，也可以看看其他人总结的一些更详细的经验和组合的自动化脚本工具。</p>
<p>比如：</p>
<ol>
<li><a href="http://www.5yun.org/7636.html" target="_blank" rel="external">youtube-dl高级使用方法，混合参数下载</a></li>
<li><a href="http://www.5yun.org/8224.html" target="_blank" rel="external">优酷付费vip视频下载方法</a></li>
<li><a href="https://github.com/kashu/ydl.sh" target="_blank" rel="external">使用youtube-dl下载视频的开源脚本</a></li>
<li><a href="https://github.com/kashu/merge.videos" target="_blank" rel="external">自动批量合并视频文件</a></li>
</ol>
<p>附上这个视频吧,有兴趣的人可以看看。</p>
<iframe height="498" width="510" src="http://player.youku.com/embed/XNzE1NTk3Mzky" frameborder="0" allowfullscreen></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Leiningen + Clojure Hello World!]]></title>
      <url>http://tonydeng.github.io/2016/07/19/leiningen-clojure-hello-world/</url>
      <content type="html"><![CDATA[<p><img src="http://www.sandraconn.com/wp-content/uploads/2014/08/hello-world-v02.jpg" alt="hello world"></p>
<p>我们之前已经写过<a href="/categories/Leiningen-Clojure之旅/">Leiningen + Clojure之旅</a>一篇Blog<a href="/2015/11/19/install-leiningen/">安装Leiningen</a>。</p>
<p>今天我们在看看如何结合Leiningen写一个Clojure的Hello World，毕竟开始一门语言，都是从Hello World开始。</p>
<a id="more"></a>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>我们还是先用lein创建一个项目，使用标准项目模板。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein new app clojure-demo --force</span><br><span class="line">Generating a project called clojure-demo based on the <span class="string">'app'</span> template.</span><br></pre></td></tr></table></figure>
<p>这儿有关于new这个指令的详细使用介绍，包括项目模板的介绍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein <span class="built_in">help</span> new</span><br><span class="line">Generate scaffolding <span class="keyword">for</span> a new project based on a template.</span><br><span class="line"></span><br><span class="line">If only one argument is passed to the <span class="string">"new"</span> task, the default template</span><br><span class="line">is used and the argument is used as the name of the project.</span><br><span class="line"></span><br><span class="line">If two arguments are passed, the first should be the name of a template,</span><br><span class="line">and the second is used as the name of the project, <span class="keyword">for</span> example:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span></span><br><span class="line"></span><br><span class="line">To generate to a directory different than your project<span class="string">'s name use --to-dir:</span><br><span class="line"></span><br><span class="line">    lein new $TEMPLATE_NAME $PROJECT_NAME --to-dir $DIR</span><br><span class="line"></span><br><span class="line">By default, the "new" task will not write to an existing directory.</span><br><span class="line">Supply the --force option to override this behavior:</span><br><span class="line"></span><br><span class="line">    lein new $TEMPLATE_NAME $PROJECT_NAME --force</span><br><span class="line">    lein new $TEMPLATE_NAME $PROJECT_NAME --to-dir $DIR --force</span><br><span class="line"></span><br><span class="line">Arguments can be passed to templates by adding them after "new"'</span>s options. Use</span><br><span class="line">`--` to separate arguments to lein new and the actual template you are using:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --to-dir <span class="variable">$DIR</span> -- template-arg-1 template-arg-2</span><br><span class="line"></span><br><span class="line">If you<span class="string">'d like to use an unreleased (ie, SNAPSHOT) template, pass in --snapshot:</span><br><span class="line"></span><br><span class="line">    lein new $TEMPLATE_NAME $PROJECT_NAME --snapshot</span><br><span class="line"></span><br><span class="line">If you'</span>d rather like to use a specific version of template, specify the version</span><br><span class="line">with --template-version option:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --template-version <span class="variable">$TEMPLATE_VERSION</span></span><br><span class="line"></span><br><span class="line">If you use the `--snapshot` or `--template-version` argument with template args</span><br><span class="line">you may need to use `--` to prevent template args from being interpreted as</span><br><span class="line">arguments to `lein new`:</span><br><span class="line"></span><br><span class="line">    lein new <span class="variable">$TEMPLATE_NAME</span> <span class="variable">$PROJECT_NAME</span> --snapshot -- template-arg-1 template-arg-2</span><br><span class="line"></span><br><span class="line">Third-party templates can be found at https://clojars.org/search?q=lein-template.</span><br><span class="line">When creating a new project from a third-party template, use its group-id</span><br><span class="line">as the template name. Note that there<span class="string">'s no need to "install" a given third-</span><br><span class="line">party template --- lein will automatically fetch it for you.</span><br><span class="line"></span><br><span class="line">Use `lein new :show $TEMPLATE` to see details about a given template.</span><br><span class="line"></span><br><span class="line">To create a new template of your own, see the documentation for the</span><br><span class="line">lein-new Leiningen plug-in.</span><br><span class="line"></span><br><span class="line">Subtasks available:</span><br><span class="line">default    A general project template for libraries.</span><br><span class="line">plugin     A leiningen plugin project template.</span><br><span class="line">app        An application project template.</span><br><span class="line">template   A meta-template for '</span>lein new<span class="string">' templates.</span><br><span class="line"></span><br><span class="line">Run `lein help new $SUBTASK` for subtask details.</span><br><span class="line"></span><br><span class="line">Arguments: ([project-name] [template project-name [-- &amp; args]])</span></span><br></pre></td></tr></table></figure>
<h2 id="project-clj说明"><a href="#project-clj说明" class="headerlink" title="project.clj说明"></a>project.clj说明</h2><p><code>project.clj</code>是<code>Leigingen</code>为项目添加的配置文件，类似于<code>Maven</code>的<code>pom.xml</code>。我们来先看看都有些什么内容。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">defproject</span> clojure-demo <span class="string">"0.1.0-SNAPSHOT"</span></span><br><span class="line">  <span class="symbol">:description</span> <span class="string">"FIXME: write description"</span></span><br><span class="line">  <span class="symbol">:url</span> <span class="string">"http://example.com/FIXME"</span></span><br><span class="line">  <span class="symbol">:license</span> &#123;<span class="symbol">:name</span> <span class="string">"Eclipse Public License"</span></span><br><span class="line">            <span class="symbol">:url</span> <span class="string">"http://www.eclipse.org/legal/epl-v10.html"</span>&#125;</span><br><span class="line">  <span class="symbol">:dependencies</span> [[org.clojure/clojure <span class="string">"1.8.0"</span>]]</span><br><span class="line">  <span class="symbol">:main</span> ^<span class="symbol">:skip-aot</span> clojure-demo.core</span><br><span class="line">  <span class="symbol">:target-path</span> <span class="string">"target/%s"</span></span><br><span class="line">  <span class="symbol">:profiles</span> &#123;<span class="symbol">:uberjar</span> &#123;<span class="symbol">:aot</span> <span class="symbol">:all</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>第一行，描述了项目名称以及版本，当前的项目名称就是 <code>clojure-demo</code>,版本是<code>0.1.0-SNAPSHOT</code>。如果一个项目版本以<code>SNAPSHOT</code>结尾，通常表明该项目还处于开发阶段，还没有正式的release。</li>
<li><code>description</code>是该项目的简要描述。</li>
<li><code>url</code>是可选的网址，可以是你项目将来上线后的实际地址。</li>
<li><code>license</code>是该项目使用License，默认给你设置为<code>Eclipse Public License</code>。</li>
<li><code>dependencies</code>是我们初期最需要关注的内容，也就是我们项目中需要依赖的其他项目及其版本的配置。比如<code>clojure-demo</code>这个项目就依赖了clojore-1.8.0的版本。</li>
<li><code>main</code>是配置了当前项目执行的文件，比如<code>clojure-demo.core</code>这个配置就表明了，执行文件就在<code>src/clojure-demo/core.clj</code>。</li>
<li><code>profiles</code>是我们自己个性化定制的不同profile的指令，比如，我们现在可以通过<code>lein uberjar</code>将项目生成一个jar供其他项目使用。</li>
</ol>
<h2 id="结合IntelliJ"><a href="#结合IntelliJ" class="headerlink" title="结合IntelliJ"></a>结合IntelliJ</h2><p>当你用IntelliJ打开<code>clojure-demo</code>，发现你根本看不到项目的结构，只能看到最外层的文件，比如<code>project.clj</code>等。src,test等目录和实际的代码你根本就看不到。那该怎么办？</p>
<p>可以先执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein pom</span><br></pre></td></tr></table></figure>
<p>这样lein帮你生成了一个<code>pom.xml</code>，你就可以按照Maven的方式import到IntelliJ中了。</p>
<h2 id="执行Hello-World"><a href="#执行Hello-World" class="headerlink" title="执行Hello World!"></a>执行Hello World!</h2><p>好，项目也生成了，IDE也可以使用了，我们就开始经典的<code>Hello World</code>吧。</p>
<p>我们在<code>project.clj</code>中配置了直接运行的方式，那我们现在开始编辑一下<code>core.clj</code>。</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">ns</span></span> clojure-demo.core</span><br><span class="line">  (<span class="symbol">:gen-class</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> -main</span><br><span class="line">  <span class="string">"I don't do a whole lot ... yet."</span></span><br><span class="line">  [&amp; args]</span><br><span class="line">  (<span class="name">println</span> <span class="string">"Hello, Clojure World!"</span>))</span><br></pre></td></tr></table></figure>
<p>执行一下看看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein run</span><br><span class="line">Hello, Clojure World!</span><br></pre></td></tr></table></figure>
<h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><p>我们先添加一个简单的方法，然后测试一下。</p>
<p>在<code>core.clj</code>中添加<code>my-plus</code>方法，简单计算一下两个数的相加</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">defn</span></span> my-plus</span><br><span class="line">  <span class="string">"I don't do a whole lot."</span></span><br><span class="line">  [a b]</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> a b))</span><br></pre></td></tr></table></figure>
<p>在<code>core_test.clj</code>中添加<code>my-plus-test</code>的测试方法，测试一下1+1是否等于2</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">deftest</span> my-plus-test</span><br><span class="line">  (<span class="name">testing</span> <span class="string">"Test my plus."</span></span><br><span class="line">    (<span class="name">is</span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">my-plus</span> <span class="number">1</span> <span class="number">1</span>) <span class="number">2</span>)))</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ lein <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">lein <span class="built_in">test</span> clojure-demo.core-test</span><br><span class="line"></span><br><span class="line">Ran 1 tests containing 1 assertions.</span><br><span class="line">0 failures, 0 errors.</span><br></pre></td></tr></table></figure>
<p>如果，你做到这一步的话，欢迎你来到Leiningen + Clojure的世界，Java工程师也可以体验一把Clojure带给你的不同体验吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[靠谱的产品经理之七字真言]]></title>
      <url>http://tonydeng.github.io/2016/07/14/product-seven-words/</url>
      <content type="html"><![CDATA[<p><img src="http://image.woshipm.com/wp-files/2015/07/kaopu.jpg" alt="怎样才算靠谱的产品经理"></p>
<p>工作那么多年，合作过的产品经理有很多，但是被我和工程师团队认为靠谱的产品经理却不多，工程师也经常吐槽产品经理不靠谱（貌似，我们之前合作过靠谱的产品经理女性居多，也不知道是什么原因……）。<br><a id="more"></a></p>
<h2 id="产品汪和程序猿之间的现状"><a href="#产品汪和程序猿之间的现状" class="headerlink" title="产品汪和程序猿之间的现状"></a>产品汪和程序猿之间的现状</h2><p>我们去通过Google或Baidu搜索关键词 “产品经理 程序员”，也经常出现如下的内容。</p>
<p>比如，想不通的……</p>
<p><img src="http://www.wanho.net/data/upload/ueditor/56d65d9d43914.jpg" alt="产品经理频繁改需求为什么会惹毛程序员？"></p>
<p>比如，比较暴力的……</p>
<p><img src="http://www.dongao.com/kjzx/UploadFiles_5705/201507/2015071016354845.png" alt="产品经理改需求惨遭囚禁凌虐"></p>
<p>或者，如此求解的……</p>
<p><img src="http://www.dongao.com/kjzx/UploadFiles_5705/201507/2015071016360147.png" alt="产品经理如何和程序员共处"></p>
<p>感觉整个互联网行业，甚至IT圈都在上演产品经理和程序员的“恩怨情仇”，堪比各大影院前段时间上映的迪斯尼大片《Zootopia》（疯狂动物城）。</p>
<p><img src="http://www.woshipm.com/wp-content/uploads/2015/07/QQ20150717145729.png" alt="产品经理和程序员的恩怨情仇"></p>
<h2 id="矛盾如何产生？"><a href="#矛盾如何产生？" class="headerlink" title="矛盾如何产生？"></a>矛盾如何产生？</h2><p>很多产品汪都经常会碰到这样的场景：</p>
<p>一个非常复杂的产品设计终于加班加点的完成了，你满心欢喜的召集程序猿们开产品讨论会，但是过程中却备受打击，经常会碰到如下问题，而你还回答不出来：</p>
<ul>
<li>是否要搜索？模糊搜索还是精确搜索？</li>
<li>是否有翻页，每页显示多少条数据？</li>
<li>能不能输入小数点、负数、字母？</li>
<li>公式怎么算的？</li>
<li>各种状态如何定义？如何转换状态？</li>
<li>……</li>
</ul>
<p>很郁闷的是上述问题，你在产品设计过程中，你根本没有考虑过这些问题，你一直在考虑如何来创建订单，应该让用户更简单的使用。而这些问题，你认为都是小问题，还需要我来考虑吗？</p>
<p>这个会议的效果可想而知。</p>
<p>程序猿们会认为这么长的时间了，你产品经理在想什么，这些都没有想明白，没干活啊！</p>
<p>产品汪们会非常委屈，觉得程序猿是有意刁难自己。要么觉得这些问题难道不是应该程序猿考虑的吗？要么觉得，这些问题复杂想不清楚。</p>
<p>最后会议草草收场，团队之间出现嫌隙。</p>
<p>当产品汪把上述问题的答案整理完之后，再次召集程序猿们开产品讨论会，发现貌似还是会有类似的问题。</p>
<p>哲人发出如此的感叹:</p>
<blockquote>
<p><img src="/images/blog/seven-words/product-workshop.png" alt="吐槽产品讨论会"></p>
</blockquote>
<p>慢慢的，产品汪和程序猿之间的情绪就越来越对立，对这个产品的热情也慢慢下降，更多的精力和时间都放在两边对耗上了，产品推行的非常之慢。</p>
<p>直到Boos来过问产品的状况，只有互相推诿和指责。</p>
<h2 id="回顾矛盾的产生"><a href="#回顾矛盾的产生" class="headerlink" title="回顾矛盾的产生"></a>回顾矛盾的产生</h2><p>其实矛盾产生的根源在于我们在产品讨论会上碰到哪些可能答不出来的问题。</p>
<p>那么，这些问题需要产品经理考虑吗？答案是显而易见的，产品经理必须要考虑这些问题、</p>
<p>因为这些最基本的问题会影响到系统的设计，没有考虑到，意味着产品经理对于规划的产品可以做什么？如何做？能做到什么程度？没有概念，规划产品的可行性就会大打折扣。</p>
<p><img src="/images/blog/seven-words/upstream-and-downstream.png" alt="产品流程的上下游"></p>
<p>一般产品研发的上下游基本上下图，程序猿处于产品汪的下游。</p>
<p>一个没有概念，规划的产品设计，你让一个思维严谨的程序猿如何能接受？他们只会认为，产品经理不靠谱，这种不靠谱的需求只会导致如下情况：</p>
<blockquote>
<p>如果让这个产品通过了产品讨论阶段，那么他们只能为这个不靠谱的产品设计和产品经理买单，程序猿们会产生这样的想法： 我TMD就是那个“接盘侠”。<br><img src="http://www.cyxqd.com/wp-content/uploads/2014/01/jiepanxia.jpg" alt="接盘侠"></p>
</blockquote>
<p><strong> 产品汪们，你们也想想，你们愿意当这个接盘侠吗？ </strong></p>
<h2 id="解决矛盾的办法"><a href="#解决矛盾的办法" class="headerlink" title="解决矛盾的办法"></a>解决矛盾的办法</h2><p>那么我们怎么来解决这些矛盾呢？</p>
<p>产品如同人一样，有样貌、皮肤等外在结构，也有筋骨、神经网络等内在体系。在产品设计及规划中，产品汪除了要对UI、UE等外在负责以外，还需要对产品的筋骨、神经网络负责。</p>
<p>产品的筋骨、神经网络就是产品隐含的逻辑规则，才是产品运转正常的保证。</p>
<p>我们推出一个产品，一般要解决两类问题：</p>
<ol>
<li>人的问题，业务的问题</li>
<li>计算机的问题，也就是技术的问题</li>
</ol>
<p>那我们设计一个产品，不管我们想的如何天马行空，如何炫酷，也一定要通过一整套的IT系统来支撑。而IT系统本质上就是对数据的各种处理，各种状态流转，使用了各种形态来展示这些数据和状态流转。</p>
<p>而产品汪一般的产品设计思路都是按照人的思维模式来进行设计的，但是人本身就是一种适配功能很强的“适配器”，人可以对模糊的信息做出自己的补充，完善自己对这个模糊的信息补充，并作出自己的反应。</p>
<p>但是计算机并非如此，比如，我们进出地铁，站在扶梯上，会有语音提示“上下楼梯，请握紧扶手”。我们很容易理解这个句话，并作出自己适当的反应，来握紧扶手。</p>
<p>但是计算机如何来理解？用手施加10牛顿的力吗？</p>
<p>那产品汪在做产品设计时，<strong>是否要考虑到如何来定义这个“紧”？！</strong></p>
<p>那很多产品汪就非常郁闷的说，这么多的问题，怎么样才能够都考虑到呢？</p>
<p><img src="http://images.rednet.cn/articleimage/2006/07/29/104016572.jpg" alt="我们不专业"></p>
<p>那怎么办呢？我们是不是需要进修一下呢？比如学星爷研读的秘籍《产品狗的自我修养》。</p>
<p><img src="http://image.woshipm.com/wp-files/2015/07/chanpingou.jpg" alt="产品狗的自我修养"></p>
<p>其实，我们并不需要研读那么深刻的著作，其实我们只要掌握了产品设计的<strong>七字真言</strong>，基本上也程序猿的在产品讨论会上碰到的问题就能解决的差不多了。</p>
<h2 id="七字真言"><a href="#七字真言" class="headerlink" title="七字真言"></a>七字真言</h2><p>很多人看到“七字真言”的第一反应可能是这样的。</p>
<p><img src="/images/blog/seven-words/seven.png" alt="七字真言"></p>
<p>其实产品设计的七字真言就是增 、删、改、查、显、算、 传</p>
<p>所有的产品设计，本质上都是对于一些数据、内容、结构层、信息做一些交互，这是产品的本质。</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ol>
<li>增加按钮的样式、位置</li>
<li>增加按钮的文案：添加、创建、新建？</li>
<li>增加内容的字段</li>
<li>字段的必填非必填说明</li>
<li>字段的验证、提示说明</li>
<li>界面排列的说明</li>
<li>弹窗还是当前页跳转？</li>
<li>……</li>
</ol>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ol>
<li>删除按钮的样式、位置</li>
<li>删除案例的文案： 删除</li>
<li>删除时是否要确认？确认窗口的样式</li>
<li>删除完以后界面布局的变化</li>
<li>逻辑删除</li>
<li>物理删除</li>
<li>删除之后是否会影响到其他的功能模块？</li>
<li>…….</li>
</ol>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ol>
<li>编辑按钮的样式、位置</li>
<li>编辑按钮的文案： 修改、编辑？</li>
<li>弹窗还是当前页面跳转？</li>
<li>可以修改与不可修改的说明</li>
<li>更改数据之后，对其他功能模块的影响</li>
<li>……</li>
</ol>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol>
<li>按照哪些字段进行排序？</li>
<li>搜索框：需要对哪些进行搜索？是否可以组合搜索？搜索后的界面如何程序？模糊搜索还是精确搜索？</li>
<li>搜索结果的展示如何？是否和搜索条件有关系？</li>
<li>搜索条件之间是否有冲突？</li>
<li>查不到数据该如何？</li>
<li>需要查看哪些数据？</li>
<li>……</li>
</ol>
<blockquote>
<p>一般来说，产品经理做到以上四点就能把原型做的非常完善，例如数据做成了列表样式，是否考虑了分页？是否需要排序？排序的话按什么条件进行？排序满足不了需求的话是否需要搜索框？查询框？查看详细列表的打开方式是怎么样的？本页操作还是新窗口操作？跳转之后需不需要跳回来？选择数据支持单选还是多选？单选的话是用下拉还是radio？如此等等</p>
<p>细节交代的越清楚，和程序猿的沟通成本就越小</p>
</blockquote>
<h3 id="显"><a href="#显" class="headerlink" title="显"></a>显</h3><ol>
<li>页面内容的布局</li>
<li>每页多少条数据、数据的排序？</li>
<li>是否有翻页、翻页样式如何？</li>
<li>是否提供查看详情，如何查看？</li>
<li>查看是弹窗还是当前页打开，还是新页面？</li>
<li>如何从各个操作页面跳转回原页面的方法？</li>
<li>跳转回来的页面如何显示？</li>
<li>不同权限用户的数据展示是否有不同？展现规则是怎么样的？</li>
<li>……</li>
</ol>
<h3 id="算"><a href="#算" class="headerlink" title="算"></a>算</h3><ol>
<li>计算规则</li>
<li>页面公式、特定指标的计算规则</li>
<li>数据背后的逻辑</li>
<li>……</li>
</ol>
<h3 id="传"><a href="#传" class="headerlink" title="传"></a>传</h3><ol>
<li>不同用户之间、不同操作之间传递哪些数据？哪些字段？</li>
<li>需要提供哪些API的接口？整合其他第三方系统时，他们提供的API是否能够满足我们现有需求？</li>
<li>数据的流向规则</li>
<li>……</li>
</ol>
<p>每当我们在做产品设计的时候，都在心里默念着七个字，基本上设计出来的产品功能点就都覆盖到了，省去了产品讨论和产品研发过程中很多不必要的沟通、交流和冲突。</p>
<p>有一个比喻非常好，“产品是孩子，开发是妈妈，产品经理是爸爸，测试时医生”，<strong>We are 伐木累！</strong>，产品汪，你们觉得呢？</p>
<p><img src="http://www.android100.org/uploadfile/2015/0829/20150829004427_0.gif" alt="we are 伐木累"></p>
<p>最后说一句，不管怎么样，各位产品汪们，需要对产品经理本身的职责要搞清楚，如果你短时间内不能达到产品经理本身应该具备的素质，那你就应该努力提高自己对产品设计和产品经理职责的理解，good good study,day day up！并且，要发挥自己的亲和力将整个团队的各个成员的长处组合起来，一起完成一个满意的产品。</p>
<p><img src="http://image.woshipm.com/wp-files/2015/07/QQ20150727200359.png" alt="任何不能杀了我的只会让我更强"></p>
<p>另外，程序猿们也不要太过难为产品汪，大家都是在一个团队工作，为了同一个目标而努力，能够互相支持，互相补位的就多多支持和补位。毕竟大家也都是在<strong>同一个马勺里喝水</strong>。</p>
<p><img src="http://www.yixieshi.com/uploads/allimg/140525/1-14052520102TZ.jpg" alt="同一个马勺里喝水"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[黑客的统计学]]></title>
      <url>http://tonydeng.github.io/2016/07/12/statistics-for-hackers/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/sfh/statistics-for-hackers.png" alt="statistics for hackers"></p>
<p>最近看到一个题为<a href="https://speakerdeck.com/jakevdp/statistics-for-hackers" target="_blank" rel="external">《Statistics for Hackers》</a>(黑客的统计学)的PPT，非常有意思，和大家分享一下。</p>
<a id="more"></a>
<p><img src="/images/blog/sfh/hackers.png" alt="黑客不是窃贼"></p>
<blockquote>
<p>这儿的Hacker（黑客）并不是是指那些尝试窃取你银行密码的人，而是那些善用编程来解决问题的人。</p>
</blockquote>
<p>作者<a href="https://twitter.com/jakevdp" target="_blank" rel="external">Jake VanderPlas</a>是华盛顿大学的资深数学科学研究员，他在PPT中表示统计学很难，但是使用编程技能后，它也可以很简单，他深圳宣称： 只要你会写 <code>for</code> 循环，你就能做统计。</p>
<p>最重要的是： <strong>问正确的问题</strong></p>
<h2 id="1-热身：-抛硬币问题（直接模拟）"><a href="#1-热身：-抛硬币问题（直接模拟）" class="headerlink" title="1. 热身： 抛硬币问题（直接模拟）"></a>1. 热身： 抛硬币问题（直接模拟）</h2><p><img src="/images/blog/sfh/coin-problem.png" alt="硬币问题"></p>
<blockquote>
<p>问题： 你抛一个硬币30次，其中22次正面朝上。问这个硬币是均匀的吗？</p>
</blockquote>
<p><img src="/images/blog/sfh/coin-dispute.png" alt="硬币问题争执"></p>
<p>这是一个经典的问题。有人认为均匀的硬币抛 30 次应该有 15 次朝上，所以这个硬币不均匀，也有人认为即使是均匀的硬币也有可能因为偶然而抛出 22 次朝上。</p>
<p><img src="/images/blog/sfh/coin-solution.png" alt="硬币问题解法"></p>
<p>经典的解法如下：</p>
<blockquote>
<p>假设硬币是均匀的，然后验证这个原假设，计算一个均匀的硬币抛出 22 次正面的概率是多少?</p>
</blockquote>
<p>开始计算，如下图所示：</p>
<p><img src="/images/blog/sfh/coin-expressions.png" alt="硬币问题解法公式"></p>
<p>列出公式后，计算得知如果硬币是均匀的，那么抛 30 次并且有 22 次正面朝上的概率是 0.008，或者说如果抛 30 次并且观察到 22 次正面朝上，则这枚硬币是均匀的概率为 0.008。这个 0.008 一般称为 p 值，习惯上，当 p 值小于 0.05（有些时候取 0.01）时，我们认为这件事是不太可能发生的，因此拒绝原假设，即得到结论：硬币不是均匀的。</p>
<p>那么，是否有什么简单的方法呢？</p>
<p>这时，编程方法就可以派上用场了，我们只需要模拟一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">N = <span class="number">1000000</span>;</span><br><span class="line">M = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">	trials = (randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>)) </span><br><span class="line">	<span class="keyword">if</span> sum(trials) &gt;= <span class="number">22</span>:</span><br><span class="line">		M += <span class="number">1</span></span><br><span class="line">p = M / N <span class="comment">#0.00819</span></span><br></pre></td></tr></table></figure>
<p>结论： 由于 p = 0.008，拒绝原假设，硬币不是均匀的。</p>
<p>简单来说，计算样板分别比较困难，但模拟样本分布很简单。</p>
<p><img src="/images/blog/sfh/coin-ultimateness.png" alt="硬币问题解法公式"></p>
<h2 id="2-随机打乱"><a href="#2-随机打乱" class="headerlink" title="2. 随机打乱"></a>2. 随机打乱</h2><p>观察两组数据：</p>
<table border="1"><thead><tr><th colspan="2">★</th><th colspan="2">✖︎</th></tr></thead><tbody><tr><td>84</td><td>72</td><td>81</td><td>69</td></tr><tr><td>57</td><td>46</td><td>74</td><td>61</td></tr><tr><td>63</td><td>76</td><td>56</td><td>87</td></tr><tr><td>99</td><td>91</td><td>69</td><td>65</td></tr><tr><td>  </td><td>  </td><td>66</td><td>44</td></tr><tr><td>  </td><td>  </td><td>62</td><td>69</td></tr></tbody></table>

<p>★ 均值：73.5<br>✖︎ 均值：66.9<br>差异：6.6</p>
<p>问题来了：两组数据的差异 6.6 是统计显著的吗？</p>
<p>经典解法如下：</p>
<p><img src="/images/blog/sfh/welch-ultimateness-1.png" alt="welch-ultimateness-1"></p>
<p><img src="/images/blog/sfh/welch-ultimateness-2.png" alt="welch-ultimateness-2"></p>
<p><img src="/images/blog/sfh/welch-ultimateness-3.png" alt="welch-ultimateness-3"></p>
<p><img src="/images/blog/sfh/welch-ultimateness-4.png" alt="welch-ultimateness-4"></p>
<p><img src="/images/blog/sfh/welch-ultimateness-5.png" alt="welch-ultimateness-5"></p>
<p>然后查表，可得：</p>
<p><img src="/images/blog/sfh/welch-ultimateness-result.png" alt="welch-ultimateness-result"></p>
<p>由于 t = 0.932 &gt; tcrit = 1.796，所以我们得到结论：在 p = 0.05 的水平上差异 6.6 不是显著的。</p>
<p>所以……，我们刚刚究竟都做了些什么？最大的问题，是我们在解题过程中已经忘了我们最初要回答的问题。</p>
<p>为什么不直接使用流行的编程方法来处理呢？比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.stats.weightstats <span class="keyword">import</span> ttest_indt, p, dof = ttest_ind(group1, group2,</span><br><span class="line">				alternative=<span class="string">'larger'</span>,</span><br><span class="line">				usevar=<span class="string">'unequal'</span>)</span><br><span class="line">print(p)  <span class="comment"># 0.186</span></span><br></pre></td></tr></table></figure>
<p>这当然可以，但是……，我们正尝试回答的是什么问题呢？</p>
<p>让我们回到问题本身，上面的样本分布和抛硬币的原理其实是一样的，让我们用一个抽样方法来处理。和抛硬币不同，这儿我们没有生成器（模拟抛硬币的结果），但这不是问题，我们可以引入一个新的解决方案：随机打乱（Shuffling）。</p>
<p>过程如下图所示：</p>
<p><img src="/images/blog/sfh/welch-ultimateness-result.gif" alt="welch-ultimateness-result"></p>
<p>执行数千次，最后得到结论：</p>
<p><img src="/images/blog/sfh/welch-ultimateness.png" alt="welch-ultimateness"></p>
<p>在 p = 0.05 的水平上，差异 6.6 不是显著的。</p>
<h3 id="关于随机打乱需要注意的事："><a href="#关于随机打乱需要注意的事：" class="headerlink" title="关于随机打乱需要注意的事："></a>关于随机打乱需要注意的事：</h3><p>– 只能在原假设认为两组相同时使用<br>– 和所有其他方法一样，只能在样本有代表性时使用，千万要注意选择偏差<br>– 要注意相关实验。这点在《Simon’s Resampling: The New Statistics》一书中有很好的讨论 </p>
<h2 id="3-亚特尔的乌龟塔"><a href="#3-亚特尔的乌龟塔" class="headerlink" title="3. 亚特尔的乌龟塔"></a>3. 亚特尔的乌龟塔</h2><p>亚特尔的乌龟塔是一则童话寓言，讲述的是一只叫亚特尔的乌龟命令其他乌龟叠在一起成为高塔的故事，知名中文博主<a href="http://www.ruanyifeng.com/blog/2005/08/post_142.html" target="_blank" rel="external">阮一峰曾经翻译过一个版本</a>。</p>
<p><img src="/images/blog/sfh/the-tortoise-tower-of-atlantis.jpg" alt="The tortoise tower of Atlantis"></p>
<p>假设我们观察到了 20 个亚特尔乌龟塔，高度分别为：</p>
<table>
<thead>
<tr>
<th>48</th>
<th>24</th>
<th>32</th>
<th>61</th>
<th>51</th>
<th>12</th>
<th>32</th>
<th>18</th>
<th>19</th>
<th>24</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td>41</td>
<td>29</td>
<td>21</td>
<td>25</td>
<td>23</td>
<td>42</td>
<td>18</td>
<td>23</td>
<td>13</td>
</tr>
</tbody>
</table>
<p>问题是：<br>– 亚特尔乌龟塔的平均高度是多少？<br>– 这个估值有多少偏差？</p>
<p>需要注意的是，这儿问的是全体亚特尔乌龟塔的平均高度，即可能存在成千上万个乌龟塔，我们只观察了其中 20 个样本，并对整体均值进行估计，而不是简单地问这 20 个样本的均值，所以才有第二个问题：这个估值有多少偏差。</p>
<p>经典解法如下：</p>
<p><img src="/images/blog/sfh/tortoise-tower-ultimateness.jpg" alt="tortoise-tower-ultimateness"></p>
<p>那么，我们是否可以使用抽样方法来处理这个问题呢？和之前一样，我们的问题是没有生成器，这次的解决方案是自助重抽样法（Bootstrap Resampling）。如下图所示：</p>
<p><img src="/images/blog/sfh/bootstrap-resampling.gif" alt="Bootstrap Resampling"></p>
<p>简单来说，就是从现有的 20 个样本中，随机抽取 20 个值（抽完后放回去，因此可能会抽到重复的值），然后计算新样本的均值。</p>
<p>重复这个步骤成千上万次，最后，我们得到下面的结果：</p>
<p><img src="/images/blog/sfh/tortoise-tower-result.jpg" alt="tortoise-tower-result"></p>
<p>可以看到，与上面使用公式计算出的结果几乎一样。</p>
<p><strong> 自助重抽样法（Bootstrap Sampling）</strong> 甚至还可以用在更复杂的统计上，同样的，也有一些注意点：</p>
<p>– 自助重抽样法（Bootstrap Sampling）被认真地研究过，有坚实的理论基础<br>– 自助重抽样法通常不太适用于基于排序的统计（如求最大值）<br>– 如果样本太小，效果会比较差（N &gt; 20 比较好）<br>– 注意选择偏差以及非独立数据 </p>
<h2 id="4-交叉验证"><a href="#4-交叉验证" class="headerlink" title="4. 交叉验证"></a>4. 交叉验证</h2><p>最后，PPT 中还举了一个交叉验证的例子。大致思想是将样本随机分为两部分，各自算出需要的值，然后用另一份样本来校验当前样本的值。重复成千上万次，最后得到可信的结果。限于篇幅，这儿就不详细介绍了，有兴趣的同学可以直接看原 <a href="https://speakerdeck.com/jakevdp/statistics-for-hackers" target="_blank" rel="external">PPT</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>相对抽象的统计学公式而言，抽样方法是一种更符合直觉的计算近似法。只要会写 <code>for</code> 循环，就可以做统计分析。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://speakerdeck.com/jakevdp/statistics-for-hackers" target="_blank" rel="external">《Statistics for Hackers》</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用 lsof 代替 Mac OS X 中的 netstat 查看占用端口的程序]]></title>
      <url>http://tonydeng.github.io/2016/07/07/use-lsof-to-replace-netstat/</url>
      <content type="html"><![CDATA[<p>众所周知水果系统内核是有 BSD 血统的 <code>Darwin</code>，OS X 自带的很多 CLI 工具也是 BSD style 的，有一部分使用起来和 Linux 无异，有一部分可以通过 <code>brew</code> 安装 GNU 版本（如 <code>tar</code>），但是 OS X 的 <code>netstat</code> 不能查看使用端口的程序名让我一直很不爽，而且也没找到 GNU 版本，于是去搜了一下解决办法，stackoverflow 上的结论基本都是建议使用 <code>lsof</code> 代替 <code>netstat</code> 进行查看：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -<span class="string">iTCP:</span>端口号 -<span class="string">sTCP:</span>LISTEN</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>-n 表示不显示主机名</li>
<li>-P 表示不显示端口俗称</li>
<li>不加 sudo 只能查看以当前用户运行的程序</li>
</ul>
<p>另外，还可以通过管道来过滤想要的信息</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -iTCP -sTCP:LISTEN | <span class="keyword">grep</span> <span class="keyword">python</span></span><br></pre></td></tr></table></figure>
<p>基本效果如下：</p>
<p>查看当前所有监听的端口以及对应的<code>Command</code>和<code>PID</code></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">➜  ~ lsof -nP -iTCP -sTCP:LISTEN</span><br><span class="line">COMMAND    PID     <span class="keyword">USER</span>   <span class="title">FD</span>   <span class="keyword">TYPE</span>             DEVICE SIZE/OFF <span class="keyword">NODE</span> <span class="title">NAME</span></span><br><span class="line">SSH\x20Pr <span class="number">1553</span> tonydeng    <span class="number">8</span>u  IPv4 <span class="number">0</span>xee7327e39355d175      <span class="number">0</span>t0  TCP <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8087</span> (LISTEN)</span><br><span class="line">SSH\x20Pr <span class="number">1553</span> tonydeng    <span class="number">9</span>u  IPv6 <span class="number">0</span>xee7327e38aad6e15      <span class="number">0</span>t0  TCP [::<span class="number">1</span>]:<span class="number">8087</span> (LISTEN)</span><br><span class="line">java      <span class="number">2978</span> tonydeng  <span class="number">166</span>u  IPv6 <span class="number">0</span>xee7327e38aad7e35      <span class="number">0</span>t0  TCP *:<span class="number">62622</span> (LISTEN)</span><br><span class="line"><span class="keyword">node</span>      <span class="title">3319</span> tonydeng   <span class="number">31</span>u  IPv4 <span class="number">0</span>xee7327e39f0f8745      <span class="number">0</span>t0  TCP *:<span class="number">4000</span> (LISTEN)</span><br></pre></td></tr></table></figure>
<p>查看指定端口对应的<code>Command</code>和<code>PID</code></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">➜  ~ lsof -nP -iTCP:<span class="number">4000</span> -sTCP:LISTEN</span><br><span class="line">COMMAND  PID     <span class="keyword">USER</span>   <span class="title">FD</span>   <span class="keyword">TYPE</span>             DEVICE SIZE/OFF <span class="keyword">NODE</span> <span class="title">NAME</span></span><br><span class="line"><span class="keyword">node</span>    <span class="title">3319</span> tonydeng   <span class="number">31</span>u  IPv4 <span class="number">0</span>xee7327e39f0f8745      <span class="number">0</span>t0  TCP *:<span class="number">4000</span> (LISTEN)</span><br></pre></td></tr></table></figure>
<p>PS ： 输出占用该端口的 PID</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">lsof</span> -nP -iTCP:<span class="number">4000</span> |grep LISTEN|awk <span class="string">'&#123;print <span class="variable">$2</span>;&#125;'</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[任意文件下载漏洞的简单防护措施]]></title>
      <url>http://tonydeng.github.io/2016/06/13/simple-protection-measures-to-download-any-file/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/download-vulnerability/security.jpg" alt="security"></p>
<p>我们在开发Web应用时，经常会提供文件下载的功能。工程师们一般会考虑遵循“单一原则”，会开发一个将请求中的<code>file</code>或<code>filePath</code>作为参数，来下载指定的文件。这样开发一个下载的功能，就能支持所有的下载需求了。</p>
<p>比如，输入这样的URL</p>
<blockquote>
<p><a href="http://tonydeng.github.io/download?file=123.txt">http://tonydeng.github.io/download?file=123.txt</a></p>
</blockquote>
<p>就能够下载<code>123.txt</code>这个文件了。</p>
<p>这样的确很方便，但是，大家有没有想过，这样的功能可能会出现什么样的安全隐患或者漏洞呢？</p>
<a id="more"></a>
<p>来，我们先看看例子：</p>
<p>下面是一段提供文件下载的<code>spring mvc</code>的java代码，使用<code>filePath</code>来指定要下载的文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDownloadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FileDownloadController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"download.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileDownload</span><span class="params">(HttpServletResponse response,</span><br><span class="line">                             HttpServletRequest request,</span><br><span class="line">                             @RequestParam(<span class="string">"filePath"</span>)</span> String filePath) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(Constants.TMP_PATH + filePath);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == file || !file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream toClient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 清空response</span></span><br><span class="line">            response.reset();</span><br><span class="line">            <span class="comment">// 设置response的Header</span></span><br><span class="line">            response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + <span class="keyword">new</span> String(filePath.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">            response.addHeader(<span class="string">"Content-Length"</span>, <span class="string">""</span> + file.length());</span><br><span class="line">            response.setContentType(<span class="string">"application/octet-stream; charset=utf-8"</span>);</span><br><span class="line">            toClient = <span class="keyword">new</span> BufferedOutputStream(response.getOutputStream());</span><br><span class="line">            toClient.write(FileUtil.getByteForFile(file));</span><br><span class="line">            toClient.flush();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            log.error(<span class="string">"file download error"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != toClient) &#123;</span><br><span class="line">                toClient.close();</span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们做个测试，在下载的目录下添加一个<code>123.txt</code>的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"123abc一二三"</span> &gt; 123.txt</span><br></pre></td></tr></table></figure>
<p>测试<code>123.txt</code>是否可以下载。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">http <span class="string">http:</span><span class="comment">//localhost:8080/file/download.do\?filePath\=123.txt</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="string">Disposition:</span> attachment;filename=<span class="number">123.</span>txt</span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">16</span></span><br><span class="line">Content-<span class="string">Type:</span> application/octet-stream; charset=utf<span class="number">-8</span></span><br><span class="line"><span class="string">Server:</span> Jetty(<span class="number">9.3</span><span class="number">.8</span>.v20160314)</span><br><span class="line"></span><br><span class="line"><span class="number">123</span>abc一二三</span><br></pre></td></tr></table></figure>
<p>看起来上面的代码和测试结果，貌似没有什么问题，也能够方便的提供文件下载服务（只需要将要下载的文件保存在<code>Constants.TMP_PATH</code>这个常量中指定的目录下就可以了）。</p>
<p>好，貌似下载的工作就完成了，我们可以考虑做别的功能了。</p>
<p>稍等，既然我们这边blog要聊<em>任意文件下载漏洞</em>，那这个漏洞到底是什么呢？我们不是已经指定了文件下载的目录了吗？</p>
<p>那我们在继续做做做测试，在指定的下载目录的上一级来创建一个<code>456.txt</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"456def四五六"</span> &gt; ../456.txt</span><br></pre></td></tr></table></figure>
<p>测试<code>456.txt</code>是否可以下载。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//localhost:8080/file/download.do\?filePath\=../456.txt</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="string">Disposition:</span> attachment;filename=../<span class="number">456.</span>txt</span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">16</span></span><br><span class="line">Content-<span class="string">Type:</span> application/octet-stream; charset=utf<span class="number">-8</span></span><br><span class="line"><span class="string">Server:</span> Jetty(<span class="number">9.3</span><span class="number">.8</span>.v20160314)</span><br><span class="line"></span><br><span class="line"><span class="number">456</span><span class="keyword">def</span>四五六</span><br></pre></td></tr></table></figure>
<p>啊！！！居然能够下载！！！</p>
<p>其实，还有更恐怖的事情。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取系统用户信息</span></span><br><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8080</span>/file<span class="regexp">/download.do\?filePath\=../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>../etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 脱裤</span></span><br><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8080</span>/file<span class="regexp">/download.do\?filePath\=../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>../data/mysql/data/mysql.dat</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>情绪稳定之后，我们肯定要问一问，这个漏洞出现在哪儿呢？</p>
<p>我们来看看这两行代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过输入的filePath参数+加上预设的下载目录，获取最终下载地址</span></span><br><span class="line">File file = <span class="keyword">new</span> File(Constants.TMP_PATH + filePath);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//读取文件并写入到Response</span></span><br><span class="line">toClient.write(FileUtil.getByteForFile(file));</span><br></pre></td></tr></table></figure>
<p>专门把这两行提出来，大家应该能够理解这个漏洞出现在哪儿了吧。</p>
<p>那我们可以通过什么样的方式来解决这个漏洞呢？</p>
<ol>
<li>是否可以通过<code>HTTP Request</code>中的<code>Referrer</code>来做判断？ <strong>貌似会误杀。</strong></li>
<li>是否可以指定的文件名来做判断？ <strong>这样太麻烦了，就不灵活了。</strong></li>
<li>是否可以通过操作系统和Web容器的文件读写权限来限制？ <strong>研究文件权限，发现根本不可行。</strong></li>
<li>……</li>
</ol>
<p>其实，我们可以通过一个简单粗暴的方式就能解决这个安全漏洞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == file || !file.exists() </span><br><span class="line">                || !file.getCanonicalFile().getParent().equals(<span class="keyword">new</span> File(Constants.TMP_PATH).getCanonicalPath())) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理就不解释了，看看<a href="http://docs.oracle.com/javase/8/docs/api/java/io/File.html#getCanonicalPath--" target="_blank" rel="external">Java的File API文档</a>吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Junit的一些的高级用法]]></title>
      <url>http://tonydeng.github.io/2016/05/11/junit-more-feature/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/junit.png" alt="Junit"></p>
<p><code>Junit</code> 是Java开发领域中非常普遍的单元测试框架，不过，大部分的使用者仅仅只是使用它一部分的功能。</p>
<p>先整理一部分相对不常用，但是个人觉得非常有用的功能（其他的慢慢补充），希望对大家有所帮助。</p>
<a id="more"></a>
<h2 id="Rule注解"><a href="#Rule注解" class="headerlink" title="Rule注解"></a>Rule注解</h2><p>比如，我们可以使用 @Role 注解来提高我们写单元测试的效率。</p>
<p><code>@Rule</code> 这个注解是 <code>Junit4</code> 的新特性，我们可以去看看Junit的关于<a href="https://github.com/junit-team/junit4/wiki/Rules" target="_blank" rel="external">Rule的使用例子</a>。</p>
<p>利用 <code>@Rule</code> 我们可以扩展 <code>Junit</code> 的功能，在执行case的时候加入测试者特有的操作，而不影响原有case的代码，减少了特有操作和test case原逻辑的耦合。</p>
<p><code>@Rule</code> 只能注解在字段中，该字段必须是 <code>public</code> 的并且类型必须实现了 <code>TestRule</code> 接口或者 <code>MethodRule</code> 接口。</p>
<p>Junit 4.9之后还加入了一个 <code>@ClassRule</code> 注解。相对 <code>@Rule</code> 来说， <code>@ClassRule</code> 是一个类级别的注解。就像 <code>@Before</code> 与 <code>@BeforeClass</code> 的区别。</p>
<h3 id="通过-Rule注解生成临时文件或临时文件夹"><a href="#通过-Rule注解生成临时文件或临时文件夹" class="headerlink" title="通过@Rule注解生成临时文件或临时文件夹"></a>通过@Rule注解生成临时文件或临时文件夹</h3><p>有时候程序运行时必须生成文件或文件夹，往往需要写不少代码来实现这个功能。我们可以使用 TemporaryFolder 来在测试的时候创建文件和目录，最爽的是它在测试运行结束之后会将测试时创建的文件和目录的自动删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.rules.TemporaryFolder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by tonydeng on 16/5/10.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitRuleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(JunitRuleTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> TemporaryFolder tempFolder = <span class="keyword">new</span> TemporaryFolder();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileCreateAndWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = tempFolder.newFile(<span class="string">"simple.txt"</span>);</span><br><span class="line">        log.info(<span class="string">"temp file:'&#123;&#125;'"</span>, file.getPath());</span><br><span class="line">        FileUtils.writeStringToFile(file, <span class="string">"Junit Rules!"</span>);</span><br><span class="line">        String line = FileUtils.readFileToString(file);</span><br><span class="line">        Assert.assertThat(line, is(<span class="string">"Junit Rules!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试完成之后，生成的这个simple.txt文件就会自动删除了。</p>
<h3 id="取得当前的测试方法名称"><a href="#取得当前的测试方法名称" class="headerlink" title="取得当前的测试方法名称"></a>取得当前的测试方法名称</h3><p>想要取得执行中的测试方法名的时候，通过@Rule注解TestName类的实例化对象可以取得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TestName name = <span class="keyword">new</span> TestName();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   log.info(<span class="string">"Test method name: &#123;&#125;"</span>,name.getMethodName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Test <span class="function"><span class="keyword">method</span> <span class="title">name</span>:</span><span class="string">'testMethodName'</span></span><br></pre></td></tr></table></figure>
<h3 id="在一个运行测试方法过程中收集多个错误信息"><a href="#在一个运行测试方法过程中收集多个错误信息" class="headerlink" title="在一个运行测试方法过程中收集多个错误信息"></a>在一个运行测试方法过程中收集多个错误信息</h3><p>使用 <code>ErrorCollector</code> 类，可以在一个测试方法中收集多个测试错误。也就是说，一个测试方法执行中，不会在第一个确认出错后就停止执行。使用 <code>ErrorCollector</code> 可以在所有点确认完后统一报出。</p>
<p>比如，有三个点需要check，但是又不想出错了就马上退出测试，可以尝试下面的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line"><span class="keyword">public</span> ErrorCollector collector = <span class="keyword">new</span> ErrorCollector();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMoreCollector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String s = <span class="keyword">null</span>;</span><br><span class="line">	collector.checkThat(<span class="string">"Value should not be null"</span>, <span class="keyword">null</span>, is(s));</span><br><span class="line"></span><br><span class="line">	s = <span class="string">""</span>;</span><br><span class="line">	collector.checkThat(<span class="string">"Value should have the length of 1"</span>,s.length(),is(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	s = <span class="string">"Junit!"</span>;</span><br><span class="line">	collector.checkThat(<span class="string">"Value should have the length of 10"</span>,s.length(),is(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的测试会报这样的错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Failed tests:   testMoreCollector(com.github.tonydeng.demo.java8.JunitRuleTest): Value should have the length of <span class="number">1</span>(..)</span><br><span class="line">  testMoreCollector(com.github.tonydeng.demo.java8.JunitRuleTest): Value should have the length of <span class="number">10</span>(..)</span><br></pre></td></tr></table></figure>
<p>或者自己手工捕获异常，添加到 <code>ErrorCollector</code> 中，通过 <code>addError</code> 添加的错误信息：。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testErrorCollector</span><span class="params">()</span></span>&#123;</span><br><span class="line">	collector.addError(<span class="keyword">new</span> Throwable(<span class="string">"first thing went wrong"</span>));</span><br><span class="line">	collector.addError(<span class="keyword">new</span> Throwable(<span class="string">"second thing went wrong"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tests in error:</span><br><span class="line">  testErrorCollector(com.github.tonydeng.demo.java8.JunitRuleTest): <span class="function">first thing went wrong</span><br><span class="line">  <span class="title">testErrorCollector</span><span class="params">(com.github.tonydeng.demo.java8.JunitRuleTest)</span>: second thing went wrong</span></span><br></pre></td></tr></table></figure>
<h3 id="设置执行最长时间"><a href="#设置执行最长时间" class="headerlink" title="设置执行最长时间"></a>设置执行最长时间</h3><p>我们有时候要对某些方法调用的时长有要求，如果超出某些时长就算是不符合要求。那我们平时怎么来测试呢？</p>
<blockquote>
<p>计算一下调用方法之前和之后的时间差，如果超出某个值，就算不符合要求。</p>
</blockquote>
<p>的确，使用上述的方式也可以达到目的，但是还是有太多多余的代码要写了。完全可以尝试一下 <code>Junit</code> 的 <code>Timeout</code>，非常简单就达到你的目的了。</p>
<p>比如，我们先设置一个5秒的超时，然后用一个无限循环的方法来测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Rule</span></span><br><span class="line">  <span class="keyword">public</span> Timeout timeout = Timeout.seconds(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.junit.runners.model.TestTimedOutException: test timed out after <span class="number">5</span> seconds</span><br></pre></td></tr></table></figure>
<h3 id="使用RuleChain"><a href="#使用RuleChain" class="headerlink" title="使用RuleChain"></a>使用RuleChain</h3><p>RuleChain提供一种将多个TestRule串在一起执行的机制。这在JUnit 4.10以后的版本中可以使用。需要根据特定顺序执行多个处理的时候，用RuleChain可以提高效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseRuleChain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> TestRule chain = RuleChain</span><br><span class="line">                           .outerRule(<span class="keyword">new</span> LoggingRule(<span class="string">"outer rule"</span>))</span><br><span class="line">                           .around(<span class="keyword">new</span> LoggingRule(<span class="string">"middle rule"</span>))</span><br><span class="line">                           .around(<span class="keyword">new</span> LoggingRule(<span class="string">"inner rule"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">starting outer rule</span><br><span class="line">starting middle rule</span><br><span class="line">starting inner rule</span><br><span class="line">finished inner rule</span><br><span class="line">finished middle rule</span><br><span class="line">finished outer rule</span><br></pre></td></tr></table></figure>
<h2 id="Parameterized注解"><a href="#Parameterized注解" class="headerlink" title="Parameterized注解"></a>Parameterized注解</h2><p>如果我们需要对我们的测试方法进行参数化，也就是只写一个测试方法，把若干种情况作为参数传递进去，一次性完成测试。那我们该怎么办？</p>
<p>可以使用 <code>Parameterized</code> 相关的注解来解决这个问题。</p>
<p>来一个简单的计算斐波纳契数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by tonydeng on 16/5/12.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciNumbersTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FibonacciNumbersTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Integer[]&gt; data() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expected;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FibonacciNumbersTest</span><span class="params">(<span class="keyword">int</span> input, <span class="keyword">int</span> expected)</span> </span>&#123;</span><br><span class="line">        value = input;</span><br><span class="line">        <span class="keyword">this</span>.expected = expected;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fibonacciNumberCall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"expected &#123;&#125; fib(value) &#123;&#125;"</span>, expected, fib(value));</span><br><span class="line">        Assert.assertEquals(expected, fib(value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，这么来写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by tonydeng on 16/5/12.</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciNumbersTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(FibonacciNumbersTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters(name = <span class="string">"&#123;index&#125;: fib(&#123;0&#125;=&#123;1&#125;)"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Integer[]&gt; data() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">8</span>&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameter</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> fInput;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameter(value = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> fExpected;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParemeter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"fExpected &#123;&#125; fib(fInput) &#123;&#125;"</span>, fExpected, fib(fInput));</span><br><span class="line">        Assert.assertEquals(fExpected, fib(fInput));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个例子中，都是利用了 <code>data()</code> 方法构建了各个测试方法的参数，其中返回值的第一个是input参数，第二个是expected参数。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/junit-team/junit4/wiki" target="_blank" rel="external">junit4 wiki via github</a></p>
<p><a href="http://www.codeaffine.com/2014/09/24/junit-nutshell-junit-tutorial/" target="_blank" rel="external">JUnit Tutorial</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Stream详解]]></title>
      <url>http://tonydeng.github.io/2016/04/25/java-stream/</url>
      <content type="html"><![CDATA[<p><img src="/images/stream-api-java8.png" alt="java8 stream api"></p>
<p>Stream是 Java 8新增加的类，用来补充集合类。</p>
<p>Stream代表数据流，流中的数据元素的数量可能是有限的，也可能是无限的。</p>
<p>Stream和其它集合类的区别在于：其它集合类主要关注与有限数量的数据的访问和有效管理(增删改)，而Stream并没有提供访问和管理元素的方式，而是通过声明数据源的方式，利用可计算的操作在数据源上执行，当然<code>BaseStream.iterator()</code> 和 <code>BaseStream.spliterator()</code>操作提供了遍历元素的方法。</p>
<p>Java Stream提供了提供了串行和并行两种类型的流，保持一致的接口，提供函数式编程方式，以管道方式提供中间操作和最终执行操作，为Java语言的集合提供了现代语言提供的类似的高阶函数操作，简化和提高了Java集合的功能。</p>
<p>本文首先介绍Java Stream的特点，然后按照功能分类逐个介绍流的中间操作和终点操作，最后会介绍第三方为Java Stream做的扩展。</p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本节翻译整理自<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="external">Java8 Stream Javadoc</a>，并对流的这些特性做了进一步的解释。</p>
<p>Stream接口还包含几个基本类型的子接口如<code>IntStream</code>, <code>LongStream</code> 和 <code>DoubleStream</code>。</p>
<p>关于流和其它集合具体的区别，可以参照下面的列表：</p>
<ol>
<li>不存储数据。流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。</li>
<li>函数式编程。流的操作不会修改数据源，例如filter不会将数据源中的数据删除。</li>
<li>延迟操作。流的很多操作如filter,map等中间操作是延迟执行的，只有到终点操作才会将操作顺序执行。</li>
<li>可以解绑。对于无限数量的流，有些操作是可以在有限的时间完成的，比如limit(n) 或 findFirst()，这些操作可是实现”短路”(Short-circuiting)，访问到有限的元素后就可以返回。</li>
<li>纯消费。流的元素只能访问一次，类似Iterator，操作没有回头路，如果你想从头重新访问流的元素，对不起，你得重新生成一个新的流。</li>
</ol>
<p>流的操作是以管道的方式串起来的。流管道包含一个数据源，接着包含零到N个中间操作，最后以一个终点操作结束。</p>
<p><img src="/images/streams.png" alt="java stream"></p>
<h3 id="并行-Parallelism"><a href="#并行-Parallelism" class="headerlink" title="并行 Parallelism"></a>并行 Parallelism</h3><p>所有的流操作都可以串行执行或者并行执行。</p>
<p>除非显示地创建并行流，否则Java库中创建的都是串行流。 <code>Collection.stream()</code>为集合创建串行流而<code>Collection.parallelStream()</code>为集合创建并行流。<code>IntStream.range(int, int)</code>创建的是串行流。通过<code>parallel()</code>方法可以将串行流转换成并行流,sequential()方法将流转换成串行流。</p>
<p>除非方法的Javadoc中指明了方法在并行执行的时候结果是不确定(比如<code>findAny</code>、<code>forEach</code>)，否则串行和并行执行的结果应该是一样的。</p>
<h3 id="Non-interference"><a href="#Non-interference" class="headerlink" title="Non-interference"></a>Non-interference</h3><p>流可以从非线程安全的集合中创建，当流的管道执行的时候，非concurrent数据源不应该被改变。下面的代码会抛出<code>java.util.ConcurrentModificationException</code>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">sl.forEach(s -&gt; l.add(<span class="string">"three"</span>));</span><br></pre></td></tr></table></figure>
<p>在设置中间操作的时候，可以更改数据源，只有在执行终点操作的时候，才有可能出现并发问题(抛出异常，或者不期望的结果)，比如下面的代码不会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">l.add(<span class="string">"three"</span>);</span><br><span class="line">sl.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>对于concurrent数据源，不会有这样的问题，比如下面的代码很正常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">sl.forEach(s -&gt; l.add(<span class="string">"three"</span>));</span><br></pre></td></tr></table></figure>
<p>虽然我们上面例子是在终点操作中对非并发数据源进行修改，但是非并发数据源也可能在其它线程中修改，同样会有并发问题。</p>
<h3 id="无状态-Stateless-behaviors"><a href="#无状态-Stateless-behaviors" class="headerlink" title="无状态 Stateless behaviors"></a>无状态 Stateless behaviors</h3><p>大部分流的操作的参数都是函数式接口，可以使用Lambda表达式实现。它们用来描述用户的行为，称之为行为参数(behavioral parameters)。</p>
<p>如果这些行为参数有状态，则流的操作的结果可能是不确定的，比如下面的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>, ……));</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> State state = <span class="keyword">new</span> State();</span><br><span class="line">Stream&lt;String&gt; sl = l.stream().map(e -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.s)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        state.s = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">sl.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>上面的代码在并行执行时多次的执行结果可能是不同的。这是因为这个lambda表达式是有状态的。</p>
<h3 id="排序-Ordering"><a href="#排序-Ordering" class="headerlink" title="排序 Ordering"></a>排序 Ordering</h3><p>某些流的返回的元素是有确定顺序的，我们称之为 <em>encounter order</em>。这个顺序是流提供它的元素的顺序，比如数组的encounter order是它的元素的排序顺序，List是它的迭代顺序(iteration order)，对于HashSet,它本身就没有encounter order。</p>
<p>一个流是否是encounter order主要依赖数据源和它的中间操作，比如数据源List和Array上创建的流是有序的(ordered)，但是在HashSet创建的流不是有序的。</p>
<p><code>sorted()</code>方法可以将流转换成有序的，<code>unordered</code>可以将流转换成无序的。<br>除此之外，一个操作可能会影响流的有序,比如<code>map</code>方法，它会用不同的值甚至类型替换流中的元素，所以输入元素的有序性已经变得没有意义了，但是对于<code>filter</code>方法来说，它只是丢弃掉一些值而已，输入元素的有序性还是保障的。</p>
<p>对于串行流，流有序与否不会影响其性能，只是会影响确定性(determinism)，无序流在多次执行的时候结果可能是不一样的。</p>
<p>对于并行流，去掉有序这个约束可能会提供性能，比如<code>distinct</code>、<code>groupingBy</code>这些聚合操作。</p>
<h3 id="结合性-Associativity"><a href="#结合性-Associativity" class="headerlink" title="结合性 Associativity"></a>结合性 Associativity</h3><p>一个操作或者函数op满足结合性意味着它满足下面的条件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">(<span class="selector-tag">a</span> op b) op c == <span class="selector-tag">a</span> op (<span class="selector-tag">b</span> op c)</span><br></pre></td></tr></table></figure>
<p>对于并发流来说，如果操作满足结合性，我们就可以并行计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a op b op c op d == (a op b) op (c op d)</span><br></pre></td></tr></table></figure>
<p>比如<code>min</code>、<code>max</code>以及字符串连接都是满足结合性的。</p>
<h2 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h2><p>可以通过多种方式创建流：</p>
<ol>
<li>通过集合的<code>stream()</code>方法或者<code>parallelStream()</code>，比如<code>Arrays.asList(1,2,3).stream()</code>。</li>
<li>通过<code>Arrays.stream(Object[])</code>方法, 比如<code>Arrays.stream(new int[]{1,2,3})</code>。</li>
<li>使用流的静态方法，比如<code>Stream.of(Object[])</code>, <code>IntStream.range(int, int)</code> 或者 <code>Stream.iterate(Object, UnaryOperator)，如Stream.iterate(0, n -&gt; n * 2)</code>，或者<code>generate(Supplier&lt;T&gt; s)</code>如<code>Stream.generate(Math::random)</code>。</li>
<li><code>BufferedReader.lines()</code>从文件中获得行的流。</li>
<li><code>Files</code>类的操作路径的方法，如<code>list</code>、<code>find</code>、<code>walk</code>等。</li>
<li>随机数流<code>Random.ints()</code>。</li>
<li>其它一些类提供了创建流的方法，如<code>BitSet.stream()</code>, <code>Pattern.splitAsStream(java.lang.CharSequence)</code>, 和 <code>JarFile.stream()</code>。</li>
<li>更底层的使用<code>StreamSupport</code>，它提供了将<code>Spliterator</code>转换成流的方法。</li>
</ol>
<h2 id="中间操作-intermediate-operations"><a href="#中间操作-intermediate-operations" class="headerlink" title="中间操作 intermediate operations"></a>中间操作 intermediate operations</h2><p>中间操作会返回一个新的流，并且操作是延迟执行的(lazy)，它不会修改原始的数据源，而且是由在终点操作开始的时候才真正开始执行。<br>这个Scala集合的转换操作不同，Scala集合转换操作会生成一个新的中间集合，显而易见Java的这种设计会减少中间对象的生成。</p>
<p>下面介绍流的这些中间操作：</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p><code>distinct</code>保证输出的流中包含唯一的元素，它是通过<code>Object.equals(Object)</code>来检查是否包含相同的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l = Stream.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"b"</span>)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[a, b, c]</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>返回的流中只包含满足断言(predicate)的数据。</p>
<p>下面的代码返回流中的偶数集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l = IntStream.range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        .filter( i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>方法将流中的元素映射成另外的值，新的值类型可以和原来的元素的类型不同。</p>
<p>下面的代码中将字符元素映射成它的哈希码(ASCII值)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l = Stream.of(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</span><br><span class="line">        .map( c -&gt; c.hashCode())</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[97, 98, 99]</span></span><br></pre></td></tr></table></figure>
<h3 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h3><p><code>flatmap</code>方法混合了<code>map</code> + <code>flattern</code>的功能，它将映射后的流的元素全部放入到一个新的流中。它的方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>mapper</code>函数会将每一个元素转换成一个流对象，而flatMap方法返回的流包含的元素为<code>mapper</code>生成的所有流中的元素。</p>
<p>下面这个例子中将一首唐诗生成一个按行分割的流，然后在这个流上调用<code>flatmap</code>得到单词的小写形式的集合，去掉重复的单词然后打印出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String poetry = <span class="string">"Where, before me, are the ages that have gone?\n"</span> +</span><br><span class="line">        <span class="string">"And where, behind me, are the coming generations?\n"</span> +</span><br><span class="line">        <span class="string">"I think of heaven and earth, without limit, without end,\n"</span> +</span><br><span class="line">        <span class="string">"And I am all alone and my tears fall down."</span>;</span><br><span class="line">Stream&lt;String&gt; lines = Arrays.stream(poetry.split(<span class="string">"\n"</span>));</span><br><span class="line">Stream&lt;String&gt; words = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">" "</span>)));</span><br><span class="line">List&lt;String&gt; l = words.map( w -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (w.endsWith(<span class="string">","</span>) || w.endsWith(<span class="string">"."</span>) || w.endsWith(<span class="string">"?"</span>))</span><br><span class="line">        <span class="keyword">return</span> w.substring(<span class="number">0</span>,w.length() -<span class="number">1</span>).trim().toLowerCase();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> w.trim().toLowerCase();</span><br><span class="line">&#125;).distinct().sorted().collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[ages, all, alone, am, and, are, before, behind, coming, down, earth, end, fall, generations, gone, have, heaven, i, limit, me, my, of, tears, that, the, think, where, without]</span></span><br></pre></td></tr></table></figure>
<p><code>flatMapToDouble</code>、<code>flatMapToInt</code>、<code>flatMapToLong</code>提供了转换成特定流的方法。</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit</code>方法指定数量的元素的流。对于串行流，这个方法是有效的，这是因为它只需返回前n个元素即可，但是对于有序的并行流，它可能花费相对较长的时间，如果你不在意有序，可以将有序并行流转换为无序的，可以提高性能。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l = IntStream.range(<span class="number">1</span>,<span class="number">100</span>).limit(<span class="number">5</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">System.out.<span class="keyword">println</span>(l);<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p><code>peek</code>方法方法会使用一个<code>Consumer</code>消费流中的元素，但是返回的流还是包含原来的流中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">        .peek(System.out::println) <span class="comment">//a,b,c,d</span></span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted()</code>将流中的元素按照自然排序方式进行排序，如果元素没有实现Comparable，则终点操作执行时会抛出<code>java.lang.ClassCastException</code>异常。<br><code>sorted(Comparator&lt;? super T&gt; comparator)</code>可以指定排序的方式。</p>
<p>对于有序流，排序是稳定的。对于非有序流，不保证排序稳定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"b_123"</span>,<span class="string">"c+342"</span>,<span class="string">"b#632"</span>,<span class="string">"d_123"</span>&#125;;</span><br><span class="line">List&lt;String&gt; l  = Arrays.stream(arr)</span><br><span class="line">        .sorted((s1,s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(<span class="number">0</span>) == s2.charAt(<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> s1.substring(<span class="number">2</span>).compareTo(s2.substring(<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> s1.charAt(<span class="number">0</span>) - s2.charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(l); <span class="comment">//[b_123, b#632, c+342, d_123]</span></span><br></pre></td></tr></table></figure>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p><code>skip</code>返回丢弃了前n个元素的流，如果流中的元素小于或者等于n，则返回空的流。</p>
<h2 id="终点操作-terminal-operations"><a href="#终点操作-terminal-operations" class="headerlink" title="终点操作 terminal operations"></a>终点操作 terminal operations</h2><h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> 	<span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> 	<span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> 	<span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure>
<p>这一组方法用来检查流中的元素是否满足断言。</p>
<p><code>allMatch</code>只有在所有的元素都满足断言时才返回true,否则flase,流为空时总是返回true</p>
<p><code>anyMatch</code>只有在任意一个元素满足断言时就返回true,否则flase,</p>
<p><code>noneMatch</code>只有在所有的元素都不满足断言时才返回true,否则flase,</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">Stream</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).allMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">Stream</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).anyMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">Stream</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).noneMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">Stream</span>.&lt;Integer&gt;empty().allMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">Stream</span>.&lt;Integer&gt;empty().anyMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">Stream</span>.&lt;Integer&gt;empty().noneMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>方法返回流中的元素的数量。它实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapToLong(e -&gt; <span class="number">1L</span>).sum();</span><br></pre></td></tr></table></figure>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R,A&gt; <span class="function">R 	<span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T,A,R&gt; collector)</span></span><br><span class="line">&lt;R&gt; R 	<span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? <span class="keyword">super</span> T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)</span></span></span><br></pre></td></tr></table></figure>
<p>使用一个<code>collector</code>执行<code>mutable reduction</code>操作。辅助类<code>Collectors</code>提供了很多的<code>collector</code>，可以满足我们日常的需求，你也可以创建新的<code>collector</code>实现特定的需求。它是一个值得关注的类，你需要熟悉这些特定的收集器，如聚合类<code>averagingInt</code>、最大最小值<code>maxBy</code> <code>minBy</code>、计数<code>counting</code>、分组<code>groupingBy</code>、字符串连接<code>joining</code>、分区<code>partitioningBy</code>、汇总<code>summarizingInt</code>、化简<code>reducing</code>、转换<code>toXXX</code>等。</p>
<p>第二个提供了更底层的功能，它的逻辑类似下面的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R result = supplier.get();</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">    accumulator.accept(result, element);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; asList = stringStream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add,</span><br><span class="line">                                           ArrayList::addAll);</span><br><span class="line">String concat = stringStream.collect(StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">                                     StringBuilder::append)</span><br><span class="line">                            .toString();</span><br></pre></td></tr></table></figure>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>findAny()</code>返回任意一个元素，如果流为空，返回空的<code>Optional</code>，对于并行流来说，它只需要返回任意一个元素即可，所以性能可能要好于<code>findFirst()</code>，但是有可能多次执行的时候返回的结果不一样。<br><code>findFirst()</code>返回第一个元素，如果流为空，返回空的<code>Optional</code>。</p>
<h3 id="forEach、forEachOrdered"><a href="#forEach、forEachOrdered" class="headerlink" title="forEach、forEachOrdered"></a>forEach、forEachOrdered</h3><p><code>forEach</code>遍历流的每一个元素，执行指定的action。它是一个终点操作，和peek方法不同。这个方法不担保按照流的<code>encounter order</code>顺序执行，如果对于有序流按照它的<code>encounter order</code>顺序执行，你可以使用<code>forEachOrdered</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="max、min"><a href="#max、min" class="headerlink" title="max、min"></a>max、min</h3><p><code>max</code>返回流中的最大值，</p>
<p><code>min</code>返回流中的最小值。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code>是常用的一个方法，事实上很多操作都是基于它实现的。</p>
<p>它有几个重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pubic Optional&lt;T&gt; 	<span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line">pubic T 	<span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line">pubic &lt;U&gt; U 	<span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U,? <span class="keyword">super</span> T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个方法使用流中的第一个值作为初始值，后面两个方法则使用一个提供的初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; total = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduce( (x, y) -&gt; x +y);</span><br><span class="line">Integer total2 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).reduce(<span class="number">0</span>, (x, y) -&gt; x +y);</span><br></pre></td></tr></table></figure>
<p>值得注意的是<code>accumulator</code>应该满足结合性(associative)。</p>
<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h3><p>将流中的元素放入到一个数组中。</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><code>concat</code>用来连接类型一样的两个流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; 	<span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p><code>toArray</code>方法将一个流转换成数组，而如果想转换成其它集合类型，西需要调用<code>collect</code>方法，利用<code>Collectors.toXXX</code>方法进行转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,C extends Collection&lt;T&gt;&gt; Collector&lt;T,?,C&gt; 	toCollection(Supplier&lt;C&gt; collectionFactory)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> …… 	toConcurrentMap(……)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T,?,List&lt;T&gt;&gt; 	toList()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> …… 	toMap(……)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T,?,Set&lt;T&gt;&gt; 	toSet()</span><br></pre></td></tr></table></figure>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>虽然Stream提供了很多的操作，但是相对于Scala等语言，似乎还少了一些。一些开源项目提供了额外的一些操作，比如<a href="https://github.com/poetix/protonpack" target="_blank" rel="external">protonpack</a>项目提供了下列方法：</p>
<ul>
<li>takeWhile and takeUntil</li>
<li>skipWhile and skipUntil</li>
<li>zip and zipWithIndex</li>
<li>unfold</li>
<li>MapStream</li>
<li>aggregate</li>
<li>Streamable</li>
<li>unique collector</li>
</ul>
<p><a href="https://github.com/NitorCreations/java8-utils" target="_blank" rel="external">java8-utils</a> 也提供了一些有益的辅助方法。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a><br><a href="http://www.leveluplunch.com/java/examples/" target="_blank" rel="external">http://www.leveluplunch.com/java/examples/</a><br><a href="https://github.com/poetix/protonpack" target="_blank" rel="external">https://github.com/poetix/protonpack</a><br><a href="https://github.com/NitorCreations/java8-utils" target="_blank" rel="external">https://github.com/NitorCreations/java8-utils</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gitignore最佳实践]]></title>
      <url>http://tonydeng.github.io/2016/04/01/gitignore/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/gitignore.jpg" alt="gitignore"></p>
<h2 id="gitignore的使用场景"><a href="#gitignore的使用场景" class="headerlink" title="gitignore的使用场景"></a>gitignore的使用场景</h2><p>使用Git的同学都知道<code>.gitignore</code> 配置文件用于配置不需要加入版本管理的文件，对版本管理带来很大的便利。今天有个需求就是忽略版本库下除少数几个文件和文件夹之外的所有文件，首先想到的方式是使用gitignore树的概念，即在需要的文件夹下都添加 <code>.gitignore</code> 文件，并在其中设定相应的规则。但是，这种方式比较麻烦。</p>
<a id="more"></a>
<h2 id="gitignore的使用模式"><a href="#gitignore的使用模式" class="headerlink" title="gitignore的使用模式"></a>gitignore的使用模式</h2><p>好好研究了一下gitignore的语法，知道了<code>.gitignore</code> 文件过滤有两种模式：开放模式和保守模式。</p>
<h3 id="开放模式"><a href="#开放模式" class="headerlink" title="开放模式"></a>开放模式</h3><p>开放模式负责设置过滤哪些文件和文件夹</p>
<p>例如： </p>
<pre><code>/target/ 表示项目根目录下的target文件夹里面所有的内容都会被过滤，不被跟踪

.classpath 表示项目根目录下的.classpath文件会被过滤，不被跟踪
</code></pre><h3 id="保守模式"><a href="#保守模式" class="headerlink" title="保守模式"></a>保守模式</h3><p>保守模式负责设置哪些文件不被过滤，也就是哪些文件要被跟踪</p>
<p>例如：</p>
<pre><code>!/target/*.h 表示target文件夹目录下所有的.h文件将被跟踪
</code></pre><p>还有就是，gitignore是从上到下逐行匹配的，因此.gitignore文件的编写原则就是：</p>
<p><strong>先编写开放模式，在编写保守模式</strong></p>
<p>要不然，开放模式的规则会把保守模式的规则给覆盖了。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面附上我的 <code>.gitignore</code> 文件的示例：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"><span class="addition">!.gitignore</span></span><br><span class="line"><span class="addition">!/posts/</span></span><br></pre></td></tr></table></figure>
<p>只跟踪版本库中的.gitignore文件和posts目录。这里需要注意的是：</p>
<pre><code>一定是/*而不是*，/*表示当前目录下的所有文件，而不是所有文件*
</code></pre><h2 id="gitignore的简单语法："><a href="#gitignore的简单语法：" class="headerlink" title="gitignore的简单语法："></a>gitignore的简单语法：</h2><ol>
<li><p>以斜杠“/”开头表目录</p>
</li>
<li><p>以星号“*”通配多字符</p>
</li>
<li><p>以问号“?”通配单字符</p>
</li>
<li><p>以方括号“[]”包含单个字符的匹列表</p>
</li>
<li><p>以叹号“!”对匹配结果反</p>
</li>
</ol>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>附上几个对大家有帮助的gitignore相关的链接。</p>
<p><a href="https://git-scm.com/docs/gitignore" target="_blank" rel="external">git-scm官网的gitinore文档</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6" target="_blank" rel="external">progit的Git基础中gitignore相关的部分</a></p>
<p><a href="https://help.github.com/articles/ignoring-files/" target="_blank" rel="external">Github的Ignoring files相关文章</a></p>
<p><a href="https://github.com/tonydeng/gitignore" target="_blank" rel="external">我forked的Github的gitignore项目</a></p>
<p><a href="https://www.gitignore.io/" target="_blank" rel="external">自动生成gitignore配置的网站</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[批量转换文件编码]]></title>
      <url>http://tonydeng.github.io/2015/11/27/batch-conversion-file-encoding/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/encoding.png" alt="encoding"></p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>之前同事有一个项目给过来，由于他之前的开发环境是Windows的，文件编码都是GBK的，看起挺不爽的，不符合我们现在的规范。需要将里面的文件全部转换成UTF8的文件编码。</p>
<p>那我们应该怎么来做呢？</p>
<p>很简单，写一个shell，利用 <code>iconv</code>转换一下就好了，于是花了5分钟左右写了一个脚本来搞定这个事情。</p>
<a id="more"></a>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line">DIR=<span class="variable">$1</span> <span class="comment"># 转换编码文件目录</span></span><br><span class="line">FT=<span class="variable">$2</span>  <span class="comment"># 需要转换的文件类型（扩展名）</span></span><br><span class="line">SE=<span class="variable">$3</span>  <span class="comment"># 原始编码</span></span><br><span class="line">DE=<span class="variable">$4</span>  <span class="comment"># 目标编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `find <span class="variable">$DIR</span> -type f -name <span class="string">"*.<span class="variable">$FT</span>"</span>`; <span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"conversion <span class="variable">$file</span> encoding <span class="variable">$SE</span> to <span class="variable">$DE</span>"</span></span><br><span class="line">    iconv <span class="_">-f</span> <span class="variable">$SE</span> -t <span class="variable">$DE</span> <span class="string">"<span class="variable">$file</span>"</span> &gt; <span class="string">"<span class="variable">$file</span>"</span>.tmp</span><br><span class="line">    mv <span class="_">-f</span> <span class="string">"<span class="variable">$file</span>"</span>.tmp <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>该脚本已经提交到<a href="https://github.com/tonydeng/note/blob/1594ae267114effa910ff2511176d3dbf7968471/sh/batch_conversion_encoding.sh" target="_blank" rel="external">github</a>上。</p>
<h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">➜  ~ ./batch_conversion_encoding<span class="selector-class">.sh</span> ~/sdk1 java GBK UTF8</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初试ETCD]]></title>
      <url>http://tonydeng.github.io/2015/11/24/etcd-the-first-using/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/etcd/etcd-api.png" alt="etcd logo"></p>
<p>之前我们分享过<a href="/2015/10/19/etcd-application-scenarios/">ETCD应用场景</a>，所有的应用场景都需要etcd提供的api来做支撑，所以这次我们就来看看ectd提供的REST API如何来使用。</p>
<p>etcd 2.0之后，规范了端口号的使用，并且写入了<a href="http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml" target="_blank" rel="external">IANA组织的标准端口记录</a>。etcd将提供给外部客户端的端口变为2379，而etcd服务间通信的端口变为2380（不过现在依然还是兼容原来4001和7001端口）。<br><a id="more"></a></p>
<h1 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h1><p>在mac osx下安装依然是非常简单，直接使用下面的命令就可以搞定。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">➜  ~  brew install etcd</span><br><span class="line">==&gt; Downloading https:<span class="comment">//homebrew.bintray.com/bottles/etcd-2.2.1.el_capitan.bottle.tar.gz</span></span><br><span class="line">Already downloaded: /Library/Caches/Homebrew/etcd-<span class="number">2.2</span>.<span class="number">1</span><span class="selector-class">.el_capitan</span><span class="selector-class">.bottle</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">==&gt; Pouring etcd-<span class="number">2.2</span>.<span class="number">1</span><span class="selector-class">.el_capitan</span><span class="selector-class">.bottle</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">==&gt; Caveats</span><br><span class="line">To have launchd start etcd at login:</span><br><span class="line">  ln -sfv /usr/local/opt/etcd<span class="comment">/*.plist ~/Library/LaunchAgents</span><br><span class="line">Then to load etcd now:</span><br><span class="line">  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.etcd.plist</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/etcd/2.2.1: 7 files, 39M</span></span><br></pre></td></tr></table></figure>
<p>我们来测试一下是否安装成功。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">➜  ~  etcd -version</span><br><span class="line">etcd <span class="string">Version:</span> <span class="number">2.2</span><span class="number">.1</span></span><br><span class="line">Git <span class="string">SHA:</span> GitNotFound</span><br><span class="line">Go <span class="string">Version:</span> go1<span class="number">.5</span><span class="number">.1</span></span><br><span class="line">Go OS<span class="regexp">/Arch: darwin/</span>amd64</span><br></pre></td></tr></table></figure>
<p>OK，看到上面的信息，就说明你已经安装成功了。从上面的信息可以看到安装的etcd版本是2.2.1，go的版本是1.5.1。</p>
<h1 id="启动etcd并测试服务"><a href="#启动etcd并测试服务" class="headerlink" title="启动etcd并测试服务"></a>启动etcd并测试服务</h1><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">➜  ~  http GET <span class="string">http:</span><span class="comment">//127.0.0.1:2379/version</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">44</span></span><br><span class="line">Content-<span class="string">Type:</span> application/json</span><br><span class="line"><span class="string">Date:</span> Wed, <span class="number">25</span> Nov <span class="number">2015</span> <span class="number">06</span>:<span class="number">07</span>:<span class="number">14</span> GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"etcdcluster"</span>: <span class="string">"2.2.0"</span>,</span><br><span class="line">    <span class="string">"etcdserver"</span>: <span class="string">"2.2.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于etcd启动参数及更多选项可以参考<a href="https://github.com/coreos/etcd/blob/master/Documentation/configuration.md" target="_blank" rel="external">Etcd Configuration Flags</a></p>
<h2 id="比较重要的配置"><a href="#比较重要的配置" class="headerlink" title="比较重要的配置"></a>比较重要的配置</h2><p><code>-name</code> 节点名称，默认是UUID<br><code>-data-dir</code> 保存日志和快照的目录，默认为当前工作目录<br><code>-addr</code> 公布的ip地址和端口。 默认为127.0.0.1:2379<br><code>-bind-addr</code> 用于客户端连接的监听地址，默认为-addr配置<br><code>-peers</code> 集群成员逗号分隔的列表，例如 127.0.0.1:2380,127.0.0.1:2381<br><code>-peer-addr</code> 集群服务通讯的公布的IP地址，默认为 127.0.0.1:2380.<br><code>-peer-bind-addr</code> 集群服务通讯的监听地址，默认为-peer-addr配置</p>
<p>上述配置也可以设置配置文件，默认为<code>/etc/etcd/etcd.conf</code>。</p>
<h1 id="试用etcd"><a href="#试用etcd" class="headerlink" title="试用etcd"></a>试用etcd</h1><h2 id="ectdctl介绍"><a href="#ectdctl介绍" class="headerlink" title="ectdctl介绍"></a>ectdctl介绍</h2><p>我们可以使用<a href="https://github.com/coreos/etcd/tree/master/etcdctl" target="_blank" rel="external">etcdctl</a>这个官方提供的客户端来对etcd进行操作，可以从<a href="https://github.com/coreos/etcd/releases" target="_blank" rel="external">github.com/coreos/etcd/releases</a>下载。</p>
<p>etcdctl是一个命令行的客户端，它提供了一下简洁的命令，可以方便我们在对服务进行测试或者手动修改数据库内容。建议刚刚接触etcd的同学可以先通过cetdctl来熟悉相关操作。这些操作跟<a href="https://github.com/coreos/etcd/blob/master/Documentation/api.md" target="_blank" rel="external">HTTP API</a>基本上是对应的。</p>
<p>etcdctl支持下面列出来的命令，基本上可以分为数据库操作和非数据库操作，可以查看<a href="https://github.com/coreos/etcd/blob/master/etcdctl/README.md" target="_blank" rel="external">etcdctl README.md</a>来了解更多</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl -h</span><br><span class="line">NAME:</span><br><span class="line">   etcdctl - A simple <span class="keyword">command</span> <span class="title">line</span> <span class="title">client</span> <span class="title">for</span> <span class="title">etcd</span>.</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   etcdctl [<span class="built_in">global</span> options] <span class="keyword">command</span> [<span class="title">command</span> <span class="title">options</span>] [<span class="title">arguments</span>...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   <span class="number">2.2</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">   backup		backup <span class="keyword">an</span> etcd <span class="built_in">directory</span></span><br><span class="line">   cluster-health	check <span class="keyword">the</span> health <span class="keyword">of</span> <span class="keyword">the</span> etcd cluster</span><br><span class="line">   mk			make <span class="keyword">a</span> <span class="built_in">new</span> key <span class="keyword">with</span> <span class="keyword">a</span> given <span class="built_in">value</span></span><br><span class="line">   mkdir		make <span class="keyword">a</span> <span class="built_in">new</span> <span class="built_in">directory</span></span><br><span class="line">   rm			remove <span class="keyword">a</span> key <span class="keyword">or</span> <span class="keyword">a</span> <span class="built_in">directory</span></span><br><span class="line">   rmdir		removes <span class="keyword">the</span> key <span class="keyword">if</span> <span class="keyword">it</span> is <span class="keyword">an</span> <span class="literal">empty</span> <span class="built_in">directory</span> <span class="keyword">or</span> <span class="keyword">a</span> key-<span class="built_in">value</span> pair</span><br><span class="line">   <span class="built_in">get</span>			retrieve <span class="keyword">the</span> <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> key</span><br><span class="line">   ls			retrieve <span class="keyword">a</span> <span class="built_in">directory</span></span><br><span class="line">   <span class="built_in">set</span>			<span class="built_in">set</span> <span class="keyword">the</span> <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> key</span><br><span class="line">   setdir		<span class="built_in">create</span> <span class="keyword">a</span> <span class="built_in">new</span> <span class="keyword">or</span> existing <span class="built_in">directory</span></span><br><span class="line">   update		update <span class="keyword">an</span> existing key <span class="keyword">with</span> <span class="keyword">a</span> given <span class="built_in">value</span></span><br><span class="line">   updatedir		update <span class="keyword">an</span> existing <span class="built_in">directory</span></span><br><span class="line">   watch		watch <span class="keyword">a</span> key <span class="keyword">for</span> changes</span><br><span class="line">   exec-watch		watch <span class="keyword">a</span> key <span class="keyword">for</span> changes <span class="keyword">and</span> exec <span class="keyword">an</span> executable</span><br><span class="line">   member		member <span class="built_in">add</span>, remove <span class="keyword">and</span> list subcommands</span><br><span class="line">   import		import <span class="keyword">a</span> snapshot <span class="built_in">to</span> <span class="keyword">a</span> cluster</span><br><span class="line">   user			user <span class="built_in">add</span>, grant <span class="keyword">and</span> revoke subcommands</span><br><span class="line">   role			role <span class="built_in">add</span>, grant <span class="keyword">and</span> revoke subcommands</span><br><span class="line">   auth			overall auth controls</span><br><span class="line">   help, h		Shows <span class="keyword">a</span> list <span class="keyword">of</span> commands <span class="keyword">or</span> help <span class="keyword">for</span> <span class="literal">one</span> <span class="keyword">command</span></span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   <span class="comment">--debug			output cURL commands which can be used to reproduce the request</span></span><br><span class="line">   <span class="comment">--no-sync			don't synchronize cluster information before sending request</span></span><br><span class="line">   <span class="comment">--output, -o 'simple'	output response in the given format (`simple`, `extended` or `json`)</span></span><br><span class="line">   <span class="comment">--discovery-srv, -D 		domain name to query for SRV records describing cluster endpoints</span></span><br><span class="line">   <span class="comment">--peers, -C 			a comma-delimited list of machine addresses in the cluster (default: "http://127.0.0.1:4001,http://127.0.0.1:2379")</span></span><br><span class="line">   <span class="comment">--endpoint 			a comma-delimited list of machine addresses in the cluster (default: "http://127.0.0.1:4001,http://127.0.0.1:2379")</span></span><br><span class="line">   <span class="comment">--cert-file 			identify HTTPS client using this SSL certificate file</span></span><br><span class="line">   <span class="comment">--key-file 			identify HTTPS client using this SSL key file</span></span><br><span class="line">   <span class="comment">--ca-file 			verify certificates of HTTPS-enabled servers using this CA bundle</span></span><br><span class="line">   <span class="comment">--username, -u 		provide username[:password] and prompt if password is not supplied.</span></span><br><span class="line">   <span class="comment">--timeout '1s'		connection timeout per request</span></span><br><span class="line">   <span class="comment">--total-timeout '5s'		timeout for the command execution (except watch)</span></span><br><span class="line">   <span class="comment">--help, -h			show help</span></span><br><span class="line">   <span class="comment">--version, -v		print the version</span></span><br></pre></td></tr></table></figure>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>数据库操作围绕对键值和目录的 <code>CRUD</code> （符合 REST 风格的一套操作：<code>Create</code>）完整生命周期的管理。</p>
<p>etcd 在键的组织上采用了层次化的空间结构（类似于文件系统中目录的概念），用户指定的键可以为单独的名字，如 <code>testkey</code>，此时实际上放在根目录 <code>/</code> 下面，也可以为指定目录结构，如 <code>cluster1/node2/testkey</code>，则将创建相应的目录结构。</p>
<blockquote>
<p>注：CRUD 即 Create, Read, Update, Delete，是符合 REST 风格的一套 API 操作。</p>
</blockquote>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>指定某个键的值。例如</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="keyword">set</span> /testdir/testkey <span class="comment">"Hello world"</span></span><br><span class="line">Hello <span class="comment">world</span></span><br></pre></td></tr></table></figure>
<p>支持的选项包括：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-ttl <span class="string">'0'</span>            该键值的超时时间（单位为秒），不配置（默认为 <span class="number">0</span>）则永不超时</span><br><span class="line"></span>-<span class="ruby">-swap-with-value value 若该键现在的值是 value，则进行设置操作</span><br><span class="line"></span>-<span class="ruby">-swap-with-index <span class="string">'0'</span>    若该键现在的索引值是指定索引，则进行设置操作</span></span><br></pre></td></tr></table></figure>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>获取指定键的值。例如</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="keyword">get</span> /testdir/testkey</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>当键不存在时，则会报错。例如</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="keyword">get</span> /testdir/testkey2</span><br><span class="line"><span class="keyword">Error</span>:  <span class="number">100</span>: <span class="keyword">Key</span> <span class="keyword">not</span> found (/testdir/testkey2) [<span class="number">18</span>]</span><br></pre></td></tr></table></figure>
<p>支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-sort    对结果进行排序</span><br><span class="line"></span>-<span class="ruby">-consistent 将请求发给主节点，保证获取内容的一致性</span></span><br></pre></td></tr></table></figure>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>当键存在时，更新值内容。例如</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl update <span class="meta-keyword">/testdir/</span>testkey <span class="string">"Hello"</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>当键不存在时，则会报错。例如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="keyword">update</span> /testdir/testkey2 <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">Error</span>:  <span class="number">100</span>: <span class="keyword">Key</span> <span class="keyword">not</span> <span class="keyword">found</span> (/testdir/testkey2) [<span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p>支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-ttl <span class="string">'0'</span>    超时时间（单位为秒），不配置（默认为 <span class="number">0</span>）则永不超时</span></span><br></pre></td></tr></table></figure>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除某个键值。例如</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl rm <span class="regexp">/testdir/</span>testkey</span><br><span class="line">PrevNode.<span class="string">Value:</span> Hello</span><br></pre></td></tr></table></figure>
<p>当键不存在时，则会报错。例如</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl rm <span class="meta-keyword">/testdir/</span>testkey</span><br><span class="line"><span class="symbol">Error:</span>  <span class="number">100</span>: Key not found (<span class="meta-keyword">/testdir/</span>testkey) [<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-dir        如果键是个空目录或者键值对则删除</span><br><span class="line"></span>-<span class="ruby">-recursive        删除目录和所有子键</span><br><span class="line"></span>-<span class="ruby">-with-value     检查现有的值是否匹配</span><br><span class="line"></span>-<span class="ruby">-with-index <span class="string">'0'</span>    检查现有的 index 是否匹配</span></span><br></pre></td></tr></table></figure>
<h3 id="mk"><a href="#mk" class="headerlink" title="mk"></a>mk</h3><p>如果给定的键不存在，则创建一个新的键值。例如</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl mk <span class="meta-keyword">/testdir/</span>testkey <span class="string">"Hello world"</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>当键存在的时候，执行该命令会报错，例如</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl mk <span class="meta-keyword">/testdir/</span>testkey <span class="string">"Hello world"</span></span><br><span class="line"><span class="symbol">Error:</span>  <span class="number">105</span>: Key already exists (<span class="meta-keyword">/testdir/</span>testkey) [<span class="number">21</span>]</span><br></pre></td></tr></table></figure>
<p>支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-ttl <span class="string">'0'</span>    超时时间（单位为秒），不配置（默认为 <span class="number">0</span>）则永不超时</span></span><br></pre></td></tr></table></figure>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>如果给定的键目录不存在，则创建一个新的键目录。例如</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="built_in">mkdir</span> testdir2</span><br></pre></td></tr></table></figure>
<p>当键目录存在的时候，执行该命令会报错，例如</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="built_in">mkdir</span> testdir2</span><br><span class="line">Error:  <span class="number">105</span>: Key already <span class="built_in">exists</span> (/testdir2) [<span class="number">22</span>]</span><br></pre></td></tr></table></figure>
<p>支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-ttl <span class="string">'0'</span>    超时时间（单位为秒），不配置（默认为 <span class="number">0</span>）则永不超时</span></span><br></pre></td></tr></table></figure>
<h3 id="setdir"><a href="#setdir" class="headerlink" title="setdir"></a>setdir</h3><p>创建一个键目录，无论存在与否。</p>
<p>支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-ttl <span class="string">'0'</span>    超时时间（单位为秒），不配置（默认为 <span class="number">0</span>）则永不超时</span></span><br></pre></td></tr></table></figure>
<h3 id="updatedir"><a href="#updatedir" class="headerlink" title="updatedir"></a>updatedir</h3><p>更新一个已经存在的目录。 支持的选项为</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-ttl <span class="string">'0'</span>    超时时间（单位为秒），不配置（默认为 <span class="number">0</span>）则永不超时</span></span><br></pre></td></tr></table></figure>
<h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><p>删除一个空目录，或者键值对。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl setdir dir1</span><br><span class="line">➜  ~  etcdctl <span class="built_in">rmdir</span> dir1</span><br></pre></td></tr></table></figure>
<p>若目录不空，会报错</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="keyword">set</span> /dir/testkey <span class="comment">hi</span></span><br><span class="line">hi</span><br><span class="line">➜  ~  etcdctl <span class="comment">rmdir</span> /dir</span><br><span class="line">Error:  <span class="number">108</span>: Directory <span class="keyword">not</span> empty (/<span class="comment">dir) [29]</span></span><br></pre></td></tr></table></figure>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>列出目录（默认为根目录）下的键或者子目录，默认不显示子目录中内容。</p>
<p>例如</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl <span class="keyword">ls</span></span><br><span class="line">/testdir</span><br><span class="line">/testdir2</span><br><span class="line">/<span class="keyword">dir</span></span><br><span class="line">➜  ~  etcdctl <span class="keyword">ls</span> <span class="keyword">dir</span></span><br><span class="line">/<span class="keyword">dir</span>/testkey</span><br></pre></td></tr></table></figure>
<p>支持的选项包括</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-sort    将输出结果排序</span><br><span class="line"></span>-<span class="ruby">-recursive    如果目录下有子目录，则递归输出其中的内容</span><br><span class="line"></span>-<span class="ruby">p        对于输出为目录，在最后添加 <span class="string">`/`</span> 进行区分</span></span><br></pre></td></tr></table></figure>
<h2 id="非数据库操作"><a href="#非数据库操作" class="headerlink" title="非数据库操作"></a>非数据库操作</h2><h3 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h3><p>备份 etcd 的数据。</p>
<p>支持的选项包括</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-data-dir         etcd 的数据目录</span><br><span class="line"></span>-<span class="ruby">-backup-dir     备份到指定路径</span></span><br></pre></td></tr></table></figure>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>监测一个键值的变化，一旦键值发生更新，就会输出最新的值并退出。</p>
<p>例如，用户更新 testkey 键值为 Hello watch。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl get /testdir/testkey</span><br><span class="line">Hello world</span><br><span class="line">➜  ~  etcdctl <span class="keyword">set</span> /testdir/testkey <span class="comment">"Hello watch"</span></span><br><span class="line">Hello <span class="comment">watch</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl watch testdir/testkey</span><br><span class="line">Hello watch</span><br></pre></td></tr></table></figure>
<p>支持的选项包括</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-forever        一直监测，直到用户按 <span class="string">`CTRL+C`</span> 退出</span><br><span class="line"></span>-<span class="ruby">-after-index <span class="string">'0'</span>    在指定 index 之前一直监测</span><br><span class="line"></span>-<span class="ruby">-recursive        返回所有的键值和子键值</span></span><br></pre></td></tr></table></figure>
<h3 id="exec-watch"><a href="#exec-watch" class="headerlink" title="exec-watch"></a>exec-watch</h3><p>监测一个键值的变化，一旦键值发生更新，就执行给定命令。</p>
<p>例如，用户更新 testkey 键值。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">➜  ~  etcdctl exec-watch testkey -- sh -c <span class="string">'ls'</span></span><br><span class="line">default<span class="selector-class">.etcd</span></span><br><span class="line">Documentation</span><br><span class="line">etcd</span><br><span class="line">etcdctl</span><br><span class="line">etcd-migrate</span><br><span class="line">README-etcdctl<span class="selector-class">.md</span></span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>
<p>支持的选项包括</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-after-index <span class="string">'0'</span>    在指定 index 之前一直监测</span><br><span class="line"></span>-<span class="ruby">-recursive        返回所有的键值和子键值</span></span><br></pre></td></tr></table></figure>
<h3 id="member"><a href="#member" class="headerlink" title="member"></a>member</h3><p>通过 list、add、remove 命令列出、添加、删除 etcd 实例到 etcd 集群中。</p>
<p>例如本地启动一个 etcd 服务实例后，可以用如下命令进行查看。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ etcdctl member <span class="keyword">list</span></span><br><span class="line">ce2a822cea30bfc<span class="variable">a:</span> name=default peerURLs=http://localhos<span class="variable">t:2380</span>,http://localhos<span class="variable">t:7001</span> clientURLs=http://localhos<span class="variable">t:2379</span>,http://localhos<span class="variable">t:4001</span></span><br></pre></td></tr></table></figure>
<p>命令选项</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-debug 输出 cURL 命令，显示执行命令的时候发起的请求</span><br><span class="line"></span>-<span class="ruby">-no-sync 发出请求之前不同步集群信息</span><br><span class="line"></span>-<span class="ruby">-output, -o <span class="string">'simple'</span> 输出内容的格式 (simple 为原始信息，json 为进行json格式解码，易读性好一些)</span><br><span class="line"></span>-<span class="ruby">-peers, -C 指定集群中的同伴信息，用逗号隔开 (默认为: <span class="string">"127.0.0.1:4001"</span>)</span><br><span class="line"></span>-<span class="ruby">-cert-file HTTPS 下客户端使用的 SSL 证书文件</span><br><span class="line"></span>-<span class="ruby">-key-file HTTPS 下客户端使用的 SSL 密钥文件</span><br><span class="line"></span>-<span class="ruby">-ca-file 服务端使用 HTTPS 时，使用 CA 文件进行验证</span><br><span class="line"></span>-<span class="ruby">-help, -h 显示帮助命令信息</span><br><span class="line"></span>-<span class="ruby">-version, -v 打印版本信息</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安装Leiningen]]></title>
      <url>http://tonydeng.github.io/2015/11/19/install-leiningen/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/leiningen.png" alt="leiningen logo"></p>
<h2 id="Leiningen简单介绍"><a href="#Leiningen简单介绍" class="headerlink" title="Leiningen简单介绍"></a>Leiningen简单介绍</h2><p><a href="http://leiningen.org" target="_blank" rel="external">Leiningen</a>是<a href="https://clojure.org" target="_blank" rel="external">Clojure</a>（貌似需要自备梯子）的项目生命周期管理工具，就像<a href="http://maven.apache.org" target="_blank" rel="external">Maven</a>在<a href="https://java.com" target="_blank" rel="external">Java</a>中的地位一样。</p>
<p>关于Leiningen具体的情况和使用方法，它的<a href="http://leiningen.org" target="_blank" rel="external">官网</a>和<a href="https://github.com/technomancy/leiningen" target="_blank" rel="external">GitHub</a>看看，上面会有更清楚的描述。<br><a id="more"></a></p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>我只是给大家说说，在安装Leiningen时可能会碰到的坑。</p>
<p>先说说，基本安装流程，咱们就遇坑填坑。</p>
<h3 id="下载lein命令"><a href="#下载lein命令" class="headerlink" title="下载lein命令"></a>下载lein命令</h3><p>下载Leiningen很简单，你使用我的命令来直接下载（仅限Mac OSX和Linux）。当然，你也可以尝试用自己系统的包管理系统来安装。比如Mac OSX可以使用<code>brew install leiningen</code>。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cd /usr/local/bin</span><br><span class="line"><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/technomancy</span><span class="regexp">/leiningen/stable</span><span class="regexp">/bin/lein</span></span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">755</span> lein</span><br></pre></td></tr></table></figure>
<p>那我们是否就已经算是安装成功，可以使用Leiningen了呢？别着急，你要是有兴趣，你看看lein这个命令，它其实就只是一段<code>Shell</code>脚本，光有它还是不够的。</p>
<h3 id="下载Leiningen"><a href="#下载Leiningen" class="headerlink" title="下载Leiningen"></a>下载Leiningen</h3><p>你可以执行一下lein，它就会自动帮你下载正在工作的那个具有超牛力的Leiningen。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>lein </span><br><span class="line">Downloading Leiningen to /Users/tonydeng/.lein/<span class="keyword">self</span>-installs/leiningen-<span class="number">2.5</span>.<span class="number">3</span>-standalone.jar now...</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line"><span class="number">100</span>   <span class="number">605</span>    <span class="number">0</span>   <span class="number">605</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">262</span>      <span class="number">0</span> --<span class="symbol">:--</span><span class="symbol">:--</span>  <span class="number">0</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">02</span> --<span class="symbol">:--</span><span class="symbol">:--</span>   <span class="number">262</span></span><br><span class="line">  <span class="number">0</span> <span class="number">15.0</span>M    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> --<span class="symbol">:--</span><span class="symbol">:--</span>  <span class="number">0</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">37</span> --<span class="symbol">:--</span><span class="symbol">:--</span>     <span class="number">0</span></span><br><span class="line">  <span class="number">0</span> <span class="number">15.0</span>M    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> --<span class="symbol">:--</span><span class="symbol">:--</span>  <span class="number">0</span><span class="symbol">:</span><span class="number">00</span><span class="symbol">:</span><span class="number">38</span> --<span class="symbol">:--</span><span class="symbol">:--</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后我就满心期待的等啊等啊，可惜等到的只是一个让人沮丧的错误提示。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Failed <span class="built_in">to</span> download <span class="keyword">https</span>://github.com/technomancy/leiningen/releases/download/<span class="number">2.5</span><span class="number">.3</span>/leiningen<span class="number">-2.5</span><span class="number">.3</span>-standalone.zip (exit code <span class="number">56</span>)</span><br><span class="line">It<span class="string">'s possible your HTTP client'</span>s certificate store does <span class="keyword">not</span> have <span class="keyword">the</span></span><br><span class="line">correct certificate authority needed. This is often caused <span class="keyword">by</span> <span class="keyword">an</span></span><br><span class="line">out-<span class="keyword">of</span>-<span class="built_in">date</span> <span class="built_in">version</span> <span class="keyword">of</span> libssl. It<span class="string">'s also possible that you'</span>re behind <span class="keyword">a</span></span><br><span class="line">firewall <span class="keyword">and</span> haven<span class="string">'t set HTTP_PROXY and HTTPS_PROXY.</span></span><br></pre></td></tr></table></figure>
<p>看到这个提示之后，我的第一反应就是 <del>Fuck GFW</del>！赶紧搭上梯子，再试，依然是不好使。然后怀疑是<code>curl</code>的问题，升级<code>curl</code>到最新版本，依然是不行。没有办法，只好祭出Google（min）大（gan）法（ci）。</p>
<p>就看到了下面这个leiningen项目中的issue #1634 – <a href="https://github.com/technomancy/leiningen/issues/1634" target="_blank" rel="external">Leiningen installation issue on Debian Wheezy #1634</a>，试了试上面给的方案，设置一下<code>HTTP_CLIENT</code>，毕竟上面的错误提示也说到了证书的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> HTTP_CLIENT=<span class="string">"wget --no-check-certificate -O"</span></span><br></pre></td></tr></table></figure>
<p>这些就OK了。</p>
<p>不过，让我比较郁闷的，为什么Leiningen版本升级之后，反而错误提示比以前的版本要检阅了呢？还是说，我使用的系统和这个 <code>issue #1634</code>遇到问题的操作系统不一样呢？不管怎么样，也算是安装成功了。</p>
<p>当你看到下面的命令输出，就说明安装成功了。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ lein <span class="comment">--version</span></span><br><span class="line">Leiningen <span class="number">2.5</span><span class="number">.3</span> <span class="keyword">on</span> Java <span class="number">1.8</span><span class="number">.0</span>_40 Java HotSpot(TM) <span class="number">64</span>-Bit Server VM</span><br></pre></td></tr></table></figure>
<p>你可以使用Leiningen的帮助来简单看看它提供的功能。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ lein -<span class="built_in">h</span></span><br><span class="line">Leiningen is a tool <span class="keyword">for</span> working with Clojure projects.</span><br><span class="line"></span><br><span class="line">Several tasks are available:</span><br><span class="line">change              Rewrite project.clj <span class="keyword">by</span> applying a function.</span><br><span class="line">check               Check <span class="keyword">syntax</span> and warn <span class="keyword">on</span> reflection.</span><br><span class="line">classpath           <span class="keyword">Print</span> the classpath of the current project.</span><br><span class="line">clean               Remove all files from project's target-path.</span><br><span class="line">compile             Compile Clojure source into .<span class="keyword">class</span> files.</span><br><span class="line">deploy              Build and deploy jar to remote repository.</span><br><span class="line">deps                Download all dependencies.</span><br><span class="line"><span class="keyword">do</span>                  Higher-<span class="keyword">order</span> task to perform other tasks <span class="keyword">in</span> succession.</span><br><span class="line"><span class="keyword">help</span>                <span class="keyword">Display</span> a <span class="keyword">list</span> of tasks or <span class="keyword">help</span> <span class="keyword">for</span> a given task.</span><br><span class="line">install             Install the current project to the <span class="keyword">local</span> repository.</span><br><span class="line">jar                 Package up all the project's files into a jar <span class="keyword">file</span>.</span><br><span class="line">javac               Compile Java source files.</span><br><span class="line">new                 <span class="keyword">Generate</span> project scaffolding based <span class="keyword">on</span> a template.</span><br><span class="line"><span class="keyword">plugin</span>              DEPRECATED. Please <span class="keyword">use</span> the :user profile instead.</span><br><span class="line">pom                 Write a pom.xml <span class="keyword">file</span> to disk <span class="keyword">for</span> Maven interoperability.</span><br><span class="line">release             Perform :release-tasks.</span><br><span class="line">repl                Start a repl session either with the current project or standalone.</span><br><span class="line">retest              <span class="keyword">Run</span> only the <span class="keyword">test</span> namespaces <span class="keyword">which</span> failed last time around.</span><br><span class="line"><span class="keyword">run</span>                 <span class="keyword">Run</span> a -main function with optional command-<span class="keyword">line</span> arguments.</span><br><span class="line"><span class="keyword">search</span>              <span class="keyword">Search</span> remote maven repositories <span class="keyword">for</span> matching jars.</span><br><span class="line">show-profiles       <span class="keyword">List</span> all available profiles or <span class="keyword">display</span> <span class="keyword">one</span> <span class="keyword">if</span> given <span class="keyword">an</span> argument.</span><br><span class="line"><span class="keyword">test</span>                <span class="keyword">Run</span> the project's tests.</span><br><span class="line">trampoline          <span class="keyword">Run</span> a task without nesting the project's JVM inside Leiningen's.</span><br><span class="line">uberjar             Package up the project files and dependencies into a jar <span class="keyword">file</span>.</span><br><span class="line"><span class="keyword">update</span>-<span class="keyword">in</span>           Perform arbitrary transformations <span class="keyword">on</span> your project map.</span><br><span class="line">upgrade             Upgrade Leiningen to specified <span class="keyword">version</span> or latest stable.</span><br><span class="line">vcs                 Interact with the <span class="keyword">version</span> control system.</span><br><span class="line"><span class="keyword">version</span>             <span class="keyword">Print</span> <span class="keyword">version</span> <span class="keyword">for</span> Leiningen and the current JVM.</span><br><span class="line">with-profile        Apply the given task with the profile(s) specified.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Run</span> `lein <span class="keyword">help</span> <span class="variable">$TASK</span>` <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Global</span> Options:</span><br><span class="line">  -o             <span class="keyword">Run</span> a task offline.</span><br><span class="line">  -<span class="keyword">U</span>             <span class="keyword">Run</span> a task after forcing <span class="keyword">update</span> of snapshots.</span><br><span class="line">  -<span class="keyword">h</span>, --<span class="keyword">help</span>     <span class="keyword">Print</span> this <span class="keyword">help</span> or <span class="keyword">help</span> <span class="keyword">for</span> a specific task.</span><br><span class="line">  -v, --<span class="keyword">version</span>  <span class="keyword">Print</span> Leiningen's <span class="keyword">version</span>.</span><br><span class="line"></span><br><span class="line">These aliases are available:</span><br><span class="line">downgrade, expands to upgrade</span><br><span class="line"></span><br><span class="line">See also: readme, faq, <span class="keyword">tutorial</span>, <span class="keyword">news</span>, <span class="keyword">sample</span>, profiles, deploying, gpg,</span><br><span class="line">mixed-source, templates, and copying.</span><br></pre></td></tr></table></figure>
<p>接下来，我就要使用Leiningen来创建和管理Clojure项目了。可以参考一下<a href="https://github.com/technomancy/leiningen/blob/stable/sample.project.clj" target="_blank" rel="external">官方提供的简单project.clj例子</a>。</p>
<h2 id="新建Clojure项目"><a href="#新建Clojure项目" class="headerlink" title="新建Clojure项目"></a>新建Clojure项目</h2><p>用下面的命令就可以轻松创建一下用Leiningen管理的Clojure项目。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">➜  lein <span class="built_in">new</span> clojure-<span class="built_in">demo</span></span><br></pre></td></tr></table></figure>
<p>我们来看看项目的目录结构，非常全面。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">➜  clojure-demo git:(master)  tree</span><br><span class="line">.</span><br><span class="line">├── CHANGELOG<span class="selector-class">.md</span></span><br><span class="line">├── LICENSE</span><br><span class="line">├── README<span class="selector-class">.md</span></span><br><span class="line">├── clojure-demo<span class="selector-class">.iml</span></span><br><span class="line">├── dev-resources</span><br><span class="line">├── doc</span><br><span class="line">│   └── intro<span class="selector-class">.md</span></span><br><span class="line">├── project<span class="selector-class">.clj</span></span><br><span class="line">├── resources</span><br><span class="line">├── src</span><br><span class="line">│   └── clojure_demo</span><br><span class="line">│       └── core<span class="selector-class">.clj</span></span><br><span class="line">├── target</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   └── META-INF</span><br><span class="line">│   │       └── maven</span><br><span class="line">│   │           └── clojure-demo</span><br><span class="line">│   │               └── clojure-demo</span><br><span class="line">│   │                   └── pom<span class="selector-class">.properties</span></span><br><span class="line">│   └── stale</span><br><span class="line">│       └── extract-native<span class="selector-class">.dependencies</span></span><br><span class="line">└── test</span><br><span class="line">    └── clojure_demo</span><br><span class="line">        └── core_test.clj</span><br></pre></td></tr></table></figure>
<p>好了，今天就先弄到这儿。改天在继续更新这个Leiningen + Clojure之旅，比如Leiningen和Maven的整合、Clojure和Java的互相调用等等。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[工程师字体]]></title>
      <url>http://tonydeng.github.io/2015/11/19/engineering-fonts/</url>
      <content type="html"><![CDATA[<p><img src="http://dejavu-fonts.org/wiki/images/d/d3/Dejavu_title.png" alt=""></p>
<p>工程师是一个比较有有意思的群体，比如像我这样有些强迫症的工程师，开始工作之前必须要先选择一个对工程师友好的字体。</p>
<p>国外有人在2009年就写了一篇文章讲关于程序员的字体。<a href="http://hivelogic.com/articles/top-10-programming-fonts" target="_blank" rel="external">top 10 programming forts</a>，上面列了不少优秀的字体。</p>
<p>知乎上也有不少人在讨论程序员用什么字体比较爽，比如<a href="http://www.zhihu.com/question/20455297" target="_blank" rel="external">【哪些字体适合程序员用来维护代码？】</a> ， <a href="http://www.zhihu.com/question/19637242" target="_blank" rel="external">【程序员编程看起来最舒服的字体（英文的和中文的）、字号、颜色和背景色是什么？】</a>。</p>
<p>不过，经过我自己的测试，还是觉得“<a href="http://www.dafont.com/bitstream-vera-mono.font" target="_blank" rel="external">Bitstream Vera Mono</a>”，和“<a href="http://dejavu-fonts.org/wiki/Main_Page" target="_blank" rel="external">DejaVu Sans Mono</a>”最好用，给大家推荐一下。</p>
<p>贴一下在终端的效果。</p>
<p><img src="/images/blog/engineering-fonts/bitstream-vera-mono.png" alt="bitestream-vera-mono font"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Java中使用Maven配置的版本信息]]></title>
      <url>http://tonydeng.github.io/2015/11/17/using-maven-version/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/using-maven-version.png" alt="HSC Maven Version"></p>
<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>我们在开发一些项目的时候需要知道当前的版本状态，比如传递版本客户端信息到服务端等等。</p>
<p>那我们有些什么办法能够获取当前项目版本呢？</p>
<p>比较简单的办法就是在我们的程序中写一个常量来记录版本号，每次升级了就更新这个常量。但是这个方案还需要我们每次升级的时候都要记得这个事情，这个对于我这种记性不太好的人来说，简直就是灾难。</p>
<p>那还有什么更好的办法吗？</p>
<a id="more"></a>
<p>那我们可以从本身项目所使用的项目生命周期管理工具来考虑。比如现在<code>Java</code>的项目大部分还是用Maven来做项目生命周期管理的，那我们可不可以将<code>Maven</code>所记录的版本信息读取出来呢？</p>
<p>应该是可以，不过，如果要读取出来，我们是否需要去分析<code>Maven</code>的<code>pom.xml</code>文件吗？如果是这样，工作量也有点大。</p>
<p>其实<code>maven</code>已经给出了方案，就是可以在自定义的资源文件（<code>properties</code>）中放置<code>pom.xml</code>设置的变量，就会自动将变量替换成为真实地值。</p>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>我有一个hsc的项目，代码中需要知道当前项目的版本。那我应该怎么来做呢？</p>
<h3 id="在src-main-resources-hsc-application-properties文件中放置如下内容："><a href="#在src-main-resources-hsc-application-properties文件中放置如下内容：" class="headerlink" title="在src/main/resources/hsc-application.properties文件中放置如下内容："></a>在src/main/resources/hsc-application.properties文件中放置如下内容：</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">hsc.<span class="keyword">version</span>=<span class="variable">$&#123;project</span>.<span class="keyword">version</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;build&gt;</span></span><br><span class="line">       <span class="params">&lt;resources&gt;</span></span><br><span class="line">           <span class="params">&lt;resource&gt;</span></span><br><span class="line">               <span class="params">&lt;directory&gt;</span>src<span class="meta-keyword">/main/</span>resources<span class="params">&lt;/directory&gt;</span></span><br><span class="line">               <span class="params">&lt;filtering&gt;</span>true<span class="params">&lt;/filtering&gt;</span></span><br><span class="line">           <span class="params">&lt;/resource&gt;</span></span><br><span class="line">       <span class="params">&lt;/resources&gt;</span></span><br><span class="line"><span class="params">&lt;/build&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现对hsc-version的读取"><a href="#实现对hsc-version的读取" class="headerlink" title="实现对hsc.version的读取"></a>实现对hsc.version的读取</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * 获取HSC版本信息</span><br><span class="line">    * @return</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHSCVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (null == HSCVersion) &#123;</span><br><span class="line">           Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               properties.load(HSCUtils.<span class="keyword">class</span>.getClassLoader().getResourceAsStream(<span class="string">"hsc-application.properties"</span>));</span><br><span class="line">               <span class="keyword">if</span> (!properties.isEmpty()) &#123;</span><br><span class="line">                   HSCVersion = properties.getProperty(<span class="string">"hsc.version"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> HSCVersion;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试获取版本信息"><a href="#测试获取版本信息" class="headerlink" title="测试获取版本信息"></a>测试获取版本信息</h3><figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> testApplicationVersion()&#123;</span><br><span class="line">      String <span class="keyword">version</span> = HSCUtils.getHSCVersion();</span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">"hsc version:'&#123;&#125;'"</span>,<span class="keyword">version</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://books.sonatype.com/mvnref-book/reference/resource-filtering-sect-properties.html" target="_blank" rel="external">maven可以使用内部变量</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java发送邮件出现"no object dch for mime type multipart/mixed"异常的解决办法及过程]]></title>
      <url>http://tonydeng.github.io/2015/10/30/java-mail-no-object-dch-for-mime-type-multipart-mixed/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/email-error/error.jpg" alt="email error"></p>
<p>前两天写了一个发送邮件的功能，结果出现了一个比较灵异的状况，现在整理一下解决办法和中间的过程。</p>
<a id="more"></a>
<h1 id="发送邮件配置及代码"><a href="#发送邮件配置及代码" class="headerlink" title="发送邮件配置及代码"></a>发送邮件配置及代码</h1><p>通过Java来发送邮件现在已经是非常方便就实现的功能。只需要使用<code>commons-email</code>这个第三方的包就可以很轻松的完成功能。</p>
<p><code>commons-email</code>的<code>maven</code>依赖配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它会传递依赖<code>mail</code>和<code>activation</code>这两个包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>发送邮件的代码也非常简单：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 发送邮件</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> recipients</span><br><span class="line"> * <span class="doctag">@param</span> subject</span><br><span class="line"> * <span class="doctag">@param</span> content</span><br><span class="line"> * <span class="doctag">@throws</span> TException</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sendMails</span><span class="params">(List&lt;Recipient&gt; recipients, String subject, String content)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;InternetAddress&gt; addresses = getReplys(recipients);</span><br><span class="line">        <span class="keyword">if</span>(log.isInfoEnabled())&#123;</span><br><span class="line">            log.info(<span class="string">"send mail to recipients:'&#123;&#125;' subject:'&#123;&#125;'"</span>, addresses, subject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(addresses))&#123;</span><br><span class="line">            Email email = settingEmail(<span class="keyword">new</span> HtmlEmail());</span><br><span class="line">            email.setSubject(subject);</span><br><span class="line">            email.setMsg(content);</span><br><span class="line">            email.setTo(addresses);</span><br><span class="line">            email.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line"> * 设置邮件配置</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> email</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> * <span class="doctag">@throws</span> EmailException</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function">Email <span class="title">settingEmail</span><span class="params">(Email email)</span> <span class="keyword">throws</span> EmailException </span>&#123;</span><br><span class="line">    email.setHostName(mailConfig.getProperty(<span class="string">"mail.host"</span>));</span><br><span class="line">    email.setCharset(mailConfig.getProperty(<span class="string">"mail.charset"</span>));</span><br><span class="line">    email.setSSLOnConnect(<span class="keyword">true</span>);</span><br><span class="line">    email.setAuthentication(mailConfig.getProperty(<span class="string">"mail.username"</span>), mailConfig.getProperty(<span class="string">"mail.password"</span>));</span><br><span class="line">    email.setFrom(mailConfig.getProperty(<span class="string">"mail.from"</span>));</span><br><span class="line">    <span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，代码写完了，单元测试也没有问题，一般情况下，就认为这个功能完成了，那么就打包部署吧。我现在使用了<code>Thrift</code>作为RPC框架，没有想到部署到测试环境中发现使用<code>Thrift</code>客户端调用发送邮件服务却无法正常发送邮件。</p>
<h1 id="灵异状况"><a href="#灵异状况" class="headerlink" title="灵异状况"></a>灵异状况</h1><p>查看日志，却发现出现了下面的异常。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Caused <span class="keyword">by: </span><span class="keyword">javax.activation.UnsupportedDataTypeException: </span>no object DCH for MIME type <span class="keyword">multipart/mixed;</span><br><span class="line"></span>	<span class="keyword">boundary="----=_Part_0_1434202756.1446193111088"</span><br><span class="line"></span>	<span class="built_in">at</span> <span class="keyword">javax.activation.ObjectDataContentHandler.writeTo(DataHandler.java:896)</span><br><span class="line"></span>	<span class="built_in">at</span> <span class="keyword">javax.activation.DataHandler.writeTo(DataHandler.java:317)</span><br><span class="line"></span>	<span class="built_in">at</span> <span class="keyword">javax.mail.internet.MimeBodyPart.writeTo(MimeBodyPart.java:1485)</span><br><span class="line"></span>	<span class="built_in">at</span> <span class="keyword">javax.mail.internet.MimeMessage.writeTo(MimeMessage.java:1773)</span><br><span class="line"></span>	<span class="built_in">at</span> com.sun.mail.smtp.SMTPTransport.sendMessage(SMTPTransport.<span class="keyword">java:1121)</span><br><span class="line"></span>	... <span class="number">17</span> more</span><br></pre></td></tr></table></figure>
<p>当时的第一反应，是否是邮件服务器那边做了调整，出现新的状况？毕竟之前的单元测试也没有问题。</p>
<p>那重新写一个新的单元测试看看是怎么回事。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testSendMails</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Recipient&gt; recipients = Lists.newArrayList(</span><br><span class="line">            <span class="keyword">new</span> Recipient(<span class="string">"tonydeng"</span>,<span class="string">"tonydeng@github.com"</span>,<span class="string">""</span>,<span class="string">""</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    notifyUtils.sendMails(recipients,<span class="string">"test"</span>,<span class="string">"content"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑了好几次，都可以正常发送邮件，那是怎么回事？难道是通过thrift之后，中间有些信息发生变化？</p>
<p>将代码通过maven打包成功可执行的jar，启动thrift server，在调用Agent项目的单元测试，果然出现<strong>“no object DCH for MIME type multipart/mixed;”</strong>的异常。</p>
<p>果然很灵异，一般来说，在邮件服务的单元测试跑通之后，这个功能就应该是没有问题了。</p>
<p>现在出现了在服务端写的单元测试可以跑通，客户端的单元测试却出现异常。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>翻墙通过Google查了一下，主要的原因都是因为<code>mailcap</code>配置的问题。解决方案有两个。</p>
<h2 id="一个是在代码中加上一段mailcap配置"><a href="#一个是在代码中加上一段mailcap配置" class="headerlink" title="一个是在代码中加上一段mailcap配置"></a>一个是在代码中加上一段mailcap配置</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap()<span class="comment">;</span></span><br><span class="line">mc.<span class="keyword">addMailcap("text/html;; </span>x-<span class="keyword">java-content-handler=com.sun.mail.handlers.text_html");</span><br><span class="line"></span>mc.<span class="keyword">addMailcap("text/xml;; </span>x-<span class="keyword">java-content-handler=com.sun.mail.handlers.text_xml");</span><br><span class="line"></span>mc.<span class="keyword">addMailcap("text/plain;; </span>x-<span class="keyword">java-content-handler=com.sun.mail.handlers.text_plain");</span><br><span class="line"></span>mc.<span class="keyword">addMailcap("multipart/*;; </span>x-<span class="keyword">java-content-handler=com.sun.mail.handlers.multipart_mixed");</span><br><span class="line"></span>mc.<span class="keyword">addMailcap("message/rfc822;; </span>x-<span class="keyword">java-content-handler=com.sun.mail.handlers.message_rfc822");</span><br><span class="line"></span>CommandMap.setDefaultCommandMap(mc)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="一个是将javax-mail下的mailcap相关文件复制到当前项目的META-INF目录下。"><a href="#一个是将javax-mail下的mailcap相关文件复制到当前项目的META-INF目录下。" class="headerlink" title="一个是将javax.mail下的mailcap相关文件复制到当前项目的META-INF目录下。"></a>一个是将javax.mail下的mailcap相关文件复制到当前项目的<code>META-INF</code>目录下。</h2><p>查看了一下<code>MailcapCommandMap</code>源码，在<code>META-INF</code>中加入<code>mailcap</code>配置文件，也应该能够和在代码中加入<code>mailcap</code>配置起到一样的作用。</p>
<p>附上<code>MailcapCommandMap</code>初始化方法：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MailcapCommandMap() &#123;</span><br><span class="line">        ArrayList dbv = <span class="keyword">new</span> ArrayList(<span class="number">5</span>);</span><br><span class="line">        MailcapFile mf = <span class="keyword">null</span>;</span><br><span class="line">        dbv.<span class="built_in">add</span>((<span class="keyword">Object</span>)<span class="keyword">null</span>);</span><br><span class="line">        LogSupport.<span class="built_in">log</span>(<span class="string">"MailcapCommandMap: load HOME"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> ex;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = System.getProperty(<span class="string">"user.home"</span>);</span><br><span class="line">            <span class="keyword">if</span>(ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">String</span> path = ex + File.separator + <span class="string">".mailcap"</span>;</span><br><span class="line">                mf = <span class="keyword">this</span>.loadFile(path);</span><br><span class="line">                <span class="keyword">if</span>(mf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dbv.<span class="built_in">add</span>(mf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException var7) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LogSupport.<span class="built_in">log</span>(<span class="string">"MailcapCommandMap: load SYS"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ex = System.getProperty(<span class="string">"java.home"</span>) + File.separator + <span class="string">"lib"</span> + File.separator + <span class="string">"mailcap"</span>;</span><br><span class="line">            mf = <span class="keyword">this</span>.loadFile(ex);</span><br><span class="line">            <span class="keyword">if</span>(mf != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dbv.<span class="built_in">add</span>(mf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException var6) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LogSupport.<span class="built_in">log</span>(<span class="string">"MailcapCommandMap: load JAR"</span>);</span><br><span class="line">        <span class="keyword">this</span>.loadAllResources(dbv, <span class="string">"META-INF/mailcap"</span>);</span><br><span class="line">        LogSupport.<span class="built_in">log</span>(<span class="string">"MailcapCommandMap: load DEF"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(MailcapCommandMap.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(defDB == <span class="keyword">null</span>) &#123;</span><br><span class="line">                defDB = <span class="keyword">this</span>.loadResource(<span class="string">"/META-INF/mailcap.default"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(defDB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dbv.<span class="built_in">add</span>(defDB);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.DB = <span class="keyword">new</span> MailcapFile[dbv.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="keyword">this</span>.DB = (MailcapFile[])((MailcapFile[])dbv.toArray(<span class="keyword">this</span>.DB));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>按照我的习惯，能够配置的就不要写在代码里了，看样子正解应该是在<code>META-INF</code>文件夹中加入<code>mailcap</code>配置文件了。</p>
<p>于是从<code>activation</code>包中将mailcap.default文件拷贝到<code>META-INF</code>中，并更新了maven打包的配置。</p>
<p>结果，还是不行？</p>
<p>难道还是要在代码中加入<code>mailcap</code>的配置？尝试了一下在代码中加入相关配置代码，的确可以正常发送邮件，但是这样的解决办法是在是太不爽了。</p>
<h1 id="那继续看看还有哪儿出问题了。"><a href="#那继续看看还有哪儿出问题了。" class="headerlink" title="那继续看看还有哪儿出问题了。"></a>那继续看看还有哪儿出问题了。</h1><p>于是我在发送邮件之前将当期的支持的mimetype都打印出来看看。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">log</span>.isInfoEnabled())&#123;</span><br><span class="line">       MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap();</span><br><span class="line">       <span class="built_in">log</span>.info(<span class="string">"mail mimetypes:'&#123;&#125;' multipart/mixed:'&#123;&#125;' "</span>, mc.getMimeTypes(), mc.getAllCommands(<span class="string">"multipart/mixed"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在server端单元测试的输出和打包后的输出有很大的差异。</p>
<ul>
<li>单元测试的输出</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">mail mimetypes:'[<span class="built_in">text</span>/html, message/rfc822, multipart/*, <span class="built_in">text</span>/xml, <span class="built_in">text</span>/plain, <span class="built_in">text</span>/*, image/jpeg, image/gif]' multipart/mixed:'[javax.activation.CommandInfo@<span class="number">349859e0</span>]'</span><br></pre></td></tr></table></figure>
<ul>
<li>打包后的输出</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">mail <span class="string">mimetypes:</span><span class="string">'text/*'</span></span><br></pre></td></tr></table></figure>
<p>看样子应该是打包之后配置加载问题。</p>
<p>再重新check一下<code>MailcapCommandMap</code>的代码，看样子应该是这段代码的缘故。</p>
<figure class="highlight d"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(MailcapCommandMap.<span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(defDB == <span class="literal">null</span>) &#123;</span><br><span class="line">        defDB = <span class="keyword">this</span>.loadResource(<span class="string">"/META-INF/mailcap.default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看样子，应该是defDB中有<code>[text/*]</code>,所以，就没有走到读取<code>/META-INF/mailcap.default</code>文件</p>
<h1 id="最终解决办法"><a href="#最终解决办法" class="headerlink" title="最终解决办法"></a>最终解决办法</h1><p>其实也很简单，将<code>mailcap.default</code>重命名为<code>mailcap</code>就好了。<code>MailcapCommandMap</code>不管怎么样都会读取到<code>mailcap</code>文件了。</p>
<h2 id="MailcapCommandMap相关代码"><a href="#MailcapCommandMap相关代码" class="headerlink" title="MailcapCommandMap相关代码"></a>MailcapCommandMap相关代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LogSupport.log(<span class="string">"MailcapCommandMap: load JAR"</span>);</span><br><span class="line"><span class="keyword">this</span>.loadAllResources(dbv, <span class="string">"META-INF/mailcap"</span>);</span><br><span class="line">LogSupport.log(<span class="string">"MailcapCommandMap: load DEF"</span>);</span><br><span class="line">synchronized(MailcapCommandMap.<span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(defDB == <span class="literal">null</span>) &#123;</span><br><span class="line">        defDB = <span class="keyword">this</span>.loadResource(<span class="string">"/META-INF/mailcap.default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mailcap配置"><a href="#mailcap配置" class="headerlink" title="mailcap配置"></a>mailcap配置</h2><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Default mailcap file for the JavaMail System.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># JavaMail content-handlers:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">text/plain;;		x-java-content-handler=com.sun.mail.handlers.text_plain</span><br><span class="line">text/html;;		x-java-content-handler=com.sun.mail.handlers.text_html</span><br><span class="line">text/xml;;		x-java-content-handler=com.sun.mail.handlers.text_xml</span><br><span class="line">multipart<span class="comment">/*;;		x-java-content-handler=com.sun.mail.handlers.multipart_mixed; x-java-fallback-entry=true</span><br><span class="line">message/rfc822;;	x-java-content-handler=com.sun.mail.handlers.message_rfc822</span></span><br></pre></td></tr></table></figure>
<h2 id="Maven-assembly中mailcap相关配置"><a href="#Maven-assembly中mailcap相关配置" class="headerlink" title="Maven assembly中mailcap相关配置"></a>Maven assembly中mailcap相关配置</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;file&gt;</span></span><br><span class="line">    <span class="params">&lt;source&gt;</span>src<span class="meta-keyword">/main/</span>resources/META-INF/mailcap<span class="params">&lt;/source&gt;</span></span><br><span class="line">    <span class="params">&lt;outputDirectory&gt;</span>META-INF<span class="params">&lt;/outputDirectory&gt;</span></span><br><span class="line"><span class="params">&lt;/file&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.jboss.org/thread/176802?_sscc=t" target="_blank" rel="external">https://developer.jboss.org/thread/176802?_sscc=t</a><br><a href="http://www.jguru.com/faq/view.jsp?EID=237257" target="_blank" rel="external">http://www.jguru.com/faq/view.jsp?EID=237257</a><br><a href="http://jimwayne.blogspot.jp/2013/02/no-object-dch-for-mime-type.html" target="_blank" rel="external">http://jimwayne.blogspot.jp/2013/02/no-object-dch-for-mime-type.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用“六顶思考帽”优化会议效率]]></title>
      <url>http://tonydeng.github.io/2015/10/24/the-six-thinking-hats/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/the-six-thinking-hasts/hasts.jpg" alt="六顶思考帽"></p>
<h1 id="为何我们讨厌开会"><a href="#为何我们讨厌开会" class="headerlink" title="为何我们讨厌开会"></a>为何我们讨厌开会</h1><p>“哎！今天糟透了，开了一天的会却什么问题也没有解决。我的忍耐力已经到了极限了,这个该死的会议不仅不不能解决问题，而且还在破坏我的团队。我的工作已经不得不因为会议再次延迟了，我不明白会议到底是要解决问题而是要巩固某些人在公司的政治地位。他们到底何时才能明白，当一条大船即将沉没的时候，船员需要的发号施令的船长，而不是一天又一天的开会！”</p>
<p>上面的话，是曾经我的一个同事兼好友在很久之前的某一天在聊天时向我吐槽他们公司无效的会议给他带来的困扰。这段话我印象非常深刻，因为我有时候也有同样地想法。不知道大家看到上面的一段话，是否也于心有戚戚耶。</p>
<a id="more"></a>
<p>不过，作为一个已经踏入到管理职能的职场人来说，开会对于你日常的工作来说，这些都是必不可少的，甚至对于有些职能来说，会议基本上可能是他工作的全部或大部分。</p>
<p>那么，为什么我们还吐槽呢？</p>
<p><strong>其实我们吐槽的不是会议，而是无效的会议。</strong></p>
<h1 id="为什么我们要开会？"><a href="#为什么我们要开会？" class="headerlink" title="为什么我们要开会？"></a>为什么我们要开会？</h1><p>我们先来看看词典对<a href="http://cn.bing.com/knows/search?intlF=0&amp;q=%E5%BC%80%E4%BC%9A&amp;FORM=HDRSC7&amp;mkt=zh-cn" target="_blank" rel="external">“开会”的解释</a></p>
<blockquote>
<p>开会：召集若干人议事；多人聚集于一定处所议事；举行会议或集会；有会议或集会。</p>
</blockquote>
<p>会议的意义是什么呢？</p>
<p>广义的会议就是让不同的人走到一起来交流，通过思想的碰撞，产生新的想法和创意。</p>
<p>从某种角度来说，会议可能是一个公司成本较高的一种行为,也是组织中不能缺少的一种工作方式。</p>
<p>因为，一般参加会议的人都会是属于这个组织中的管理者和核心员工，这些人的时间成本和经济成本在组织中都是非常高的。如果会议没有效率，那么对组织的影响和伤害是非常大的。</p>
<p>这些的问题，应该大部分的人都能够意识到，为什么我们还是会面临这样的状况呢？</p>
<blockquote>
<p>“争论中，争论双方都是对的，但是他们看到的知识事物的不同侧面”。– 爱德华·德·波诺</p>
</blockquote>
<p>很多时候，由于参加会议的人经历、见识、立场都各有不同，看同一事物的角度和方法都各有差异。如果各自都坚持自己的看法，那必须是一个争执不休的场景。就算是最擅长妥协和权限的政治家们，也会出现这样的如下的场景。</p>
<p><img src="/images/blog/the-six-thinking-hasts/parliament.png" alt="议会"></p>
<p>甚至有这样暴力+香艳的场面，<a href="http://news.163.com/08/0125/14/432G47RF0001121M.html" target="_blank" rel="external">世界议会暴力大观：日本女议员打架掉胸罩(组图)</a>，来自有态度的网易新闻，大家有兴趣，可以去自己点击链接去查看 ^_^</p>
<h1 id="会议无效率的原因"><a href="#会议无效率的原因" class="headerlink" title="会议无效率的原因"></a>会议无效率的原因</h1><p>我的理解中，会议对于一个组织来说，是<strong>一个能够快速沟通并达成一致结论的方式和工具</strong>。</p>
<p>但是现实工作中，我们在会议上花费了太多的时间，这些原本能够为公司产生生产力的时间，都浪费在冗长而低效的会议室上。这些会议通常洋溢着令人厌烦的气氛，大多数时候，我们都得到这样的结论–“会议在拖我们的后腿”。</p>
<p>仔细分析一下，一般“拖我们后腿的会议”都有如下几个特点：</p>
<ol>
<li>会议的主题不明确。</li>
<li>会议讨论的过程中太过发散，跳跃性过大，导致整个会议过程拖沓。</li>
<li>会议主持人控制力不够。</li>
<li>争执不休，无法决策。</li>
<li>会议结束后也没有具体的结论和方案。</li>
<li>……</li>
</ol>
<p>其实这些特点，总体来说，就是在<strong>会议过程中的某（zheng）个（ge）环节（主题、人、过程……）上缺乏聚焦</strong>。</p>
<p>另外，还有一个非常重要的问题，就是会后的执行，好多时候，会开完了就大家就开始“玩会儿了”。</p>
<h1 id="六顶思考帽介绍"><a href="#六顶思考帽介绍" class="headerlink" title="六顶思考帽介绍"></a>六顶思考帽介绍</h1><p>我们先看看<a href="https://wikipedia.org" target="_blank" rel="external">维基百科</a>的<a href="https://zh.wikipedia.org/zh-cn/%E5%85%AD%E9%A1%B6%E6%80%9D%E8%80%83%E5%B8%BD%E5%AD%90" target="_blank" rel="external">六顶思考帽的定义</a>（如要翻墙，请自备梯子）：</p>
<blockquote>
<p>德·波诺帽子方法，或称为六顶帽思考方法，是一种将群体讨论和个体思考相结合的思考方法。这种思考方法是由<a href="https://zh.wikipedia.org/wiki/%E6%84%9B%E5%BE%B7%E8%8F%AF%C2%B7%E5%BE%B7%C2%B7%E6%B3%A2%E8%AB%BE" target="_blank" rel="external">爱德华·德·波诺</a>在其介绍思考方法的书籍<a href="http://book.douban.com/subject/3031961/" target="_blank" rel="external">六顶思考帽（Six Thinking hats）</a>中提出的，该书全球销量超过3000万册。</p>
</blockquote>
<h2 id="每顶帽子的定义"><a href="#每顶帽子的定义" class="headerlink" title="每顶帽子的定义"></a>每顶帽子的定义</h2><h3 id="白色思考帽："><a href="#白色思考帽：" class="headerlink" title="白色思考帽："></a>白色思考帽：</h3><blockquote>
<p>中立而客观。<br>白色思考帽代表客观的事实与数据。<br>我们需要得到什么资讯？</p>
</blockquote>
<h3 id="红色思考帽："><a href="#红色思考帽：" class="headerlink" title="红色思考帽："></a>红色思考帽：</h3><blockquote>
<p>暗示著愤怒与情感。<br>红色思考帽代表情绪上的感觉、直觉和预感。<br>现在你感觉这个怎么样？但你不必刻意去证明你的感觉。</p>
</blockquote>
<h3 id="黑色思考帽："><a href="#黑色思考帽：" class="headerlink" title="黑色思考帽："></a>黑色思考帽：</h3><blockquote>
<p>负面。<br>黑色思考帽也就是考虑事物的负面因素，它是对事物负面因素的注意、判断和评估。<br>这是真的吗？它会起作用吗？缺点是什么？它有什么问题？为什么不能做。</p>
</blockquote>
<h3 id="黄色思考帽："><a href="#黄色思考帽：" class="headerlink" title="黄色思考帽："></a>黄色思考帽：</h3><blockquote>
<p>耀眼、正面。<br>黄色思考帽代表乐观、希望与正面思想。<br>为什么这个值得做？为什么可以作这件事？它为什么会起作用？</p>
</blockquote>
<h3 id="绿色思考帽："><a href="#绿色思考帽：" class="headerlink" title="绿色思考帽："></a>绿色思考帽：</h3><blockquote>
<p>草地的颜色。<br>绿色思考帽代表创意与创造性新的想法。<br>有不同的想法？新的想法、建议和假设是什么？可能的解决办法和行动的过程是什么？其他可能的选择是什么？</p>
</blockquote>
<h3 id="蓝色思考帽："><a href="#蓝色思考帽：" class="headerlink" title="蓝色思考帽："></a>蓝色思考帽：</h3><blockquote>
<p>天空的颜色。<br>蓝色思考帽代表思维过程的控制与组织。<br>它可以控制其他思考帽的使用。</p>
</blockquote>
<p><img src="/images/blog/the-six-thinking-hasts/6K-by-xmind.png" alt="XMind提供的六顶思考帽模板"></p>
<blockquote>
<p><a href="http://www.xmind.net/" target="_blank" rel="external">XMind</a>也提供了<a href="http://www.xmind.net/m/6K7b/" target="_blank" rel="external">六顶思考帽的模板</a>，大家如果使用XMind的话，可以直接创建六顶思考帽的思维导图。</p>
</blockquote>
<h2 id="六个思考帽能够解决的问题"><a href="#六个思考帽能够解决的问题" class="headerlink" title="六个思考帽能够解决的问题"></a>六个思考帽能够解决的问题</h2><ol>
<li>聚焦并且改进想法的过程</li>
<li>鼓励创造性，平行和水平思考</li>
<li>改进沟通</li>
<li>加速做决定</li>
<li>避免辩论</li>
</ol>
<h1 id="利用六顶思考帽优化开会效率"><a href="#利用六顶思考帽优化开会效率" class="headerlink" title="利用六顶思考帽优化开会效率"></a>利用六顶思考帽优化开会效率</h1><p>那我们是否可以利用六个思考帽来优化开会效率呢？我们可以先看看之前总结的<a href="#会议无效率的原因">会议无效率的原因</a>以及<a href="#六个思考帽能够解决的问题">六个思考帽能够解决的问题</a>。那聪明人应该能够想到如何利用六个帽子来解决问题了吧。</p>
<blockquote>
<p>“六顶思考帽使我们的会议时间减少了80%，同时也改变了整个欧洲的企业文化。” – J.P.摩根国际投资银行。</p>
</blockquote>
<h2 id="单独使用某一顶帽子"><a href="#单独使用某一顶帽子" class="headerlink" title="单独使用某一顶帽子"></a>单独使用某一顶帽子</h2><p>如果，会议只是单一目的，比如收集看法、讨论做某件事物的价值等等，我们可以根据会议的目的来只使用某一顶帽子就能够解决问题了。</p>
<p><img src="/images/blog/the-six-thinking-hasts/one-hast.png" alt="使用单一帽子"></p>
<h2 id="组合使用帽子"><a href="#组合使用帽子" class="headerlink" title="组合使用帽子"></a>组合使用帽子</h2><p>一般来说，我们大部分的会议都不是只用单一帽子就能够达到目的的，那么我们就要尝试组合使用帽子的方式来进行会议的讨论和决策。</p>
<p><img src="/images/blog/the-six-thinking-hasts/combination-hasts.png" alt="组合使用帽子"></p>
<p>不过，要注意的是，<strong>六顶思考帽方法可能需要一定的训练与磨合才能发挥出它的真正效果。</strong></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>比如我就在前几天的项目Review的会议上使用了六个帽子来组织了一下这个会议。</p>
<ol>
<li>先让团队的每个人都在两张便签纸上分别写出，在本次项目中自己觉得“最爽”和“最不爽”的三点，写完后贴在白板上。 <strong>（黑色帽子 + 黄色帽子）</strong></li>
<li>每个人陈述自己觉得爽和不爽的原因，并举例子说明。<strong>（红色帽子）</strong></li>
<li>大家一起对所有人的“最爽”和“最不爽”进行归类，并且对归类后的条目进行计票。 <strong>（蓝色帽子）</strong></li>
<li>大家一起分析“最不爽”的现状。<strong>（白色帽子）</strong></li>
<li>每个人提出对“最不爽”的改进意见。 <strong>（绿色帽子）</strong></li>
<li>大家从改进意见中找出最可能执行成功的方案。 <strong>（蓝色帽子）</strong></li>
</ol>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>OK，这篇Blog也断断续续抽空的写了好几天，关于<strong>会议</strong>、<strong>效率</strong>以及<strong>六顶思考帽</strong>这些都是非常大的话题，并不是一篇短短的Blog能够描述清楚的。只是对于我来说，作为一个自己对这些事情和内容的思考和总结，同时希望能够对看到这篇Blog的人也有帮助。</p>
<p>另外，再说一点多余的话，虽然与这篇Blog主题关系不太大，不过，也是我为什么之前在项目Review会议中使用“六顶思考帽”的方式来组织会议的原因之一，先随便说说，要是哪天心血来潮，自己再刨个坑，一篇详细点的Blog在仔细说说。</p>
<p>现实中，作为团队管理者的我们有一项不容忽视的问题，就是团队建设（不仅仅是吃饭）。</p>
<p>比如我们要在团队内推行一个新的制度或方法。如果，硬性地作为团队的大方法论强制实施，或许能加快该制度或方法的推广速度。但是我认为，任何出自<strong>非团队意识</strong>的<strong>强迫</strong>的活动，都会让团队感觉到“他们在领导眼里不能自理，需要‘学生手册’来约束自己”，这无疑会打消团队的积极性。</p>
<p>团队成员可能以一种，沉默不抵抗的方式应对让他们头疼的流程。</p>
<p>因此，我建议，要么征求团队意见，集体达成一致；要么就作为你自己的思考方式，在团队中隐晦地加以利用。</p>
<p>就好比，我在项目Review会议上用的方法，所有的人都参与到整个改进方案的建设中，这样大家就更容易接受这些方案。你再后续的推行这些改进方案整个团队就更加容易接受了。</p>
<p>好了，不写了，洗洗睡觉去了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于用户体验的讨论和思考]]></title>
      <url>http://tonydeng.github.io/2015/10/21/discussion-on-user-experience/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/user-experience/user-experience.png" alt="user experience"></p>
<p>昨天晚上媳妇跟我说，他们的产品负（jiao）责（shi）人（gun）说”交互设计就是UI，产品界面上什么按钮该放哪儿，页面该怎么跳转，这些都是<strong>用户体验</strong>“，转达了他们产品负责人的话之后，媳妇继续问：“我觉得她说的不对，我认为用户体验是UI（界面设计）+UE（交互设计）。”</p>
<p>媳妇的这个问题让我陷入了思考，现在互联网从业人员都在谈“用户体验”，包括传统行业的从业人员也在谈“互联网思维”，也谈“用户体验”。<strong>那么用户体验到底是一个什么东西？是否就是UI+UE？</strong>，也让我有了写这篇Blog的冲动。</p>
<a id="more"></a>
<h2 id="什么是用户体验"><a href="#什么是用户体验" class="headerlink" title="什么是用户体验"></a>什么是用户体验</h2><p>简略来说，用户体验是一种在用户<strong>使用</strong>一个产品（服务）的<strong>过程</strong>中建立起来的<strong>纯主观</strong>的<strong>心理感受</strong>。</p>
<p>而从系统上讲，用户体验是一个<strong>全方位的概念</strong>，在产品的<strong>不同阶段</strong>，<strong>不同渠道</strong>，每一个可能和产品、服务，以及企业本身<strong>接触的地方都能产生用户体验</strong>。</p>
<p>互联网产品的用户体验比其他任何产品都重要。因为它是一个“自助式”的产品，没有事先阅读的说明书，没有任何操作培训或讨论会，也没有客户服务代表来帮助用户了解这个产品如何使用。</p>
<p>不过，现在很多互联网公司也主要到了原来互联网产品在这块的问题，现在很多APP都添加了很多用户使用引导的功能，相信大家也都体会过，对自己实际使用这个产品的帮助并不是那么大，更多使用方式的都是靠自己摸索。</p>
<h2 id="影响用户体验的因素"><a href="#影响用户体验的因素" class="headerlink" title="影响用户体验的因素"></a>影响用户体验的因素</h2><p>我们来看看一张网络上的老图。</p>
<p><img src="/images/blog/user-experience/more-information.jpg" alt="more infomation"></p>
<p>虽然只是讲了建设一个网站的工作并不像表面看起来的那么简单，但是就像我们上面描述的那样，用户主观的心理感受不是仅仅只是表面的工作能够满足到的。所以，用户体验当然不仅仅是“UI+UE”。</p>
<p>有许多因素可以影响用户时间使用的体验，用户的个体差异也决定了每个用户的真实感受/体验是无法通过有效途径来完全模拟或再现的。不过，对于一个界定明确的用户群体来讲，其用户体验的共性是能够通过良好设计的测试/实验来认识到的。</p>
<p>我们来看相对全面的用户体验所涉及的领域：</p>
<p><img src="/images/blog/user-experience/user-experience-in-the-areas-of.jpg" alt="用户体验涉及的领域"></p>
<p>所以，谈到用户体验，作为提供产品（服务）的组织来说，其实涉及到该组织内每一个成员的贡献。</p>
<p>就拿互联网企业来说，产品功能设计（产品经理）、用户界面设计（UI）、用户交互设计（UE）、产品内容（运营、商务、BD）、产品稳定性和响应速度（技术）等方面对用户的体验都是有影响的。大家想一想看看是不是这样？</p>
<p>说到底，“用户体验”就是一切以用户为中心。国外有一句经典商业名言：“客户就是上帝”，古代的中国商人也用“衣食父母”来比喻客户对商家的重要性（虽然，最早的出处是关汉卿在《<a href="http://baike.baidu.com/subview/13964/5887709.htm" target="_blank" rel="external">窦娥冤</a>》中由昏官桃杌太守之口说出）。</p>
<p>所以，作为我们每一个互联网从业人员来说，用户体验应该是我们始终在脑海中绷紧的一根弦，并且要在实际工作付诸行动的行为准则之一（并不是喊喊口号而已，也不是某些人掩饰自己能力不足的借口）。在产品开发的每一个步骤中，都要把用户体验列入到考虑范围中。</p>
<h2 id="用户体验的要素"><a href="#用户体验的要素" class="headerlink" title="用户体验的要素"></a>用户体验的要素</h2><p>那什么样的用户体验才算是好呢？如何来验证呢？</p>
<p>其实，在2000年3月（15年前）就有人总结出了用户体验的要素。</p>
<p>我们来看看<a href="http://www.amazon.com/o/ASIN/0735712026/ref=nosim/jjgnet-20/" target="_blank" rel="external">《用户体验的要素》</a>的作者<a href="http://blog.jjg.net/" target="_blank" rel="external">Jesse James Garrett</a>是怎么来说的。</p>
<p><img src="/images/blog/user-experience/the-elements-of-user-expexrience-en.jpg" alt="用户体验的要素"></p>
<p>这张图是国人翻译的</p>
<p><img src="/images/blog/user-experience/the-elements-of-user-expexrience-zh.jpg" alt="用户体验的要素"></p>
<h2 id="附录：Jesse-James-Garrett关于用户体验要素的演讲"><a href="#附录：Jesse-James-Garrett关于用户体验要素的演讲" class="headerlink" title="附录：Jesse James Garrett关于用户体验要素的演讲"></a>附录：Jesse James Garrett关于用户体验要素的演讲</h2><p>我们来看看Jesse James Garrett再Adaptive path工作坊上的演讲《用户体验的要素》，这个PPT非常精彩，覆盖了整个团队内部分工、产品设计要素以及项目管理要点等各个方面，非常值得大家去仔细揣摩。</p>
<h3 id="用户体验的要素-1"><a href="#用户体验的要素-1" class="headerlink" title="用户体验的要素"></a>用户体验的要素</h3><p><img src="/images/blog/user-experience/ppt/00.png" alt="00"></p>
<h3 id="认识用户体验的要素"><a href="#认识用户体验的要素" class="headerlink" title="认识用户体验的要素"></a>认识用户体验的要素</h3><p><img src="/images/blog/user-experience/ppt/01.png" alt="01"></p>
<h3 id="史上最差的一些电影"><a href="#史上最差的一些电影" class="headerlink" title="史上最差的一些电影"></a>史上最差的一些电影</h3><p><img src="/images/blog/user-experience/ppt/02.png" alt="02"></p>
<h3 id="究竟谁应该受到指责呢？"><a href="#究竟谁应该受到指责呢？" class="headerlink" title="究竟谁应该受到指责呢？"></a>究竟谁应该受到指责呢？</h3><ul>
<li>用户可能会说：“我可能没有好好选择？”，“我一定是没有好好看说明书”，“或许我不够聪明”….</li>
<li>对于不优的产品，用户承担了不必要的责罚。</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/03.png" alt="03"></p>
<h3 id="如果把产品也看做是人"><a href="#如果把产品也看做是人" class="headerlink" title="如果把产品也看做是人"></a>如果把产品也看做是人</h3><p><img src="/images/blog/user-experience/ppt/04.png" alt="04"></p>
<h3 id="以用户为中心的设计"><a href="#以用户为中心的设计" class="headerlink" title="以用户为中心的设计"></a>以用户为中心的设计</h3><ul>
<li>这是产品开发必须遵循的理念和态度</li>
<li>产品自身不是结束</li>
<li>产品是为了最终能提供满足用户优良的交互体验而生的一种手段</li>
<li>它是强调理解用户而不是技术的理论体系</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/05.png" alt="05"></p>
<h3 id="用户体验关注什么？"><a href="#用户体验关注什么？" class="headerlink" title="用户体验关注什么？"></a>用户体验关注什么？</h3><ul>
<li>一个产品的行为是怎样的，在实际生活中如何应用</li>
<li>超越产品自身，关注它与人们生活的联结</li>
<li>它包含各个范畴的因素</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/06.png" alt="06"></p>
<h3 id="外观层"><a href="#外观层" class="headerlink" title="外观层"></a>外观层</h3><p><img src="/images/blog/user-experience/ppt/07.png" alt="07"></p>
<h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><p><img src="/images/blog/user-experience/ppt/08.png" alt="08"></p>
<h3 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h3><p><img src="/images/blog/user-experience/ppt/09.png" alt="09"></p>
<h3 id="范围层"><a href="#范围层" class="headerlink" title="范围层"></a>范围层</h3><p><img src="/images/blog/user-experience/ppt/10.png" alt="10"></p>
<h3 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h3><p><img src="/images/blog/user-experience/ppt/11.png" alt="11"></p>
<h3 id="用户体验要素的五大层级"><a href="#用户体验要素的五大层级" class="headerlink" title="用户体验要素的五大层级"></a>用户体验要素的五大层级</h3><p><img src="/images/blog/user-experience/ppt/12.png" alt="12"></p>
<h3 id="扫除一些名词障碍"><a href="#扫除一些名词障碍" class="headerlink" title="扫除一些名词障碍"></a>扫除一些名词障碍</h3><p>信息设计、功能说明、交互设计、信息架构、界面设计、内容需求、导航设计</p>
<p><img src="/images/blog/user-experience/ppt/13.png" alt="13"></p>
<h3 id="网站的二元性：作为信息源的网站"><a href="#网站的二元性：作为信息源的网站" class="headerlink" title="网站的二元性：作为信息源的网站"></a>网站的二元性：作为信息源的网站</h3><p><img src="/images/blog/user-experience/ppt/14.png" alt="14"></p>
<h3 id="网站的二元性：作为软件应用的网站"><a href="#网站的二元性：作为软件应用的网站" class="headerlink" title="网站的二元性：作为软件应用的网站"></a>网站的二元性：作为软件应用的网站</h3><p><img src="/images/blog/user-experience/ppt/15.png" alt="15"></p>
<h3 id="网站基本的二元性"><a href="#网站基本的二元性" class="headerlink" title="网站基本的二元性"></a>网站基本的二元性</h3><p><img src="/images/blog/user-experience/ppt/16.png" alt="16"></p>
<p><img src="/images/blog/user-experience/ppt/17.png" alt="17"></p>
<h3 id="战略层-1"><a href="#战略层-1" class="headerlink" title="战略层"></a>战略层</h3><ul>
<li>用户需求：网站必须为使用它的人提供些什么</li>
<li>网站目的：网站必须为建立它的人做些什么</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/18.png" alt="18"></p>
<h3 id="用户需求"><a href="#用户需求" class="headerlink" title="用户需求"></a>用户需求</h3><ul>
<li>一些基本原则——用户使用产品必须能够：<ul>
<li>工作</li>
<li>可操作使用</li>
<li>达到一些期望</li>
</ul>
</li>
<li>但是大部分时候需要根据实际使用对象和产品具体分析</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/19.png" alt="19"></p>
<h3 id="用户调研"><a href="#用户调研" class="headerlink" title="用户调研"></a>用户调研</h3><ul>
<li>这是最好的方式来了解用户实际需求</li>
<li>很多方式方法：从快速、廉价到长期、昂贵的都有</li>
<li>推荐一本好书《Observing the User Experience》</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/20.png" alt="20"></p>
<h3 id="用户细分"><a href="#用户细分" class="headerlink" title="用户细分"></a>用户细分</h3><ul>
<li>可以控制地识别用户需求</li>
<li>通过用户共性特征分类</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/21.png" alt="21"></p>
<h3 id="用户模型"><a href="#用户模型" class="headerlink" title="用户模型"></a>用户模型</h3><ul>
<li>以用户调研为基础的特征描述</li>
<li>从一系列常规特征推论到具体事件</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/22.png" alt="22"></p>
<h3 id="网站目的"><a href="#网站目的" class="headerlink" title="网站目的"></a>网站目的</h3><ul>
<li>经常与商业性有关</li>
<li>商业目的</li>
<li>商业驱动</li>
<li>商业需求</li>
<li>需要具体问题具体分析</li>
<li>独立于组织结构的其他行为</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/23.png" alt="23"></p>
<h3 id="成功的度量流量"><a href="#成功的度量流量" class="headerlink" title="成功的度量流量"></a>成功的度量流量</h3><ul>
<li>唯一的方法用来获知改变网站设计有何不同</li>
<li>紧密地与站点目标连接</li>
<li>未来将会更广泛应用</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/24.png" alt="24"></p>
<h3 id="范围层-1"><a href="#范围层-1" class="headerlink" title="范围层"></a>范围层</h3><ul>
<li>功能说明：网站应有的应用特色</li>
<li>内容需求：网站必须包含的基本内容</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/25.png" alt="25"></p>
<h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li>什么样的特色应用是用户需要用来完成目标的？</li>
<li>聚焦在“它该做什么”<ul>
<li>而不是“它怎么工作”</li>
<li>也不是“它什么不能做”</li>
</ul>
</li>
<li>具体一些，但不要指使系统设计</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/26.png" alt="26"></p>
<h3 id="内容需求"><a href="#内容需求" class="headerlink" title="内容需求"></a>内容需求</h3><ul>
<li>什么样的信息是用户需要的或想从网站获取的</li>
<li>它采用何种形式</li>
<li>它的来源是哪里</li>
<li>谁来负责？</li>
<li>根据目的定义要点</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/27.png" alt="27"></p>
<h3 id="跟进文档"><a href="#跟进文档" class="headerlink" title="跟进文档"></a>跟进文档</h3><ul>
<li>文档是在浪费时间？<ul>
<li>没人看</li>
<li>它们从来不是最新的</li>
<li>维护起来很麻烦</li>
</ul>
</li>
<li>花在规划网站的时间是为制作网站的时候节约时间</li>
<li>把文档融进进程，而不是作为一个独立的步骤</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/28.png" alt="28"></p>
<h3 id="结构层-1"><a href="#结构层-1" class="headerlink" title="结构层"></a>结构层</h3><ul>
<li>交互设计：用户如何在过程中从一步移到另一步</li>
<li>信息架构：用户如何从一个内容要素移到下一个</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/29.png" alt="29"></p>
<h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><ul>
<li>交互行为<ul>
<li>一方面用户能够使用系统</li>
<li>另一方面系统能够反馈给用户信息</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/30.png" alt="30"></p>
<h3 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h3><ul>
<li>明确各内容要素间的概念关系</li>
<li>影响用户思考主题</li>
<li>常常是等级式的，但也不是一定的</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/31.png" alt="31"></p>
<h3 id="自上而下-VS-自下而上"><a href="#自上而下-VS-自下而上" class="headerlink" title="自上而下 VS 自下而上"></a>自上而下 VS 自下而上</h3><ul>
<li>自上而下以分类开始，再对内容进行归类</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/32.png" alt="32"></p>
<h3 id="自上而下-VS-自下而上-1"><a href="#自上而下-VS-自下而上-1" class="headerlink" title="自上而下 VS 自下而上"></a>自上而下 VS 自下而上</h3><ul>
<li>自下而上以内容开始，最后集结成几类</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/33.png" alt="33"></p>
<h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><ul>
<li>可视化的表达更有效</li>
<li>根据需要，图表可繁可简</li>
<li>更多说明欢迎访问以下网址</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/34.png" alt="34"></p>
<h3 id="框架层-1"><a href="#框架层-1" class="headerlink" title="框架层"></a>框架层</h3><ul>
<li>信息设计：帮助用户理解信息</li>
<li>界面设计：帮助用户输入，促进系统输出</li>
<li>导航设计：为用户提供更轻松便捷的移动操作</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/35.png" alt="35"></p>
<h3 id="信息设计"><a href="#信息设计" class="headerlink" title="信息设计"></a>信息设计</h3><ul>
<li>我们如何表达信息使得人们理解并使用它</li>
<li>从不同信息中传达出相对重要的信息</li>
<li>引导用户从一条信息到另一条</li>
<li>提醒重要细节</li>
<li>传达各元素联系</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/36.png" alt="36"></p>
<h3 id="Google-Maps的例子"><a href="#Google-Maps的例子" class="headerlink" title="Google Maps的例子"></a>Google Maps的例子</h3><p><img src="/images/blog/user-experience/ppt/37.png" alt="37"></p>
<h3 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h3><ul>
<li>为用户提供与应用程序功能交互的一种可视化方式</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/38.png" alt="38"></p>
<h3 id="导航设计"><a href="#导航设计" class="headerlink" title="导航设计"></a>导航设计</h3><ul>
<li>表达出用户可以有哪些选择</li>
<li>使用户移动操作更便利</li>
<li>不同的设计有不同的效果</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/39.png" alt="39"></p>
<h3 id="线框图"><a href="#线框图" class="headerlink" title="线框图"></a>线框图</h3><ul>
<li>将所有框架议题放到一个高度概括的“草图”里</li>
<li>图示表达页面元素相对优先级</li>
<li>建议页面布局的方式</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/40.png" alt="40"></p>
<h3 id="外观层-1"><a href="#外观层-1" class="headerlink" title="外观层"></a>外观层</h3><ul>
<li>视觉设计：“外观和感觉”中的“外观”</li>
<li>经常会有部分人认为你在说“网页设计”</li>
<li>不仅是美学范畴</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/41.png" alt="41"></p>
<h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p><img src="/images/blog/user-experience/ppt/42.png" alt="42"></p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><img src="/images/blog/user-experience/ppt/43.png" alt="43"></p>
<h3 id="用户体验的要素-2"><a href="#用户体验的要素-2" class="headerlink" title="用户体验的要素"></a>用户体验的要素</h3><p><img src="/images/blog/user-experience/ppt/44.png" alt="44"></p>
<h3 id="要素的应用举例"><a href="#要素的应用举例" class="headerlink" title="要素的应用举例"></a>要素的应用举例</h3><p><img src="/images/blog/user-experience/ppt/45.png" alt="45"></p>
<h3 id="以搜索引擎为例"><a href="#以搜索引擎为例" class="headerlink" title="以搜索引擎为例"></a>以搜索引擎为例</h3><ul>
<li>几乎所有的网站都有</li>
<li>每个网站的方式都有差别</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/46.png" alt="46"></p>
<h3 id="战略层-2"><a href="#战略层-2" class="headerlink" title="战略层"></a>战略层</h3><ul>
<li>用户需求<ul>
<li>用户需要搜索引擎吗？</li>
<li>是否限制了那些需要搜索功能的用户的需求？</li>
</ul>
</li>
<li>网站目的<ul>
<li>使用可操作搜索可以获取我们提供的信息么？</li>
<li>是否可操作搜索限制了网站所需要达成的目标？</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/47.png" alt="47"></p>
<h3 id="范围层-2"><a href="#范围层-2" class="headerlink" title="范围层"></a>范围层</h3><ul>
<li>产品功能说明书<ul>
<li>关键词输入</li>
<li>其他领域的特殊标准</li>
<li>缩小搜索结果范围的能力</li>
</ul>
</li>
<li>内容需求<ul>
<li>标记</li>
<li>结果数据</li>
<li>帮助文档</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/48.png" alt="48"></p>
<h3 id="结构层-2"><a href="#结构层-2" class="headerlink" title="结构层"></a>结构层</h3><ul>
<li>交互设计<ul>
<li>用户每一步可做的选择</li>
<li>多控制下的系统行为</li>
</ul>
</li>
<li>信息架构<ul>
<li>作为搜索标准的构架范围</li>
<li>元数据结构</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/49.png" alt="49"></p>
<h3 id="框架层-2"><a href="#框架层-2" class="headerlink" title="框架层"></a>框架层</h3><ul>
<li>信息设计<ul>
<li>搜索结果的布局</li>
<li>错误状态的表达</li>
</ul>
</li>
<li>界面设计<ul>
<li>用户输入的途径</li>
</ul>
</li>
<li>导航设计<ul>
<li>进入界面流和离开界面流</li>
<li>通过搜索结果移动浏览</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/50.png" alt="50"></p>
<h3 id="外观层-2"><a href="#外观层-2" class="headerlink" title="外观层"></a>外观层</h3><ul>
<li>视觉设计<ul>
<li>颜色</li>
<li>字体样式</li>
<li>布局</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/51.png" alt="51"></p>
<h3 id="提出正确的问题"><a href="#提出正确的问题" class="headerlink" title="提出正确的问题"></a>提出正确的问题</h3><ul>
<li>我们尝试解决哪些问题</li>
<li>我们针对问题提出哪些解决方法会导致什么样的结果？</li>
<li>解决办法是否促使我们重新思考其他问题？</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/52.png" alt="52"></p>
<h3 id="马拉松和短距离冲刺"><a href="#马拉松和短距离冲刺" class="headerlink" title="马拉松和短距离冲刺"></a>马拉松和短距离冲刺</h3><ul>
<li>冲刺是短期竞速<ul>
<li>快速开始</li>
<li>尽快燃烧能量</li>
</ul>
</li>
<li>马拉松是长期赛跑<ul>
<li>自己控制速度</li>
<li>选择何时燃烧能量</li>
</ul>
</li>
<li>你打算尝试那种运动？</li>
<li>哪种运动你正在做？</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/53.png" alt="53"></p>
<h3 id="回答出反对的理由"><a href="#回答出反对的理由" class="headerlink" title="回答出反对的理由"></a>回答出反对的理由</h3><ul>
<li>“市场调研可以告诉我们所有关于用户的事”<ul>
<li>人口数据可不是用户深入研究</li>
</ul>
</li>
<li>“我们就遵照网上找来的指导挨个来做”<ul>
<li>网上找的资料必定很普遍</li>
</ul>
</li>
<li>“界面是简单的——技术是复杂的”<ul>
<li>什么更复杂：机器还是人</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/54.png" alt="54"></p>
<h3 id="回答出反对的理由-1"><a href="#回答出反对的理由-1" class="headerlink" title="回答出反对的理由"></a>回答出反对的理由</h3><ul>
<li>“我们雇不起专家”<ul>
<li>任何事你都不需要专家</li>
</ul>
</li>
<li>“我们做的时候再弄明白”<ul>
<li>爵士乐可以即兴创作，设计可不行</li>
</ul>
</li>
<li>“我们做质量评估的时候再处理”<ul>
<li>那时候就晚了</li>
</ul>
</li>
<li>“时间表上没时间了”<ul>
<li>下次发布的时候节约时间吧</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/55.png" alt="55"></p>
<h3 id="该避免犯的错误"><a href="#该避免犯的错误" class="headerlink" title="该避免犯的错误"></a>该避免犯的错误</h3><ul>
<li><strong>弃权式设计：</strong>“我们应该做哪些容易完成的事”</li>
<li><strong>模仿式设计：</strong>“如果这对亚马逊网是足够好的，对我们也是”</li>
<li><strong>命令式设计：</strong>“因为我说过”</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/56.png" alt="56"></p>
<h3 id="瀑布式是危险的"><a href="#瀑布式是危险的" class="headerlink" title="瀑布式是危险的"></a>瀑布式是危险的</h3><p><img src="/images/blog/user-experience/ppt/57.png" alt="57"></p>
<h3 id="迭代式发展"><a href="#迭代式发展" class="headerlink" title="迭代式发展"></a>迭代式发展</h3><ul>
<li>网站更新不会停止</li>
<li>做你现在要做的</li>
<li>总是前瞻性地计划下次发布</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/58.png" alt="58"></p>
<h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ul>
<li>具体你选的哪项职责无关紧要——只要你把所有板块都覆盖住</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/59.png" alt="59"></p>
<h3 id="九大支柱"><a href="#九大支柱" class="headerlink" title="九大支柱"></a>九大支柱</h3><ul>
<li>常见成功团队的核心能力</li>
<li>影响团队的：<ul>
<li>职责</li>
<li>进程</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/60.png" alt="60"></p>
<h3 id="用户调研-1"><a href="#用户调研-1" class="headerlink" title="用户调研"></a>用户调研</h3><ul>
<li>以用户为中心设计的基础</li>
<li>告知所有的战略决定</li>
<li>基本职责是认识用户需求</li>
<li>头衔：<ul>
<li>用户调研员</li>
<li>可用性分析师</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/61.png" alt="61"></p>
<h3 id="站点战略"><a href="#站点战略" class="headerlink" title="站点战略"></a>站点战略</h3><ul>
<li>基本职责是定义站点目的</li>
<li>决定优先级和成功的度量法</li>
<li>头衔：<ul>
<li>商业分析师</li>
<li>产品经理</li>
<li>执行监制</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/62.png" alt="62"></p>
<h3 id="技术战略"><a href="#技术战略" class="headerlink" title="技术战略"></a>技术战略</h3><ul>
<li>主要负责功能说明书</li>
<li>决定技术平台和采用标准</li>
<li>头衔：<ul>
<li>高级工程师</li>
<li>开发主管</li>
<li>技术领头人</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/63.png" alt="63"></p>
<h3 id="内容战略"><a href="#内容战略" class="headerlink" title="内容战略"></a>内容战略</h3><ul>
<li>主要负责内容需求</li>
<li>决定合适的版式和主题</li>
<li>头衔：<ul>
<li>内容策划人</li>
<li>内容编辑</li>
<li>主编</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/64.png" alt="64"></p>
<h3 id="抽象设计"><a href="#抽象设计" class="headerlink" title="抽象设计"></a>抽象设计</h3><ul>
<li>把战略转向设计概念</li>
<li>主要负责结构层</li>
<li>有时负责范围和框架层</li>
<li>头衔：<ul>
<li>信息架构师</li>
<li>交互设计师</li>
<li>界面专家</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/65.png" alt="65"></p>
<h3 id="技术执行"><a href="#技术执行" class="headerlink" title="技术执行"></a>技术执行</h3><ul>
<li>有策略地执行技术战略</li>
<li>可能要组合很多职能：从编码到整合到测试</li>
<li>头衔：<ul>
<li>软件工程师</li>
<li>HTML开发者</li>
<li>QA测试员</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/66.png" alt="66"></p>
<h3 id="内容制作"><a href="#内容制作" class="headerlink" title="内容制作"></a>内容制作</h3><ul>
<li>有策略地执行内容战略</li>
<li>搜集，编辑，生产和部署内容（不仅是文本）</li>
<li>头衔：<ul>
<li>内容制作人</li>
<li>作者</li>
<li>编辑</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/67.png" alt="67"></p>
<h3 id="视觉设计"><a href="#视觉设计" class="headerlink" title="视觉设计"></a>视觉设计</h3><ul>
<li>有策略地实现抽象设计</li>
<li>主要负责外观层</li>
<li>有时负责框架和结构层</li>
<li>头衔：<ul>
<li>界面设计师</li>
<li>视觉设计师</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/68.png" alt="68"></p>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ul>
<li>将所有策略能力绑定</li>
<li>在小型组织里常常忽略</li>
<li>头衔：<ul>
<li>制作人</li>
<li>项目管理</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/69.png" alt="69"></p>
<h3 id="九大支柱-1"><a href="#九大支柱-1" class="headerlink" title="九大支柱"></a>九大支柱</h3><ul>
<li>不是一个九人小组</li>
<li>也不是一个九项步骤的过程</li>
<li>应该正确结合两者并深入进去研究</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/70.png" alt="70">　</p>
<h3 id="以上这些都是关于什么呢？"><a href="#以上这些都是关于什么呢？" class="headerlink" title="以上这些都是关于什么呢？"></a>以上这些都是关于什么呢？</h3><ul>
<li>开发前要做计划</li>
<li>对于你所有选择要有清晰的理由</li>
<li>清楚明确地表达</li>
<li>做人们喜爱的东西</li>
</ul>
<p><img src="/images/blog/user-experience/ppt/71.png" alt="71">　
　　</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p><img src="/images/blog/user-experience/ppt/72.png" alt="72">　</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://cuikai-wh.com/about" target="_blank" rel="external">@小轰同学</a>-<a href="http://cuikai-wh.com/wp-content/uploads/2011/01/elements-of-ue-v1.png" target="_blank" rel="external">用户体验的要素-1.0版思维导图整合版本</a></p>
<p><a href="http://www.adaptivepath.com/events/workshops/businessofux/elements0803.pdf" target="_blank" rel="external">Jesse James Garrett在adaptive path的演讲 – 用户体验的要素</a></p>
<p><a href="http://www.jjg.net/ia/visvocab/chinese.html" target="_blank" rel="external">描绘信息架构和交换设计的图示词汇表</a></p>
<p><a href="http://www.jjg.net/elements/pdf/elements.pdf" target="_blank" rel="external">The Elements of User Experience</a></p>
<p><a href="http://ww3.sinaimg.cn/large/64945e3dtw1djew0x37yng.gif" target="_blank" rel="external">产品设计-概念图</a></p>
<p><a href="http://ww3.sinaimg.cn/large/6694d7c8jw1duyly18i1mg.gif" target="_blank" rel="external">如何留住你的用户？设计你的用户体验流</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java8环境下的Maven javadoc插件的配置]]></title>
      <url>http://tonydeng.github.io/2015/10/21/maven-Javadoc-plugin-in-java8-exception-resolution/</url>
      <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天用maven在release代码时，又出现新的问题了，生成javadoc出现异常，导致release失败。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Refer to the generated Javadoc files <span class="keyword">in</span> <span class="string">'./target/site/apidocs'</span> dir.</span><br><span class="line"></span><br><span class="line">org.apache.maven.reporting.<span class="string">MavenReportException:</span></span><br><span class="line">Exit <span class="string">code:</span> <span class="number">1</span> -.<span class="regexp">/src/</span>main<span class="regexp">/java/</span>com<span class="regexp">/github/</span>tonydeng<span class="regexp">/commons/</span>utils/DigestUtils.<span class="string">java:</span><span class="number">30</span>: 警告: input没有 <span class="meta">@param</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String sha1ToHex(String input) &#123;</span><br><span class="line">	                     ^</span><br><span class="line">.<span class="regexp">/src/</span>main<span class="regexp">/java/</span>com<span class="regexp">/github/</span>tonydeng<span class="regexp">/commons/</span>utils/DigestUtils.<span class="string">java:</span><span class="number">30</span>: 警告: 没有 <span class="meta">@return</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>javadoc的插件配置是这样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>之前这个配置工作都很正常，让我百思不得其解。</p>
<p>那怎么办？</p>
<p>嗯，先升级一下maven-javadoc-plugin看看，升级到最新的2.10.3。</p>
<p>还是不行，回退java版本到java7。</p>
<p>哦，这样就可以了。看来应该是java8加了对javadoc的新的特性，我没有关注到。</p>
<p>OK，找到线索了，那就查查看。</p>
<p>先看看<a href="http://openjdk.java.net/projects/jdk8/features" target="_blank" rel="external">Java8的特性列表</a>吧。果然，Java8添加了一个Javadoc注释内容检查的特性<a href="http://openjdk.java.net/jeps/172" target="_blank" rel="external">DocLint</a>。</p>
<p>DocLint提供了一种方法来检测Javadoc的注释中的错误，希望能够在开发周期的早期和容易链接回源代码的方式。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果想忽略DocLint的使用，可以在maven-javadoc-plugin的配置中加上对DocLint的忽略。</p>
<p>最后的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>install<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">additionalparam</span>&gt;</span>-Xdoclint:none<span class="tag">&lt;/<span class="name">additionalparam</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git中文件名大小写引起的错误处理]]></title>
      <url>http://tonydeng.github.io/2015/10/21/capitalization-error-handing-in-git/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/git-branching.png" alt="git branching"></p>
<p>在团队使用Git的时候，尤其是多人合作的项目，经常会出现一个问题，就是由于同一个文件名大小写不一致导致无法合并的问题。</p>
<p>那我们应该怎么来解决呢?</p>
<a id="more"></a>
<p>可以使用git rm –cached将冲突的文件从Git仓库的缓存中删除，然后改名后再加入到git中</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git rm --cached <span class="symbol">&lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line">mv <span class="symbol">&lt;old_filename&gt;</span> <span class="symbol">&lt;new_filename&gt;</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">add</span> <span class="symbol">&lt;new_filename&gt;</span></span><br><span class="line"></span><br><span class="line">git commit -<span class="keyword">m</span> <span class="string">'rename &lt;new_filename&gt;'</span> <span class="symbol">&lt;new_filename&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然，为了一劳永逸，我们可以让团队成员都更改配置git的大小写敏感，避免某些windows用户继续制造这样的问题。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ETCD应用场景]]></title>
      <url>http://tonydeng.github.io/2015/10/19/etcd-application-scenarios/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/etcd/etcd2-0.png" alt="etcd logo"></p>
<h1 id="etcd是什么？"><a href="#etcd是什么？" class="headerlink" title="etcd是什么？"></a>etcd是什么？</h1><p>很多人对这个问题的第一反应可能是，它是一个键值存储仓库，却没有重视官方定义的后半句，用于<strong>配置共享</strong>和<strong>服务发现</strong>。</p>
<blockquote>
<p>A highly-available key value store for shared configuration and service discovery.</p>
</blockquote>
<p>实际上，etcd作为一个受到Zookeeper和doozer启发而催生的项目，除了拥有与之类似的功能外，更具有以下4个特点。（<a href="https://github.com/coreos/etcd" target="_blank" rel="external">引自etcd官方文档</a>）</p>
<ul>
<li>简单： 基于HTTP+JSON的API让你可以用CURL命令就可以轻松使用。</li>
<li>安全： 可以选择SSL客户认证机制。</li>
<li>快速： 每个实例每秒支持一千次写操作。</li>
<li>可信： 使用<a href="http://raftconsensus.github.io/" target="_blank" rel="external">Ralf</a>算法充分实现了分布式。</li>
</ul>
<a id="more"></a>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="场景一：-服务发现"><a href="#场景一：-服务发现" class="headerlink" title="场景一： 服务发现"></a>场景一： 服务发现</h2><p>服务发现（Service Discovery）要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务如何才能找到对方并建立连接。</p>
<p>从本质上说，服务发现就是要了解集群中是否有进程在监听upd或者tcp端口，并且通过名字就可以进行查找和链接。</p>
<p>要解决服务发现的问题，需要下面三大支柱，缺一不可。</p>
<ul>
<li>一个强一致性、高可用的服务存储目录。<ul>
<li>基于Ralf算法的etcd天生就是这样一个强一致性、高可用的服务存储目录。</li>
</ul>
</li>
<li>一种注册服务和健康服务健康状况的机制。<ul>
<li>用户可以在etcd中注册服务，并且对注册的服务配置<code>key TTL</code>，定时保持服务的心跳以达到监控健康状态的效果。</li>
</ul>
</li>
<li>一种查找和连接服务的机制。<ul>
<li>通过在etcd指定的主题下注册的服务业能在对应的主题下查找到。</li>
<li>为了确保连接，我们可以在每个服务机器上都部署一个proxy模式的etcd，这样就可以确保访问etcd集群的服务都能够互相连接。</li>
</ul>
</li>
</ul>
<p><img src="/images/blog/etcd/service-discovery.jpg" alt="服务发现"></p>
<p>下面我们来看一下服务发现的具体应用场景</p>
<h3 id="微服务协同工作架构中，服务动态添加。"><a href="#微服务协同工作架构中，服务动态添加。" class="headerlink" title="微服务协同工作架构中，服务动态添加。"></a>微服务协同工作架构中，服务动态添加。</h3><p>随着Docker容器的流行，多种微服务共同协作，构成一个功能相对强大的架构的案例越来越多。透明化的动态添加这些服务的需求也日益强烈。通过服务发现机制，在etcd中注册某个服务名字的目录，在该目录下存储可用的服务节点的IP。在使用服务的过程中，只要从服务目录下查找可用的服务节点进行使用即可。</p>
<p>微服务协同工作如下图：</p>
<p><img src="/images/blog/etcd/micro-services.jpg" alt="微服务"></p>
<h3 id="PaaS平台中应用多实例与实例故障重启透明化"><a href="#PaaS平台中应用多实例与实例故障重启透明化" class="headerlink" title="PaaS平台中应用多实例与实例故障重启透明化"></a>PaaS平台中应用多实例与实例故障重启透明化</h3><p>PaaS平台中的应用一般都有多个实例，通过域名，不仅可以透明的对多个实例进行访问，而且还可以实现负载均衡。</p>
<p>但是应用的某个实例随时都有可能故障重启，这时就需要动态的配置域名解析（路由）中的信息。通过etcd的服务发现功能就可以轻松解决这个动态配置的问题。</p>
<p><img src="/images/blog/etcd/multiple-instances.jpg" alt="多实例透明化"></p>
<h2 id="场景二：-消息发布和订阅"><a href="#场景二：-消息发布和订阅" class="headerlink" title="场景二： 消息发布和订阅"></a>场景二： 消息发布和订阅</h2><p>在分布式系统中，最为适用的组件间通信的方式是消息发布和订阅机制。</p>
<p>具体而言，即配置一个配置共享中心，书籍提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦有关主题有消息发布，就会实时通知订阅者。通过这种方式可以实现发布式系统配种的集中式管理和实时动态更新。</p>
<h3 id="应用中的一些配置新存放在etcd上进行集中管理"><a href="#应用中的一些配置新存放在etcd上进行集中管理" class="headerlink" title="应用中的一些配置新存放在etcd上进行集中管理"></a>应用中的一些配置新存放在etcd上进行集中管理</h3><p>这类场景的使用方式通常是这样的：</p>
<p>应用在启动的适合主动从etc获取一次配置信息，同时，在etcd节点上注册一个<code>Watcher</code>并等待，以后每次配置有更新的适合，etcd都会实时通知订阅者，以此达到获取最新配置信息的目的。</p>
<h3 id="分布式日志收集系统"><a href="#分布式日志收集系统" class="headerlink" title="分布式日志收集系统"></a>分布式日志收集系统</h3><p>这个系统的核心工作是收集分布在不同机器上的日志。</p>
<p>收集器通常按应用（或主题）来分配收集任务单元，因此可以在etcd上创建一个以应用（或主题）名目的目录，并将这个应用（或主题）相关的所有机器IP以子目录的形式存储在目录下。然后设置一个递归的etcd Watcher，递归式的健康应用（或主题）目录下所有信息的变动。这样就实现了在机器IP（消息）发生变动时，能够实时接受收集器调整任务分配。</p>
<h3 id="系统中心需要动态自动获取与人工干预修改信息请求内容"><a href="#系统中心需要动态自动获取与人工干预修改信息请求内容" class="headerlink" title="系统中心需要动态自动获取与人工干预修改信息请求内容"></a>系统中心需要动态自动获取与人工干预修改信息请求内容</h3><p>通常的解决方案是对外保留接口，例如JMX接口，来获取一些运行时的信息或提交修改的请求。</p>
<p>而引入etcd后，只需要将这些信息存放在指定的etcd目录中，即可通过http接口直接被外部访问。</p>
<p><img src="/images/blog/etcd/msg-pub-sub.jpg" alt="消息发布与订阅"></p>
<h2 id="场景三：-负载均衡"><a href="#场景三：-负载均衡" class="headerlink" title="场景三： 负载均衡"></a>场景三： 负载均衡</h2><p>在<a href="#场景一：_服务发现">场景一</a>中也提到了负载均衡（即软件负载均衡）。</p>
<p>在分布式系统中，为了保证服务的高可用以及数据一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。</p>
<p>这样的实现谁让会导致一定程度上数据写入性能的下降，但是却能够实现数据访问时的负载均衡。因为每个对等服务节点上都存有完整的数据，所有用户的访问流量就可以分流道不同的机器上。</p>
<h3 id="etcd本身分布式架构存储的信息支持负载均衡"><a href="#etcd本身分布式架构存储的信息支持负载均衡" class="headerlink" title="etcd本身分布式架构存储的信息支持负载均衡"></a>etcd本身分布式架构存储的信息支持负载均衡</h3><p>etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd是一个不错的选择。比如，业务系统中常用的二级代码表。</p>
<p>二级代码表的工作过程一般是这样，在表中存储代码，在etcd存储代码所代表的具体换衣，业务系统调用查表的过程，就需要查看表中代码的含义。所以如果把二级代码表中的小量数据存储到etcd中，不仅方便修改，也易于大量访问。</p>
<h3 id="利用etcd维护一个负载均衡节点表"><a href="#利用etcd维护一个负载均衡节点表" class="headerlink" title="利用etcd维护一个负载均衡节点表"></a>利用etcd维护一个负载均衡节点表</h3><p>etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式把请求转发给存活的多个节点。类似KafkaMQ，通过Zookeeper来维护生产者和消费者的负载均衡（也可以用etcd来做Zookeeper的工作）。</p>
<p><img src="/images/blog/etcd/load-balance.jpg" alt="负载均衡"></p>
<h2 id="场景四：-分布式通知与协调"><a href="#场景四：-分布式通知与协调" class="headerlink" title="场景四： 分布式通知与协调"></a>场景四： 分布式通知与协调</h2><p>这里讨论的分布式通知和协调，与消息发布和订阅有点相似。两者都使用了etcd的<code>Watcher</code>机制，通过注册与异步通知机制，实现分布式环境下的不同系统之间的通知与协调，从而对数据变更进行实时处理。</p>
<p>实现方式通常为：</p>
<p>不同系统都在etcd上对同一个目录进行注册，同事设置<code>Watcher</code>监控该目录的变化（如果对子目录的变化也有需求，可以设置成递归模式），当某个系统更新了etcd的目录，那么设置了<code>Watcher</code>的系统就会受到通知，并做出相应的通知，并作出相应处理。</p>
<h3 id="通过etcd进行低耦合的心跳检测"><a href="#通过etcd进行低耦合的心跳检测" class="headerlink" title="通过etcd进行低耦合的心跳检测"></a>通过etcd进行低耦合的心跳检测</h3><p>检测系统和被检测系统通过etcd上某个目录管理而非直接关联起来，这样可以大大减少系统的耦合性。</p>
<h3 id="通过etcd完成系统调度"><a href="#通过etcd完成系统调度" class="headerlink" title="通过etcd完成系统调度"></a>通过etcd完成系统调度</h3><p>某系统有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台做的一些操作，实际上只需要修改etcd上某些目录节点的状态，而etcd就会自动把这些变化通知给注册了<code>Watcher</code>的推送系统客户端，推送系统再作出相应的推送任务。</p>
<h3 id="通过etcd完成工作汇报"><a href="#通过etcd完成工作汇报" class="headerlink" title="通过etcd完成工作汇报"></a>通过etcd完成工作汇报</h3><p>大部分类似的任务分发系统，子任务启动后，到etcd来注册一个临时工作目录，并且定时将自己的进度汇报（将进度写入到这个临时目录），这样任务管理者就能够实时知道任务进度。</p>
<p><img src="/images/blog/etcd/distributed-collaborative-work.jpg" alt="分布式协同工作"></p>
<h2 id="场景五：-分布式锁"><a href="#场景五：-分布式锁" class="headerlink" title="场景五： 分布式锁"></a>场景五： 分布式锁</h2><p>因为etcd使用<code>Raft</code>算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。</p>
<p>锁服务有两种使用方式，一是保持独占，二是控制时序。</p>
<h3 id="保持独占"><a href="#保持独占" class="headerlink" title="保持独占"></a>保持独占</h3><p>即所有试图获取锁的用户最终只有一个可以得到。</p>
<p>etcd为此提供了一套实现分布式锁原子操作CAS（<code>ComparaAndSwap</code>）的API。通过设置<code>prevExist</code>值，可以保证在多个节点同时创建某个目录时，只有一个成功，而该用户即可任务是获得了锁。</p>
<h3 id="控制时序"><a href="#控制时序" class="headerlink" title="控制时序"></a>控制时序</h3><p>即所有试图获取锁的用户都会进入等待队列，获得锁的顺序是全局唯一的，同时决定了队列执行顺序。</p>
<p>etcd为此也提供了一套API（自动创建有序键），对一个目录建值是指定为<code>POST</code>动作，这样etcd就会在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）。</p>
<p>同时还可以使用API按顺序列出所有目录下的键值。此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号。</p>
<p><img src="/images/blog/etcd/distributed-lock.jpg" alt="分布式锁"></p>
<h2 id="场景六：-分布式队列"><a href="#场景六：-分布式队列" class="headerlink" title="场景六： 分布式队列"></a>场景六： 分布式队列</h2><p>分布式队列的常规用法与场景五中所描述的分布式锁的控制时序用法类似，即创建一个先进先出的队列，保证顺序。</p>
<p>另一种比较有意思的实现是<strong>在保证队列达到某个条件时再统一按顺序执行</strong>。这种方法的实现可以在<code>/queue</code>这个目录中另外再建立一个<code>/queue/condition</code>节点。</p>
<ol>
<li>condition可以表示队列大小。比如一个大的任务需要很多小任务就绪的情况下才能执行，每次有一个小任务就绪，就给这个condition数字加1，直到达到大任务规定的数字，再开始执行队列里的一系列小任务，最终执行大任务。</li>
<li>condition可以表示某个任务不在队列。这个任务可以是所有排序任务的首个执行程序，也可以是拓扑结构中没有依赖的点。通常，必须执行这些任务后才能执行队列中的其他任务。</li>
<li>condition还可以表示其它的一类开始执行任务的通知。可以由控制程序指定，当condition出现变化时，开始执行队列任务。</li>
</ol>
<p><img src="/images/blog/etcd/distributed-queue.jpg" alt="分布式队列"></p>
<h2 id="场景七：-集群监控与Leader竞选"><a href="#场景七：-集群监控与Leader竞选" class="headerlink" title="场景七： 集群监控与Leader竞选"></a>场景七： 集群监控与Leader竞选</h2><p>通过etcd来进行监控实现起来非常简单并且实时性强，用到了以下两点特性：</p>
<ol>
<li>前面几个场景已经提到了Watcher机制，当某个节点消失或由变动时，Watcher会第一时间发现并告知用户。</li>
<li>节点可以设置<code>TTL key</code>，比如每隔30s向etcd发送一次心跳使代表该节点依然存活，否则说明节点消失。</li>
</ol>
<p>这样就可以第一时间检测到各节点的健康状态，以完成集群的监控要求。</p>
<p>另外，使用分布式锁，可以完成Leader竞选。对于一些长时间CPU计算或使用IO操作，只需要由竞选出的Leader计算或处理一次，再把结果复制给其他Follower即可，从而避免重复劳动，节省计算资源。</p>
<p>Leader应用的经典场景是在<strong>搜索系统中建立全量索引</strong>。如果每个机器分别进行索引的建立，不仅耗时，而且不能保证索引的一致性。通过在etcd的CAS机制竞选Leader，由Leader进行索引计算，再降计算结果分发到其他节点。</p>
<p><img src="/images/blog/etcd/leader-election.jpg" alt="Leader竞选"></p>
<h2 id="场景八：-为什么使用etcd而不用Zookeeper？"><a href="#场景八：-为什么使用etcd而不用Zookeeper？" class="headerlink" title="场景八： 为什么使用etcd而不用Zookeeper？"></a>场景八： 为什么使用etcd而不用Zookeeper？</h2><p>阅读了“<a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="external">Zookeeper典型应用场景一览</a>”的同学可能会发现，etcd实现的这些功能，Zookeeper都能实现。那为什么要用etcd而非直接使用Zookeeper呢？</p>
<p>相比较之下，Zookeeper有如下缺点。</p>
<ol>
<li>复杂。 Zookeeper的部署维护复杂，管理员必须掌握一系列的知识和技能；而<a href="http://" target="_blank" rel="external">Paxos</a>强一致性算法也是素来以复杂难懂而闻名于世；另外，Zookeeper的使用也比较复杂，需要安装客户端，官方只提供Java和C的两种语言的接口。</li>
<li>Java编写。这里不是对Java有偏见，而是Java本身就偏向重型应用，它会引入大量的依赖。而运维人员则普遍希望机器集群能尽可能的简单，维护起来也不容易出错。</li>
<li>发展缓慢。 Apache基金会项目特有的“<a href="http://www.infoworld.com/article/2612082/open-source-software/has-apache-lost-its-way-.html" target="_blank" rel="external">Apache Way</a>”在开源界也饱受争议，其中一大原因就是由于基金会庞大的结构和松散的管理导致项目发展缓慢。</li>
</ol>
<p>而etcd作为一个后起之秀，其优点也很明显。</p>
<ol>
<li>简单。 使用Go编写部署简单；使用HTTP作为接口使用简单；使用Raft算法保证强一致性让用户易于理解。</li>
<li>数据持久化。 etcd默认数据一更新就进行持久化。</li>
<li>安全。 etcd支持SSL客户端安全认证。</li>
</ol>
<p>最后，etcd作为一个年轻的项目，正在高速迭代和开发中，这既是一个优点，也是一个缺点。</p>
<p>优点是在于它的未来具有无限的可能性，缺点是版本的迭代导致其使用的可靠性无法保证，无法得到大项目长时间使用的校验。</p>
<p>然而，目前CoreOS、Kubernetes和Cloudfoundry等知名项目均在生产环境中使用了etcd，所以总的来说，etcd值得你去尝试。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://github.com/coreos/etcd" target="_blank" rel="external">https://github.com/coreos/etcd</a></li>
<li><a href="http://jm-blog.aliapp.com/?p=1232" target="_blank" rel="external">http://jm-blog.aliapp.com/?p=1232</a></li>
<li><a href="http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/" target="_blank" rel="external">http://progrium.com/blog/2014/07/29/understanding-modern-service-discovery-with-docker/</a></li>
<li><a href="http://devo.ps/blog/zookeeper-vs-doozer-vs-etcd" target="_blank" rel="external">http://devo.ps/blog/zookeeper-vs-doozer-vs-etcd</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Netty 5用户指南]]></title>
      <url>http://tonydeng.github.io/2015/09/20/netty5-user-guide/</url>
      <content type="html"><![CDATA[<p>Netty是一个<code>NIO client/server</code>网络编程框架，可以快速且容易的开发基于协议（protocol）的网络客户端/服务端的程序，它极大简化了TCP和UDP socket编程，提供流水线化的操作。</p>
<p>“快速且容易”并不会导致应用难以维护和性能低下。Netty经过仔细设计，基于许多协议实现的经验如：<code>FTP</code>、<code>SMTP</code>、<code>HTTP</code>以及各种二进制和基于本文的老的协议，Netty成功的找到一种保证开发，稳定性，灵活性的方式，毋需折中。</p>
<p><img src="/images/blog/netty/components.png" alt="netty components"></p>
<a id="more"></a>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul>
<li>为各种传输类型提供统一的API，阻塞和非阻塞的socket</li>
<li>灵活和可扩展的事件模型，将关注点分离</li>
<li>高度可定制的线程模型-单线程，一种或多个线程池，如<a href="http://en.wikipedia.org/wiki/Staged_event-driven_architecture" target="_blank" rel="external">SEDA</a></li>
<li>真正无连接的数据报socket支持（since 3.1）</li>
</ul>
<h2 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h2><ul>
<li>提供Javadoc，用户指南和例子</li>
<li>JDK1.5以上版本不需要第三方库支持</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>更好的吞吐率，低延迟</li>
<li>较少的资源占用</li>
<li>最小化不必要的内存拷贝</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>完整的SSL/TLS， StartTLS支持</li>
</ul>
<h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><ul>
<li>作者从2003就开始写类似的框架（<code>mina</code>），一直收集用户反馈。官方的<a href="http://netty.io/wiki/user-guide-for-5.x.html" target="_blank" rel="external">user guide</a>，中文翻译的<a href="http://www.getsetter.cn/2014/07/15/netty5/" target="_blank" rel="external">用户指南</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>现如今我们使用通用的应用程序或者类库来实现系统之间的互相访问，比如，我们经常使用一个HTTP客户端来从web服务器上获取信息，或者通过web service来执行一个远程的调用。</p>
<p>然而，一个通用的协议和它的实现有时候并没用覆盖到一些场景。比如我们无法使用通用的http服务器来对庞大的文件和电子邮件进行交互，再比如我们无法处理那中准实时消息，比如财务信息和多人游戏数据。我们需要一个高效的协议实现用来处理一些特殊的场景。例如你可以实现一个基于AJAX的聊天应用，媒体流传输或者大文件传输的http服务器，你甚至可以想自己设计一个新的协议来准确定制你自己的需求。</p>
<p>另外，不可避免的事情是你不得不处理这些私有协议来确保和原有系统的互通。在这个例子中会告诉你实现一个对应该程序不损耗稳定性和性能的协议是多么的快。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="http://netty.io" target="_blank" rel="external">Netty</a>是一个提供异步事件驱动的网络应用框架，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p>
<p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p>
<p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是Netty的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。Netty的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。</p>
<h1 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h1><p>这个章节会围绕Netty核心的结构并附上一些简单的例子让你快速的入门。当你读完本章节你马上就可以用Netty写出一个客户端和一个服务端。<br>如果你在学习某些东西的时候喜欢自顶向下的方法，你可能想要从第二个章节架构概述开始，然后再回到这里。</p>
<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>如果要运行本章节中的2个例子最低要求是：Netty的最新版本(Netty5)和JDK1.6及以上。最新的Netty版本在项目<a href="http://netty.io/downloads.html" target="_blank" rel="external">下载页面</a>。为了下载到正确的JDK版本，请到你偏爱的网站下载。<br>当你在读的过程中，你可能有很多关于本章节介绍的类相关的问题，每当你想知道他们的更多的信息那么请参考API说明文档。为了方便，所有文档中涉及到的类名字都会被关联到一个在线的API说明。当然如果有任何错误信息、语法错误或者你有任何好的建议来改进文档说明，那么请联系<a href="http://netty.io/community.html" target="_blank" rel="external">netty社区</a>。</p>
<h2 id="实现Discard服务器"><a href="#实现Discard服务器" class="headerlink" title="实现Discard服务器"></a>实现Discard服务器</h2><p>世界上最简单的协议不是”Hello,World!”，是<a href="http://tools.ietf.org/html/rfc863" target="_blank" rel="external">DISCARD</a>，他是一种丢弃所有接收的数据，并不做有任何响应的协议。<br>为了实现DISCARD协议，你唯一需要做的就是忽略所有收到的数据。让我们从处理器的实现开始，处理器是由Netty生成用来处理I/O事件的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Handles a server-side channel.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123; <span class="comment">// (2)</span></span><br><span class="line">        <span class="comment">// Discard the received data silently.</span></span><br><span class="line">        ((ByteBuf) msg).release(); <span class="comment">// (3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123; <span class="comment">// (4)</span></span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>DisCardServerHandler 继承自 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="external">ChannelHandlerAdapter</a>，这个类实现了<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>接口，ChannelHandler提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="external">ChannelHandlerAdapter</a>类而不是你自己去实现接口方法。</p>
</li>
<li><p>这里我们覆盖了<code>chanelRead()</code>事件处理方法。每当从客户端收到新的数据时，这个方法会在收到消息时被调用，这个例子中，收到的消息的类型是<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a></p>
</li>
<li><p>为了实现DISCARD协议，处理器不得不忽略所有接受到的消息。<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>是一个引用计数对象，这个对象必须显示地调用release()方法来释放。请记住处理器的职责是释放所有传递到处理器的引用计数对象。通常，channelRead()方法的实现就像下面的这段代码：</p>
</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    <span class="selector-tag">try</span> &#123;</span><br><span class="line">        <span class="comment">// Do something with msg</span></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        ReferenceCountUtil<span class="selector-class">.release</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>exceptionCaught()</code>事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</li>
</ul>
<p>到目前为止一切都还比较顺利，我们已经实现了DISCARD服务的一半功能，剩下的需要编写一个<code>main()</code>方法来启动服务端的DiscardServerHandler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.discard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Discards any incoming data.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span></span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span></span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123; <span class="comment">// (4)</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span></span><br><span class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Bind and start to accept incoming connections.</span></span><br><span class="line">            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span></span><br><span class="line">            <span class="comment">// shut down your server.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">8080</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> DiscardServer(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a> 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a>会被使用。第一个经常被叫做‘<code>boss</code>’，用来接收进来的连接。第二个经常被叫做‘<code>worker</code>’，用来处理已经被接收的连接，一旦‘<code>boss</code>’接收到连接，就会把连接信息注册到‘<code>worker</code>’上。如何知道多少个线程已经被使用，如何映射到已经创建的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channels</a>上都需要依赖于<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>的实现，并且可以通过构造函数来配置他们的关系。</li>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a> 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li>
<li>这里我们指定使用<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>类来举例说明一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>如何接收进来的连接。</li>
<li>这里的事件处理类经常会被用来处理一个最近的已经接收的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a>是一个特殊的处理类，他的目的是帮助使用者配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。也许你想通过增加一些处理类比如DiscardServerHandle来配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>或者其对应的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到<code>pipline</code>上，然后提取这些匿名类到最顶层的类上。</li>
<li>你可以设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如<code>tcpNoDelay</code>和<code>keepAlive</code>。请参考<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="external">ChannelOption</a>和详细的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelConfig.html" target="_blank" rel="external">ChannelConfig</a>实现的接口文档以此可以对<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="external">ChannelOptions</a>的有一个大概的认识。</li>
<li>你关注过<code>option()</code>和<code>childOption()</code>吗？<code>option()</code>是提供给<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>用来接收进来的连接。childOption()是提供给由父管道<a href="http://netty.io/5.0/api/io/netty/channel/ServerChannel.html" target="_blank" rel="external">ServerChannel</a>接收到的连接，在这个例子中也是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>。</li>
<li>我们继续，剩下的就是绑定端口然后启动服务。这里我们在机器上绑定了机器所有网卡上的8080端口。当然现在你可以多次调用<code>bind()</code>方法(基于不同绑定地址)。</li>
</ul>
<p>恭喜！你已经完成熟练地完成了第一个基于NETTY的服务端程序。</p>
<h3 id="观察接收到的数据"><a href="#观察接收到的数据" class="headerlink" title="观察接收到的数据"></a>观察接收到的数据</h3><p>现在我们已经编写出我们第一个服务端，我们需要测试一下他是否真的可以运行。最简单的测试方法是用<code>telnet</code> 命令。例如，你可以在命令行上输入<code>telnet localhost 8080</code>或者其他类型参数。</p>
<p>然而我们能说这个服务端是正常运行了吗？事实上我们也不知道因为他是一个discard服务，你根本不可能得到任何的响应。为了证明他仍然是在工作的，让我们修改服务端的程序来打印出他到底接收到了什么。</p>
<p>我们已经知道<code>channelRead()</code>方法是在数据被接收的时候调用。让我们放一些代码到DiscardServerHandler类的<code>channelRead()</code>方法。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    <span class="selector-tag">try</span> &#123;</span><br><span class="line">        <span class="selector-tag">while</span> (in.isReadable()) &#123; <span class="comment">// (1)</span></span><br><span class="line">            System<span class="selector-class">.out</span><span class="selector-class">.print</span>((char) in.readByte());</span><br><span class="line">            System<span class="selector-class">.out</span><span class="selector-class">.flush</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="selector-tag">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil<span class="selector-class">.release</span>(msg); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这个低效的循环事实上可以简化为:<code>System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</code></p>
</li>
<li><p>或者，你可以在这里调用<code>in.release()</code>。</p>
</li>
</ul>
<p>如果你再次运行<code>telnet</code>命令，你将会看到服务端打印出了他所接收到的消息。</p>
<p>完整的discard server代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/discard/package-summary.html" target="_blank" rel="external">io.netty.example.discard</a>包下面。</p>
<h2 id="ECHO服务（响应式协议）"><a href="#ECHO服务（响应式协议）" class="headerlink" title="ECHO服务（响应式协议）"></a>ECHO服务（响应式协议）</h2><p>到目前为止，我们虽然接收到了数据，但没有做任何的响应。然而一个服务端通常会对一个请求作出响应。让我们学习怎样在<a href="http://tools.ietf.org/html/rfc862" target="_blank" rel="external">ECHO</a>协议的实现下编写一个响应消息给客户端，这个协议针对任何接收的数据都会返回一个响应。</p>
<p>和discard server唯一不同的是把在此之前我们实现的<code>channelRead()</code>方法，返回所有的数据替代打印接收数据到控制台上的逻辑。因此，需要把<code>channelRead()</code>方法修改如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    ctx<span class="selector-class">.write</span>(msg); <span class="comment">// (1)</span></span><br><span class="line">    ctx<span class="selector-class">.flush</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html," target="_blank" rel="external">ChannelHandlerContext</a>对象提供了许多操作，使你能够触发各种各样的I/O事件和操作。这里我们调用了<code>write(Object)</code>方法来逐字地把接受到的消息写入。请注意不同于DISCARD的例子我们并没有释放接受到的消息，这是因为当写入的时候NETTY已经帮我们释放了。</li>
<li><code>ctx.write(Object)</code>方法不会使消息写入到通道上，他被缓冲在了内部，你需要调用<code>ctx.flush()</code>方法来把缓冲区中数据强行输出。或者你可以用更简洁的<code>cxt.writeAndFlush(msg)</code>以达到同样的目的。</li>
</ul>
<p>如果你再一次运行telnet命令，你会看到服务端会发回一个你已经发送的消息。<br>完整的echo服务的代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/echo/package-summary.html" target="_blank" rel="external">io.netty.example.echo</a>包下面。</p>
<h2 id="TIME服务-时间协议的服务"><a href="#TIME服务-时间协议的服务" class="headerlink" title="TIME服务(时间协议的服务)"></a>TIME服务(时间协议的服务)</h2><p>在这个部分被实现的协议是<a href="http://tools.ietf.org/html/rfc868" target="_blank" rel="external">TIME</a>协议。和之前的例子不同的是在不接受任何请求时他会发送一个含32位的整数的消息，并且一旦消息发送就会立即关闭连接。在这个例子中，你会学习到如何构建和发送一个消息，然后在完成时主动关闭连接。</p>
<p>因为我们将会忽略任何接收到的数据，而只是在连接被创建发送一个消息，所以这次我们不能使用<code>channelRead()</code>方法了，代替他的是，我们需要覆盖<code>channelActive()</code>方法，下面的就是实现的内容：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">package io<span class="selector-class">.netty</span><span class="selector-class">.example</span><span class="selector-class">.time</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">TimeServerHandler</span> <span class="selector-tag">extends</span> <span class="selector-tag">ChannelHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void channelActive(final ChannelHandlerContext ctx) &#123; <span class="comment">// (1)</span></span><br><span class="line">        final ByteBuf time = ctx<span class="selector-class">.alloc</span>()<span class="selector-class">.buffer</span>(<span class="number">4</span>); <span class="comment">// (2)</span></span><br><span class="line">        time<span class="selector-class">.writeInt</span>((int) (System.currentTimeMillis() / <span class="number">1000</span>L + <span class="number">2208988800</span>L));</span><br><span class="line"></span><br><span class="line">        final ChannelFuture f = ctx<span class="selector-class">.writeAndFlush</span>(time); <span class="comment">// (3)</span></span><br><span class="line">        <span class="selector-tag">f</span><span class="selector-class">.addListener</span>(new ChannelFutureListener() &#123;</span><br><span class="line">            <span class="variable">@Override</span></span><br><span class="line">            public void operationComplete(ChannelFuture future) &#123;</span><br><span class="line">                assert f == future;</span><br><span class="line">                ctx<span class="selector-class">.close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Override</span></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">exceptionCaught</span>(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">        cause<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">        ctx<span class="selector-class">.close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>channelActive()</code>方法将会在连接被建立并且准备进行通信时被调用。因此让我们在这个方法里完成一个代表当前时间的32位整数消息的构建工作。</li>
<li>为了发送一个新的消息，我们需要分配一个包含这个消息的新的缓冲。因为我们需要写入一个32位的整数，因此我们需要一个至少有4个字节的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。通过<code>ChannelHandlerContext.alloc()</code>得到一个当前的ByteBufAllocator，然后分配一个新的缓冲。</li>
<li>和往常一样我们需要编写一个构建好的消息。但是等一等，flip在哪？难道我们使用NIO发送消息时不是调用<code>java.nio.ByteBuffer.flip()</code>吗？ByteBuf之所以没有这个方法因为有两个指针，一个对应读操作一个对应写操作。当你向ByteBuf里写入数据的时候写指针的索引就会增加，同时读指针的索引没有变化。读指针索引和写指针索引分别代表了消息的开始和结束。</li>
</ul>
<p>比较起来，NIO缓冲并没有提供一种简洁的方式来计算出消息内容的开始和结尾，除非你调用<code>flip</code>方法。当你忘记调用flip方法而引起没有数据或者错误数据被发送时，你会陷入困境。这样的一个错误不会发生在Netty上，因为我们对于不同的操作类型有不同的指针。你会发现这样的使用方法会让你过程变得更加的容易，因为你已经习惯一种没有使用<code>flip</code>的方式。</p>
<p>另外一个点需要注意的是<code>ChannelHandlerContext.write()</code>(和<code>writeAndFlush()</code>)方法会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>对象，一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>代表了一个还没有发生的I/O操作。这意味着任何一个请求操作都不会马上被执行，因为在Netty里所有的操作都是异步的。举个例子下面的代码中在消息被发送之前可能会先关闭连接。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">Channel <span class="number">ch</span> = ...<span class="comment">;</span></span><br><span class="line"><span class="number">ch</span>.writeAndFlush(message)<span class="comment">;</span></span><br><span class="line"><span class="number">ch</span>.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>因此你需要在<code>write()</code>方法返回的ChannelFuture完成后调用<code>close()</code>方法，然后当他的写操作已经完成他会通知他的监听者。请注意,<code>close()</code>方法也可能不会立马关闭，他也会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>。</p>
<ul>
<li>当一个写请求已经完成是如何通知到我们？这个只需要简单地在返回的ChannelFuture上增加一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>。这里我们构建了一个匿名的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>类用来在操作完成时关闭Channel。</li>
</ul>
<p>或者，你可以使用简单的预定义监听器代码:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">f</span><span class="selector-class">.addListener</span>(<span class="selector-tag">ChannelFutureListener</span><span class="selector-class">.CLOSE</span>);</span><br></pre></td></tr></table></figure>
<p>为了测试我们的time服务如我们期望的一样工作，你可以使用UNIX的<code>rdate</code>命令</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ rdate -o <span class="tag">&lt;<span class="name">port</span>&gt;</span> -p <span class="tag">&lt;<span class="name">host</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>port是你在<code>main()</code>函数中指定的端口，host使用locahost就可以了。</p>
<h2 id="Time客户端"><a href="#Time客户端" class="headerlink" title="Time客户端"></a>Time客户端</h2><p>不像DISCARD和ECHO的服务端，对于TIME协议我们需要一个客户端因为人们不能把一个32位的二进制数据翻译成一个日期或者日历。在这一部分，我们将会讨论如何确保服务端是正常工作的，并且学习怎样用NETTY编写一个客户端。</p>
<p>在Netty中,编写服务端和客户端最大的并且唯一不同的使用了不同的<a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>的实现。请看一下下面的代码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String host = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span></span><br><span class="line">            b.group(workerGroup); <span class="comment">// (2)</span></span><br><span class="line">            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span></span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span></span><br><span class="line">            b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a>类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的channel。</li>
<li>如果你只指定了一个<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>，那他就会即作为一个‘<code>boss</code>’线程，也会作为一个‘<code>workder</code>’线程，尽管客户端不需要使用到‘<code>boss</code>’线程。</li>
<li>代替<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>的是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" target="_blank" rel="external">NioSocketChannel</a>,这个类在客户端channel被创建时使用。</li>
<li>不像在使用ServerBootstrap时需要用<code>childOption()</code>方法，因为客户端的<a href="http://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html" target="_blank" rel="external">SocketChannel</a>没有父channel的概念。</li>
<li>我们用<code>connect()</code>方法代替了<code>bind()</code>方法。<br>正如你看到的，他和服务端的代码是不一样的。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>是如何实现的?他应该从服务端接受一个32位的整数消息，把他翻译成人们能读懂的格式，并打印翻译好的时间，最后关闭连接:</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">package io<span class="selector-class">.netty</span><span class="selector-class">.example</span><span class="selector-class">.time</span>;</span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.Date</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">TimeClientHandler</span> <span class="selector-tag">extends</span> <span class="selector-tag">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg; <span class="comment">// (1)</span></span><br><span class="line">        <span class="selector-tag">try</span> &#123;</span><br><span class="line">            long currentTimeMillis = (m<span class="selector-class">.readUnsignedInt</span>() <span class="selector-tag">-</span> <span class="selector-tag">2208988800L</span>) * <span class="selector-tag">1000L</span>;</span><br><span class="line">            System<span class="selector-class">.out</span><span class="selector-class">.println</span>(new Date(currentTimeMillis));</span><br><span class="line">            ctx<span class="selector-class">.close</span>();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            m<span class="selector-class">.release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">        cause<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">        ctx<span class="selector-class">.close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在TCP/IP中，NETTY会把读到的数据放到ByteBuf的数据结构中。</li>
</ul>
<p>这样看起来非常简单，并且和服务端的那个例子的代码也相差不多。然而，处理器有时候会因为抛出<code>IndexOutOfBoundsException</code>而拒绝工作。在下个部分我们会讨论为什么会发生这种情况。</p>
<h1 id="流数据的传输处理"><a href="#流数据的传输处理" class="headerlink" title="流数据的传输处理"></a>流数据的传输处理</h1><h2 id="一个小的Socket-Buffer问题"><a href="#一个小的Socket-Buffer问题" class="headerlink" title="一个小的Socket Buffer问题"></a>一个小的Socket Buffer问题</h2><p>在基于流的传输里比如TCP/IP，接收到的数据会先被存储到一个socket接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了2个独立的数据包，操作系统也不会作为2个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取。举个例子，让我们假设操作系统的TCP/TP协议栈已经接收了3个数据包：</p>
<p><img src="/images/blog/netty/netty5_1.png" alt="netty socket buffer"></p>
<p>由于基于流传输的协议的这种普通的性质，在你的应用程序里读取数据的时候会有很高的可能性被分成下面的片段。</p>
<p><img src="/images/blog/netty/netty5_2.png" alt="netty socket buffer"></p>
<p>因此，一个接收方不管他是客户端还是服务端，都应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的数据。在上面的例子中，接收到的数据应该被构造成下面的格式：</p>
<p><img src="/images/blog/netty/netty5_3.png" alt="netty socket buffer"></p>
<h3 id="第一个解决方案"><a href="#第一个解决方案" class="headerlink" title="第一个解决方案"></a>第一个解决方案</h3><p>现在让我们回到TIME客户端的例子上。这里我们遇到了同样的问题，一个32字节数据是非常小的数据量，他并不见得会被经常拆分到到不同的数据段内。然而，问题是他确实可能会被拆分到不同的数据段内，并且拆分的可能性会随着通信量的增加而增加。</p>
<p>最简单的方案是构造一个内部的可积累的缓冲，直到4个字节全部接收到了内部缓冲。下面的代码修改了TimeClientHandler的实现类修复了这个问题</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">package io<span class="selector-class">.netty</span><span class="selector-class">.example</span><span class="selector-class">.time</span>;</span><br><span class="line"></span><br><span class="line">import java<span class="selector-class">.util</span><span class="selector-class">.Date</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">TimeClientHandler</span> <span class="selector-tag">extends</span> <span class="selector-tag">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    private ByteBuf buf;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        buf = ctx<span class="selector-class">.alloc</span>()<span class="selector-class">.buffer</span>(<span class="number">4</span>); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void handlerRemoved(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        buf<span class="selector-class">.release</span>(); <span class="comment">// (1)</span></span><br><span class="line">        buf = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">        ByteBuf m = (ByteBuf) msg;</span><br><span class="line">        buf<span class="selector-class">.writeBytes</span>(m); <span class="comment">// (2)</span></span><br><span class="line">        m<span class="selector-class">.release</span>();</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">if</span> (buf.readableBytes() &gt;= <span class="number">4</span>) &#123; <span class="comment">// (3)</span></span><br><span class="line">            long currentTimeMillis = (buf<span class="selector-class">.readInt</span>() <span class="selector-tag">-</span> <span class="selector-tag">2208988800L</span>) * <span class="selector-tag">1000L</span>;</span><br><span class="line">            System<span class="selector-class">.out</span><span class="selector-class">.println</span>(new Date(currentTimeMillis));</span><br><span class="line">            ctx<span class="selector-class">.close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">        cause<span class="selector-class">.printStackTrace</span>();</span><br><span class="line">        ctx<span class="selector-class">.close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>有2个生命周期的监听方法：handlerAdded()和handlerRemoved()。你可以完成任意初始化任务只要他不会被阻塞很长的时间。</li>
<li>首先，所有接收的数据都应该被累积在buf变量里。</li>
<li>然后，处理器必须检查buf变量是否有足够的数据，在这个例子中是4个字节，然后处理实际的业务逻辑。否则，Netty会重复调用channelRead()当有更多数据到达直到4个字节的数据被积累。</li>
</ul>
<h3 id="第二个解决方案"><a href="#第二个解决方案" class="headerlink" title="第二个解决方案"></a>第二个解决方案</h3><p>尽管第一个解决方案已经解决了Time客户端的问题了，但是修改后的处理器看起来不那么的简洁，想象一下如果由多个字段比如可变长度的字段组成的更为复杂的协议时，你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的实现将很快地变得难以维护。</p>
<p>正如你所知的，你可以增加多个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a> ,因此你可以把一整个ChannelHandler拆分成多个模块以减少应用的复杂程度，比如你可以把TimeClientHandler拆分成2个处理器：</p>
<ul>
<li>TimeDecoder处理数据拆分的问题</li>
<li>TimeClientHandler原始版本的实现</li>
</ul>
<p>幸运地是，Netty提供了一个可扩展的类，帮你完成TimeDecoder的开发。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) &#123; <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// (3)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.add(in.readBytes(<span class="number">4</span>)); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>是<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的一个实现类，他可以在处理数据拆分的问题上变得很简单。</li>
<li>每当有新数据接收的时候，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>都会调用decode()方法来处理内部的那个累积缓冲。</li>
<li><code>Decode()</code>方法可以决定当累积缓冲里没有足够数据时可以往out对象里放任意数据。当有更多的数据被接收了<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>会再一次调用<code>decode()</code>方法。</li>
<li>如果在<code>decode()</code>方法里增加了一个对象到out对象里，这意味着解码器解码消息成功。<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>将会丢弃在累积缓冲里已经被读过的数据。请记得你不需要对多条消息调用<code>decode()</code>，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>会持续调用<code>decode()</code>直到不放任何数据到out里。</li>
</ul>
<p>现在我们有另外一个处理器插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>里，我们应该在TimeClient里修改<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a> 的实现：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> TimeDecoder(), <span class="keyword">new</span> TimeClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果你是一个大胆的人，你可能会尝试使用更简单的解码类<a href="http://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html" target="_blank" rel="external">ReplayingDecoder</a>。不过你还是需要参考一下API文档来获取更多的信息。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void decode(</span><br><span class="line">        <span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span> out) &#123;</span><br><span class="line">        out.add(in.readBytes(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，Netty还提供了更多可以直接拿来用的解码器使你可以更简单地实现更多的协议，帮助你避免开发一个难以维护的处理器实现。请参考下面的包以获取更多更详细的例子：</p>
<ul>
<li>对于二进制协议请看<a href="http://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html" target="_blank" rel="external">io.netty.example.factorial</a></li>
<li>对于基于文本协议请看<a href="http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html" target="_blank" rel="external">io.netty.example.telnet</a></li>
</ul>
<h2 id="用POJO代替ByteBuf"><a href="#用POJO代替ByteBuf" class="headerlink" title="用POJO代替ByteBuf"></a>用POJO代替ByteBuf</h2><p>我们已经讨论了所有的例子，到目前为止一个消息的消息都是使用<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>作为一个基本的数据结构。在这一部分，我们会改进TIME协议的客户端和服务端的例子，用POJO替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。</p>
<p>在你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandlerS</a>中使用POJO优势是比较明显的。通过从<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>中提取出ByteBuf的代码，将会使<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的实现变得更加可维护和可重用。在TIME客户端和服务端的例子中，我们读取的仅仅是一个32位的整形数据，直接使用ByteBuf不会是一个主要的问题。然后，你会发现当你需要实现一个真实的协议，分离代码变得非常的必要。</p>
<p>首先，让我们定义一个新的类型叫做UnixTime。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">package io.netty.example.time;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnixTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>L + <span class="number">2208988800</span>L));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date((<span class="keyword">value</span>() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以修改下TimeDecoder类，返回一个UnixTime，以替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@<span class="function">Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(<span class="params">ChannelHandlerContext ctx, ByteBuf <span class="keyword">in</span>, List&lt;Object&gt; <span class="keyword">out</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">in</span>.readableBytes() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">out</span>.add(<span class="keyword">new</span> UnixTime(<span class="keyword">in</span>.readInt()));</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>下面是修改后的解码器，TimeClientHandler不再有任何的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>代码了。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    UnixTime m = (UnixTime) msg;</span><br><span class="line">    System<span class="selector-class">.out</span><span class="selector-class">.println</span>(m);</span><br><span class="line">    ctx<span class="selector-class">.close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是变得更加简单和优雅了？相同的技术可以被运用到服务端。让我们修改一下TimeServerHandler的代码。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    ChannelFuture f = ctx<span class="selector-class">.writeAndFlush</span>(new UnixTime());</span><br><span class="line">    f<span class="selector-class">.addListener</span>(ChannelFutureListener.CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，仅仅需要修改的是ChannelHandler的实现，这里需要把UnixTime对象重新转化为一个ByteBuf。不过这已经是非常简单了，因为当你对一个消息编码的时候，你不需要再处理拆包和组装的过程。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.example.time;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void write(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg, <span class="type">ChannelPromise</span> promise) &#123;</span><br><span class="line">        <span class="type">UnixTime</span> m = (<span class="type">UnixTime</span>) msg;</span><br><span class="line">        <span class="type">ByteBuf</span> encoded = ctx.alloc().buffer(<span class="number">4</span>);</span><br><span class="line">        encoded.writeInt(m.value());</span><br><span class="line">        ctx.write(encoded, promise); <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这几行代码里还有几个重要的事情。</p>
<ul>
<li>第一， 通过ChannelPromise，当编码后的数据被写到了通道上Netty可以通过这个对象标记是成功还是失败。</li>
<li>第二， 我们不需要调用<code>cxt.flush()</code>。因为处理器已经单独分离出了一个方法<code>void flush(ChannelHandlerContext cxt)</code>,如果像自己实现<code>flush</code>方法内容可以自行覆盖这个方法。</li>
</ul>
<p>进一步简化操作，你可以使用<a href="http://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html" target="_blank" rel="external">MessageToByteEncode</a>:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder&lt;UnixTime&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">UnixTime</span> msg, <span class="type">ByteBuf</span> out) &#123;</span><br><span class="line">        out.writeInt(msg.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的任务就是在TimeServerHandler之前把TimeEncoder插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>。但这是不那么重要的工作。</p>
<h2 id="关闭你的应用"><a href="#关闭你的应用" class="headerlink" title="关闭你的应用"></a>关闭你的应用</h2><p>关闭一个Netty应用往往只需要简单地通过<code>shutdownGracefully()</code>方法来关闭你构建的所有的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a>S.当<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>被完全地终止,并且对应的所有channels都已经被关闭时，Netty会返回一个<a href="http://netty.io/5.0/api/io/netty/util/concurrent/Future.html" target="_blank" rel="external">Future</a>对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一章节中，我们会快速地回顾下如果在熟练掌握Netty的情况下编写出一个健壮能运行的网络应用程序。<br>在Netty接下去的章节中还会有更多更相信的信息。我们也鼓励你去重新复习下在<a href="https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example" target="_blank" rel="external">io.netty.example</a>包下的例子。<br>请注意<a href="http://netty.io/community.html" target="_blank" rel="external">社区</a>一直在等待你的问题和想法以帮助Netty的持续改进，Netty的文档也是基于你们的快速反馈上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决Maven使用artchetype:create创建工程失败的问题]]></title>
      <url>http://tonydeng.github.io/2015/09/18/maven-generate-project/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/maven/maven-jee.png" alt="maven java"></p>
<p>Maven是我一直用来管理Java项目生命周期的工具，从2006年开始使用，到现在快十年了。没想到今天碰到一个新的问题，就是使用 <code>mvn artchetype:create</code> 来创建项目时失败了。</p>
<a id="more"></a>
<p>问题如下：</p>
<p>Maven命令如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mvn archetype:create \</span><br><span class="line">    -DgroupId=com<span class="selector-class">.github</span><span class="selector-class">.tonydeng</span><span class="selector-class">.bluebrid</span> \</span><br><span class="line">    -DartifactId=bluebrid</span><br></pre></td></tr></table></figure>
<p>错误提示如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to <span class="keyword">execute</span> goal org.apache.maven.plugins:maven-archetype-<span class="keyword">plugin</span>:<span class="number">2.4</span>:<span class="keyword">create</span> (<span class="keyword">default</span>-cli) <span class="keyword">on</span> <span class="keyword">project</span> bluebrid: Unable <span class="keyword">to</span> <span class="keyword">parse</span> configuration <span class="keyword">of</span> mojo org.apache.maven.plugins:maven-archetype-<span class="keyword">plugin</span>:<span class="number">2.4</span>:<span class="keyword">create</span> <span class="keyword">for</span> parameter #: Cannot <span class="keyword">create</span> <span class="keyword">instance</span> <span class="keyword">of</span> <span class="keyword">interface</span> org.apache.maven.artifact.repository.ArtifactRepository: org.apache.maven.artifact.repository.ArtifactRepository.&lt;init&gt;() -&gt; [<span class="keyword">Help</span> <span class="number">1</span>]</span><br><span class="line">[<span class="keyword">ERROR</span>]</span><br><span class="line">[<span class="keyword">ERROR</span>] <span class="keyword">To</span> see the <span class="keyword">full</span> stack <span class="keyword">trace</span> <span class="keyword">of</span> the <span class="keyword">errors</span>, re-run Maven <span class="keyword">with</span> the -e switch.</span><br><span class="line">[<span class="keyword">ERROR</span>] Re-run Maven <span class="keyword">using</span> the -X <span class="keyword">switch</span> <span class="keyword">to</span> <span class="keyword">enable</span> <span class="keyword">full</span> debug logging.</span><br><span class="line">[<span class="keyword">ERROR</span>]</span><br><span class="line">[<span class="keyword">ERROR</span>] <span class="keyword">For</span> more information about the <span class="keyword">errors</span> <span class="keyword">and</span> possible solutions, please <span class="keyword">read</span> the <span class="keyword">following</span> articles:</span><br><span class="line">[<span class="keyword">ERROR</span>] [<span class="keyword">Help</span> <span class="number">1</span>] <span class="keyword">http</span>://cwiki.apache.org/confluence/display/MAVEN/PluginConfigurationException</span><br></pre></td></tr></table></figure>
<p>从错误提示来看，应该是<code>maven-archetype-plugin-2.4</code>这个版本的插件没有<code>create</code>这个参数了。</p>
<p>去<a href="http://maven.apache.org/" target="_blank" rel="external">Maven的官网</a>的<a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="external">plugin list</a>中查看，原来archetype这个插件在2015年8月9号更新到2.4的版本，那再继续看看<a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="external">archetype插件</a>有了什么新的变化。</p>
<p>原来artchetype已经没有create这个方法了，现在推荐方式是先建立自己的Example project，然后通过这个example project为例子，再创建实际你要用的项目。</p>
<p>基本的流程就像这幅图中描述的。</p>
<p><img src="/images/blog/maven/archetype-overview.png" alt="maven archetype plugin flow"></p>
<p>OK，那我们就按照官方的指示来操作一次看看。</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">$ mvn arche<span class="keyword">type</span>:create-from-project</span><br><span class="line">$ cd target/generated-sources/arche<span class="keyword">type</span>/</span><br><span class="line">$ mvn install</span><br><span class="line">$ cd /tmp/arche<span class="keyword">type</span></span><br><span class="line">$ mvn arche<span class="keyword">type</span>:generate -<span class="type">DarcheypteCatalog</span>=local</span><br></pre></td></tr></table></figure>
<p>那还有没有别的简单的方法来创建，就像之前使用archetype:create一样呢？</p>
<p>你可以使用下面的命令来进行创建项目。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    -DarchetypeGroupId=org<span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.archetypes</span> \</span><br><span class="line">    -DgroupId=com<span class="selector-class">.github</span><span class="selector-class">.tonydeng</span><span class="selector-class">.bluebrid</span> \</span><br><span class="line">    -DartifactId=bluebrid \</span><br><span class="line">    -T20</span><br></pre></td></tr></table></figure>
<p>不过，这样创建项目，你会发现在如下两个点要等N长的时间，这个N长的时间可能要以几十分钟来计算。</p>
<blockquote>
<p>[INFO] Generating project in Interactive mode</p>
<p>[INFO] Generating project in Batch mode</p>
</blockquote>
<p>其实你可以再加上两个参数  <code>-DinteractiveMode=false -DarchetypeCatalog=internal</code> 可以让你快速秒建项目。</p>
<p>这两个参数的意义分别如下：</p>
<blockquote>
<p>-DinteractiveMode=false  指定不使用交互模式</p>
<p>-DarchetypeCatalog=internal 指定不从远程服务器上取catalog，</p>
</blockquote>
<p>完整的命令如下：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    -<span class="ruby">DarchetypeGroupId=org.apache.maven.archetypes \</span><br><span class="line"></span>    -<span class="ruby">DinteractiveMode=<span class="literal">false</span> \</span><br><span class="line"></span>    -<span class="ruby">DarchetypeCatalog=internal \</span><br><span class="line"></span>    -<span class="ruby">DgroupId=com.github.tonydeng.bluebrid \</span><br><span class="line"></span>    -<span class="ruby">DartifactId=bluebrid \</span><br><span class="line"></span>    -<span class="ruby">T2<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<p>创建webapp项目命令如下：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">    -<span class="ruby">DarchetypeGroupId=org.apache.maven.archetypes \</span><br><span class="line"></span>    -<span class="ruby">DinteractiveMode=<span class="literal">false</span> \</span><br><span class="line"></span>    -<span class="ruby">DarchetypeCatalog=internal \</span><br><span class="line"></span>    -<span class="ruby">DgroupId=com.github.tonydeng.bluebrid \</span><br><span class="line"></span>    -<span class="ruby">DartifactId=bluebrid-webapp \</span><br><span class="line"></span>    -<span class="ruby">DarchetypeArtifactId=maven-archetype-webapp \</span><br><span class="line"></span>    -<span class="ruby">T2<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<p>遇到同样问题的同学们，你们可以试试我的方法，应该能够快速的解决你们的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NoSQL vs SQL By Alphabet高可用架构微信群]]></title>
      <url>http://tonydeng.github.io/2015/08/20/nosql-vs-sql/</url>
      <content type="html"><![CDATA[<p>本文所有内容来自Alphabet高可用架构微信群内部分享，分享是阿里巴巴的沈询老师。</p>
<p>今天想介绍的东西是NoSQL到SQL。我之所以选择这个题目，其实就是因为看到了一张图。</p>
<p><img src="/images/blog/nosql_vs_sql/a_history_of_databases_in_no-tation.jpg" alt="A history of databases in No-tation"></p>
<p>看完以后我真的噗嗤就笑了，黑的漂亮。</p>
<a id="more"></a>
<p>作为一个对数据库历史有点了解的人来说，这图真的反应了我们在数据库存储领域螺旋上升一样的发展历程的最佳代表，这哥们真的是天赋异禀。</p>
<p>那么，为什么我会笑呢？今天习武我做完这次分享，大家也能够跟我一样笑一下~</p>
<p>那么我们先来第一章：</p>
<h2 id="1970-We-have-no-SQL"><a href="#1970-We-have-no-SQL" class="headerlink" title="1970:We have no SQL"></a>1970:We have no SQL</h2><p>嗯，我们没有SQL</p>
<p>要介绍这个问题，我们要先来看看，什么叫数据库，以及数据库这个东西是怎么来的。</p>
<p>相信，大家都是程序员，而程序员，一定会碰到这样一个需求：“我要用计算机表示一辆车子”。</p>
<p>这辆车呢，有一个外壳，四善玻璃，四个轮子。</p>
<p>我应该如何用程序来表述它呢？</p>
<p>第一个能够想到的，一定是使用结构体（Java中class）。</p>
<p>但，当我们发现这个车子的抽象不够用了，比如，我需要在车子上面装一对反光镜。该怎么办呢？</p>
<p>我们只能往里面增加一个新的属性，来表述这个反光镜。</p>
<p>如果这种需求越来越多，越来越多，我们就会发现，每次都要改一下这个结构体，编译，发布，是一个非常麻烦的事情啊……于是，就有了这种非常纯粹的需求，我有没有可能把他弄成动态的？</p>
<p>这时候，我们最常用的一个数据结构，就是“映射”。</p>
<p>如果我是一个Java程序员的话，那么映射就是一个Map<object,object></object,object></p>
<p>一般来说Map有两类实现，第一类是Hash，第二类是有序树。</p>
<p>有了这个随需应变的集合，我们就可以把事情变成这样：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"轮子"</span>,轮子对象);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"镜子"</span>,镜子对象);</span><br></pre></td></tr></table></figure>
<p>我们有些时候，又会担心数据丢失对不对？</p>
<p>所以，还要想办法把这个对象以非常高兴的方式持久化下来，放到磁盘上，这样就不容易丢失了。</p>
<p>如果大家了解一点点的磁盘知识的画，就立刻会发现一个问题，<code>map.put/get</code> 操作，其实都是有一次寻找的过程。而这个寻找的过程，对于磁盘来说，就会转变为一次随机的寻道过程。</p>
<p>这里有很多种方式，能够用磁盘结构来存储类似Map这样的概念，我今天只介绍一种，就是B-tree。</p>
<p>不知道大家对这个词儿是不是熟悉啊 ，反正我面试基本都会问问……</p>
<p>需要先提的一件事是B树==B-树。所谓B-树，并不是B减树的意思，希望大家不要跟我一样土鳖……</p>
<p><img src="/images/blog/nosql_vs_sql/b-tree.jpg" alt="B Tree"></p>
<p>这就是一个最简单的B树，我们观察一下就会发现，其实B树的出发点很简单，既然磁盘寻道时间很多，那就减少它~~ 一次寻道就能够从磁盘取更多的数据就行了。</p>
<p>所以，它是以“数组”为单位，存储数据的，而数组，其实就是一片连续并且有界的空间。</p>
<p>数组本身很难扩展，而维护数组内有序，其实也是有一定代价的。而数组满了以后怎么办？这就是B树会做的事儿-<strong>分裂</strong></p>
<p>如果这里大家能够联想到另外一个东西，那就算学明白了~~ HBase其实就是一颗巨大的、分布式的B树。</p>
<p>其他容我最后吐槽~~</p>
<p>好了，我们稍微绕出去一点，分享一下B树是什么，主要目的实际上就是让大家回忆一下数据结构，这有有利于我们继续讲其他东西。</p>
<p>回到数据库，详细很多人都听过一个名词“层次数据库”，似乎这东西就是在上古时代的神器，现在则不见了踪影。</p>
<p>那么，这“层次数据库”到底是什么玩意儿呢？</p>
<p>我们来看一张图</p>
<p><img src="/images/blog/nosql_vs_sql/hierarchiacl_database.jpg" alt="Hierarchiacl Database"></p>
<p>抽象来看，层次模型其实就是这样的东西。</p>
<p>我再用小汽车来表述一下：一个小车由四扇玻璃，四个轮子，两个反光镜组成。</p>
<p>车有自己的属性，轮子有自己的属性，反光镜有自己的属性。</p>
<p>给大家举两个例子，相信大家应该可以立刻就明白，所谓的层次模型如果用Java代码来写的话，应该是什么样的。</p>
<p>Map套Map，每一个Map有一些固定的属性，比如这个Map的名字是什么？这个Map的属性是什么？</p>
<p>而这就是我们最开始用的数据库了。</p>
<p>非常简单，一个Map结构搞定所有需求。看起来世界大同了。</p>
<h2 id="下面，我们就来到1980年：-Know-SQL。知道SQL了。"><a href="#下面，我们就来到1980年：-Know-SQL。知道SQL了。" class="headerlink" title="下面，我们就来到1980年： Know SQL。知道SQL了。"></a>下面，我们就来到1980年： Know SQL。知道SQL了。</h2><p>为什么这么写？其实就是关系数据库是上世纪70年代发明的，而到了80年代，第一代全功能的关系数控System R由IBM发布。</p>
<p>所以，在80年代，我们才正式进入关系数据库模型。</p>
<p>相信，很多人都觉得自己了解关系模型，似乎每个人提到它，都说“对对对”绝对对。</p>
<p>因为这是有数学支持的，所以不应该怀疑。</p>
<p>可选，实际上如果大家了解科学发现的历史，我们就会发现，自从爱因斯坦把牛顿那又完美数学报纸的自洽理论踢出了神坛，数学自洽就再也不是一个真理的标准了。</p>
<p>而真理只有一个，哪个用户多，就是哪个~~~</p>
<p>那么，为什么关系模型最终赢得了比赛，而层次模型死掉了呢？</p>
<p>很简单，因为人类都是蠢蛋和傻瓜啊……哪个简单，容易用，就是哪个赢。</p>
<p>下面，我们就以一个例子俩看看，关系模型易用在哪里。</p>
<p>还是以车子为例。如果我要做这样一个查询：把厂里生产的所有汽车里面，左轮子供应商是DRDS的轮胎都找出来。</p>
<p>对于层次模型，我们的代码是：</p>
<p>遍历每一辆车（从车对象中找到左面的轮子，查看轮子的属性，是DRDS的留下，不是的丢弃）。</p>
<p>而如果是关系模型呢？ <code>select * from 轮子表 where 轮子位置 = &#39;左&#39; and 轮子供应商 = &#39;DRDS&#39;</code> ,就完成了。</p>
<p>我看了都觉得是个世界性的创举，不知道您是什么感觉？</p>
<p>好，那么下一步，我们来看看，关系模型将会怎么处理这条SQL。</p>
<p><img src="/images/blog/nosql_vs_sql/DRDS.jpg" alt="关系模型组织形式"></p>
<p>其实，用这一张图就可以表示一个最简单的关系模型了，基本上所有的数据库，都是这个组织形式。</p>
<p>最上面的额用户API就是执行的SQL和事务命令；中间的就是关系代数转换层和事务处理层；最后，最底层，是个KV存储。</p>
<p>啊？KV这不是NoSQL的概念么，你凭什么盗用它？</p>
<p>呵呵，谁盗用谁呢？还不一定呢。</p>
<p>先从最底层下看来，KV存储是什么？其实就是我们一开始说的“映射”结构。对应内存，可能有Hash和有序树结构，对应磁盘主要是btree树系和LSM树系。</p>
<p>我这里不展开说了，因为每个数据结构都有自己好玩的属性，讲起了太多。我们直接来聊聊关系代数引擎。这是数据库最关键的部分之一。</p>
<p>但其实从功能目标来说，并不是很复杂。</p>
<p><img src="/images/blog/nosql_vs_sql/relational_algebra_engines.jpg" alt="关系代数引擎"></p>
<p>这张图就是整个关系代数引擎所经过的步骤。</p>
<p>最原始的是SQL字符串。类似 <code>select * from tab where id = 1</code> ,它经过的过程叫做SQL解析，会生成一个AST抽象语法树。</p>
<p><img src="/images/blog/nosql_vs_sql/abstract_syntax_tree.jpg" alt="抽象语法树"></p>
<p>select被拆解为fromList/WhereClause等细碎的字串。</p>
<p>这个过程的主要作用是，作为计算机编写代码而言，我们更容易识别这种结构化的数据，而文档属于非结构化数据。有了这棵树，我们还需要再做一件事情，就是执行优化。它的入参是AST树+索引源信息。</p>
<p>索引源信息又是什么鬼？</p>
<p>要讲明白这个，得先看看关系模型和Map是怎么对应起来的。我用几张PPT来讲解一下。</p>
<p><img src="/images/blog/nosql_vs_sql/sql_step_by_step_1.jpg" alt="如何按照key找到对应的数据"></p>
<p>第一个SQL是 select * from tab where id = ? ，上面的那个则是一个表格。</p>
<p>如果我们用map来表示，可以表示成这样：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">M<span class="function"><span class="title">ap</span>: key -&gt;</span> <span class="function"><span class="title">primaryKey</span>, value -&gt;</span> [pk,user_id,Name]</span><br></pre></td></tr></table></figure>
<p>也就是，以PK值作为Map的key，以一个包含了pk,user_id,Name的值的结构作为Map的value。（当然也可以只包含user_id,Name）。也OK~</p>
<p>有了这个map，我们只需要从AST里面取出id=？，得知id=0（假设），然后 map.get(0)，就可以拿到对应的user_id和Name数据了，加上输入的id=0这个数据，就可以返回了。</p>
<p>再来看另一个需求。</p>
<p>这里面，我们的查询条件发生了变化，不是id了，而是user_id。</p>
<p>而我们刚才只有一个Map : Map: key -&gt; primaryKey, value -&gt; [user_id,Name] ，我应该如何利用这个Map去找到所有符合要求的结果呢？</p>
<p>我能想到的第一种方式是，遍历Map里面的每一个Entry，取出每一个Entry以后，看看user_id == 我想要的值？如果不等于，丢弃，如果等于，返回。即可。</p>
<p>然而，这中方式带来的问题就是，如果我有1亿条记录，我就要做这件事情1亿次。明显O(N)效率太慢了。</p>
<p>怎么加快一下？</p>
<p>有需求就有人相应，于是，我们可以用一个空间换时间的法子。</p>
<p><img src="/images/blog/nosql_vs_sql/sql_step_by_step_2.jpg" alt="如何按照key找到对应的数据-二级索引"></p>
<p>看看上面的图，里面有增加了一个新的Map。 Map: key -&gt; user_id ,value -&gt; [id]</p>
<p>这个Map以user_id作为key，于是我们又可以愉快而高兴的用户第二个Map的get接口来获取所有符合要求的id列表。然后再根据这个符合要求的id列表，去查第一个Map，获得对应的数据了。</p>
<p>刚才介绍的这块，其实就是关系模型如何映射到Map（也就是KV模型）的关键方法了。</p>
<p>当然，还会有很多扩展性的方式和方法，不过这就不是今天的主题了。</p>
<p>这个数据比较小，只有三列，一个索引。如果我有十几个，甚至几十个索引的适合，我们会面对另一问题。</p>
<p><img src="/images/blog/nosql_vs_sql/sql_step_by_step_2.jpg" alt="如何按照key找到对应的数据-二级索引-name"></p>
<p>如果我有一个user_id的二级索引，又有一个Name的二级索引。我该选择哪一个作为查询用的索引呢？是不是我需要一种机制，来选择那个最“便宜”的索引？</p>
<p>这就是索引选择的过程，我们进行索引选择，就必然的需要知道每一个索引的区分高还是低（说白了，就是一个key对应的plist.size()少还是多）……</p>
<p>而这个索引的区分度高/低，就是所谓索引源信息的最简单模式。在真实的数据库中，还会有很多其他信息，也是索引的源信息，不过为了方便大家理解，简化一下。</p>
<p>有了索引源信息和AST树，我们就可以生成执行计划了。</p>
<p><img src="/images/blog/nosql_vs_sql/mysql_explain.jpg" alt="mysql explain"></p>
<p>这时候，再尝试看看这个，相信大家就大概能够猜到这里的东西所表示的含义了。</p>
<p>所以，很多事情呢不用去背，了解背后的原理，优化就是随手拈来的事儿了……</p>
<p>这里，我省略了事务步骤，这个更复杂。</p>
<h2 id="NO-SQL"><a href="#NO-SQL" class="headerlink" title="NO SQL!"></a>NO SQL!</h2><p>卧槽，豪言壮语，SQL数据库has gone，新时代来临了！</p>
<p>似乎一夜之间，这个世界就翻了天，facebook开源了cassandra，Hadoop、HBase横空出世，似乎这就是未来啊。</p>
<p>我们来看看知乎的问题</p>
<p><a href="http://www.zhihu.com/question/21288175" target="_blank" rel="external">互联网领域，传统的sql很力不从心，一些更具有针对性的nosql会越来与火，以后会不会出来各种强力nosql？</a></p>
<p>反正最雷我的一个问题大概是： 我们是一个新业务，想用NoSQL来提升开发效率，不知道cassandra和hbase应该选哪个？</p>
<p>看完以后，我真的觉得没办法好好做朋友了。</p>
<p>Digg采用Cassandra遭遇失败，工程副总裁离职，希望大家不是这个人。</p>
<p>No SQL！怎么来的？</p>
<p>这还是得从事物开说起来。</p>
<p>从第一代产品化的数据库在上世纪80年代开发完成以后，我们的数据库主要演进模型里面只有几个有限的里程碑，我目前能够记住的就这么积极事情。</p>
<ol>
<li>mvcc多版本并发控制</li>
<li>存储过程</li>
<li>各类OLAP的分析类引擎</li>
</ol>
<p>而，实际上大家心里都知道有一件事情它一定会发生，只是不知道什么时候会发生。这就是，分布式系统。</p>
<p>分布式系统，能够具有无限的扩张能力，按需伸缩，只要有钱，我们的系统就不会down，不会死。这种能力其实在上世纪80年代就深入人心了。还记得SUN公司提出的口号吗？</p>
<p>“网络就是计算机”</p>
<p>傻瓜都知道，未来一定是分布式系统的天下，单机系统还有什么玩头？</p>
<p>单机系统不应该是那待宰的羔羊吗？等着DRDS异军突起不就好了吗？</p>
<p>但是等啊等啊，30年过去了，还没有等等自己寿终正寝的那一天，反而似乎活的越来越好了。这是为什么？</p>
<p>理由很简单，技术没突破……</p>
<p>如果一个分布式系统做的跟单机系统一样方便，又能扩展，性能又好，那这个世界上早就没有单机系统了。而且，从上世纪80年代到21世界的前几年，我们实际上都不需要分布式系统。大部分的系统都是所谓“图书馆管理系统”，“客户关系管理系统”等等企业内部管理系统。</p>
<p>我们不需要很高并发，只需要容易操作就行乐。</p>
<p>那么，单机的关系数据库系统自然最容易操作。所以单机系统大行其道。</p>
<p>然而，云计算和互联网的时代到来了。我们服务的对象， 从顶天了几千人，一下子就变成了十几亿人，计算机要管理的数据量呈指数级别的飞速上涨，而我们却完全无法对用户数据做出准确预估。</p>
<p>这时候，扩展性，性能的要求就变得更为重要了，不开展业务挂了和开发难度少量上升，两个事情做权衡，想想大家都能like知道哪个更重要。</p>
<p>所以，我们要扩展！</p>
<p>然而，数据库却无法提供这样的扩展性，当年的淘宝也是用Oracle的，配置算不错的，也算是有小黑柜子……</p>
<p>然而，今天不火的网站，明天就有可能突然就火了，我们的用户数在一年内就会突破这个柜子的容量，折旧都来不及。</p>
<p>很明显，时代变了。</p>
<p>传统关系数据库，哪怕是RAC都不能满足我们队数据库扩展性的追求了。</p>
<p>这时候，肯定有人在想，这个有问题，我们就解决它啊。</p>
<p>这类技术就是Oracle Rac啊，mysql cluter啊这类玩具，他们希望能够不改变用户行为来实现扩展性。然而，做了好多年，发现玩不转。</p>
<p>为了支持更大的访问量和数据量，我们必然需要分布式数据库系统，而分布式系统有必然会面临对强一致性带来的延迟提高的问题，因为网络通信本身比单机内通信代价高很多，这种通信的代价就会直接增加系统单次提交的延迟。延迟提高会导致数据库锁持有时间变长，使得高冲突条件下分布式事务的性能不升反降（这个具体可以了解一下Amdahl定律），甚至性能距离单机数据库都还有明显的差距。</p>
<p>从上面的说明，我们可以发现，问题的关键并不是分布式事务做不出来，而是做出来了却没什么卵用。 数据库领域的高手们努力了40年，但至今还没有人能够很好解决这个问题，Goolge Spanner的开发负责人就经常在他的Blog上谈论延迟的问题，相信也是饱受这个问题的困扰。</p>
<p>这就是主要问题。</p>
<p>于是，有一群人认为，强一致性这就是看起不怎么靠谱，那彻底绕开这个问题是不是个更好的选择？他们发现确实有那么一些场景是不需要强一致性事务的，甚至连SQL都可以不要，最典型的就是日志流水的记录和分析这类的场景，而去掉了事务和SQQL，接口简单了，性能就更容易得到提升，扩展性也更容易实现，这就是NoSQL的起源。</p>
<p>他们喊出非常响亮的口号“No SQL！”，来标志着他们的时代到来。</p>
<h2 id="2005：-Not-only-SQL。不仅仅是SQL"><a href="#2005：-Not-only-SQL。不仅仅是SQL" class="headerlink" title="2005： Not only SQL。不仅仅是SQL"></a>2005： Not only SQL。不仅仅是SQL</h2><p>好吧，经过5年的忽悠，有很多人愿意相信NoSQL似乎确有其事，于是有一批先行者就开始探索各种玩法。</p>
<p><a href="http://www.lampchina.net/mod-news_do-show_id-8272.html" target="_blank" rel="external">Digg采用Cassandra遭遇失败，工程副总裁离职</a></p>
<p><img src="/images/blog/nosql_vs_sql/digg.jpg" alt="Digg副总裁离职"></p>
<p>点个蜡</p>
<p>玩着玩着，大家发现还是不靠谱，这样不行啊</p>
<p>这东西不就是让我们每个业务都把关系数据库重新实现一把么？让我们退回层次模型上去啊。</p>
<p>对于人类这种懒惰而笨拙的动物，开历史的倒车明显是不受待见的。</p>
<p>于是，有一批人站出来，说No什么SQL，还是得有数据库。</p>
<p>但是NoSQL开发者已经忽悠了那么多投资人的前，总得要有一个交代吧。所以，既然没有办法颠覆，咱们就共存吧。</p>
<p>什么NoSQL和SQL，大家一家人，各种发展就好了。这就是Not only SQL的来源。</p>
<p>NoSQL有哪些明确的场景呢？</p>
<p>比如HDFS比较火，于是就有人发现，哎，我们如果学google，也弄一个分布式的KV是不是也能火？我想，这就是某base最大的价值。</p>
<p>不过，在这个平缓期，还是能看到一些创新性的想法的。他们帮助数据库领域往前走了不大的一步。MongoDB是个不错的思路（我个人觉得）。</p>
<p>json代替了臃肿的xml成为一个小的标准。而且，这个上面做了很多索引，也是很聪明的做饭。借鉴了数据库的核心思路，这也算是共存了。其他的NoSQL也在往SQL上努力。比如Cassandra的cql，HBase的各类SQL引擎，其实都是对关系数据模型的一种妥协。</p>
<p>毕竟，NoSQL还没有好到能够颠覆整个生态。</p>
<h2 id="2013-No-SQL"><a href="#2013-No-SQL" class="headerlink" title="2013 No, SQL!"></a>2013 No, SQL!</h2><p>不，我们还是要关系数据库。</p>
<p>这就是我们现在的感觉。</p>
<p>经过了10年的折腾，我们还是发现，关系模型目前来说是最方便表达数据存储的语言。比其他都要方便的多。所以，还是妥协吧，于是，所有的NoSQL都想办法尝试支持关系数据库。</p>
<p>然而，回到初始，我们不就是因为关系数据库不能满足要求，所以才要做NoSQL的么？难道NoSQL弄个关系代数引擎，就能够做出魔法末？</p>
<p>其实，也不行。</p>
<p>模型上能够规避和腾挪的空间并不是很大。</p>
<p>最终，大家殊途同归，还是回到如何能够让关系数据库更具有扩展性，性能更好，这条道路上来，条条大路通罗马嘛~和气生财。</p>
<p>这就是NewSQL的来源。</p>
<p>DRDS也是NewSQL的一员，其实说实话，我挺有感触的，作为这么多年一直坚守在分布式数据库这个领域的人来说，能够坚持下来真的不容易，太多诱惑都在外面，最火的时候，连DBA都去学了各种NoSQL的运维技术。</p>
<p>然而，我们能够坚守，其实是因为我们懂得历史，也看得到现在。我们深刻的知道，科学就是承认自己并非无所不能。然后不断的往那无所不能的地方努力的一种精神。</p>
<p>一直以来，我们都尽可能的协助用户保留关系数据库的方便性，然后想办法告知用户，哪些地方目前还缺少技术突破，应该使用哪些工具来替代。</p>
<p>所以也算是积累了非常多的经验和工具。同时，我们也努力追求数据库领域的那个圣杯。更快的存取数据，可以按需扩缩以承载更大的访问量和更大的数据量，开发容易，硬件成本低。这些是大家梦寐以求在追求的动向，也是我们在追求的。虽不能至，吾心向往之。</p>
<p>最后，来聊聊阿里的技术选择。</p>
<p>其实，所有大公司似乎都在释放各种信号，xxx在用了什么系统了，xxx在用了什么系统了……</p>
<p>阿里可能不大一样，从内部来说，它也是一个生态系统，用户选择什么实际上主要都是由用户自己决定的。所以，阿里能够出现任何一种选择，只要能够解决问题即可。</p>
<p>他们就是工作不饱和和啥都试一试。</p>
<p>TDDL DRDS这套体系，只能说是目前用的最广的一套。原因也很简单，改变行为习惯少。</p>
<p>双11对DRDS这套体系来说，其实没有什么压力。我前几年的双十一虽然都在核心作战室，不过我一般的做法都是到了那里：“您辛苦了，您也是，大家辛苦了”，然后吃吃吃……</p>
<p>因为确实没有什么好担心的啊，没有不平稳的理由。</p>
<p>DRDS的能力更多体系在双十一开始和双十一结束。我们需要在那之前机器扩容，以及在那之后的机器缩容。这些才是DRDS的的核心能力。</p>
<p>上上次我的确很是紧张……因为新接了一个消息系统。这种削峰填谷的系统才是亚历山大啊……</p>
<p>其余的生活基本上就没啥了……更多是跟大家一样，也都是普通的功能开发而已。</p>
<p>好了，我的故事将完了。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><p>问题1. 能说说DRDS和RDS的关系吗？</p>
<pre><code>一个偏重分布式，一个偏重单机
</code></pre><p>问题2. 请问阿里的DRDS如何实现join sql语句来执行多表关联查询的？如何兼容单机存储的SQL？需要注意哪些坑？</p>
<pre><code>方案很多，其实如果大家对join有所了解，也就那么几种，hash/index nest loop/sort merge，没有什么魔法。http://coding-geek.com/how-databases-work/ 这个不错，我比较推荐。
</code></pre><p>问题3. 请问schema less/free你怎么看？</p>
<pre><code>这俩似乎没见过拼一起哈，我分开。但是本质是同一个东西，我个人觉得有市场。不过能有多大，不知道。
优势：业务模型更灵活。
劣势：额外的空间占用。

技术债也一定要还的......我清楚的记得当年我维护的一个cms系统，所有数据都是map。结果最后有一些诡异的数据不知道什么时候被塞到里面，然后最后也没有人知道是在哪里塞的，debug都很难找到。
所以，一般来说，结合会更好一些。

目前pg/mysql都开始支持json了，这东西其实只是工作量的问题，没有什么技术上的难度。
</code></pre><p>问题4. 最近很多声音说不要在用户mongodb了，如何来看？</p>
<pre><code>这个就纯属于个人意见了啊...... 我个人不喜欢mongodb那帮人的嘴脸......

[MongoDB核心贡献者：不是MongoDB不行，而是你不懂！](http://www.cnblogs.com/shanyou/archive/2012/11/17/2774344.html)

然而，为什么会这样？还不是某些人为了骗分，默认配置特别激进...... 而开发者不会告诉你，如果改成安全配置，他们的性能没比MySQL强哪里去。

一个存储引擎，至少10年才能稳定。前两天刚碰到一个游戏客户说某nosql数据文件损坏无法恢复，问我们有没有办法，我说，下次选择谨慎点......性能不是唯一的。这次请节哀。
</code></pre><p>问题5. 海量，低延时（毫秒级），高并发（十万以上），目前关系型数据库是否有并存的方案？</p>
<pre><code>10w并发不算很高了，DRDS是你最好的选择。
</code></pre><p>问题6. 非结构化数据，如文本，树图等，这些sql无法处理的，是否是用nosql更合理？</p>
<pre><code>非结构化数据也是一个重要的门类，一直都存在，以后也会存在，但是nosql为了宣传，把所有的东西都拉到自己阵营，这其实与其初衷已经违背了。
twtter的图数据库其实也是依托mysql做的......你给我钱给我人，给我时间，我能汇编写任何东西。
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于LinkedHashMap的LRUCache实现]]></title>
      <url>http://tonydeng.github.io/2015/07/16/linkedhashmap-based-lrucache-implementation/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/lru/lru-cache.png" alt="LRU Cache"></p>
<p>让面试者描述一下缓存算法，以及经典的缓存算法LRU的实现，是我在面试过程中经常会问到的题目。</p>
<p>能够当场说出LRU算法实现思路的人基本没有，甚至不少人都无法说清楚LRU是一个实现什么功能的算法。（现在肯专心研究数据结构和算法的人不多了）</p>
<a id="more"></a>
<p>那我们今天就说一下LRU算法，分两点来说一下。</p>
<ol>
<li>LRU算法是要做什么？</li>
<li>我们有没有什么简单的方法来实现LRU算法？</li>
</ol>
<h4 id="先说说第一点，LRU算法是要做什么？"><a href="#先说说第一点，LRU算法是要做什么？" class="headerlink" title="先说说第一点，LRU算法是要做什么？"></a>先说说第一点，LRU算法是要做什么？</h4><p>其实解释起来很简单，LRU就是<strong>Least Recently Used</strong>的缩写，翻译过来就是<strong>“最近最少使用”</strong>。也就是说LRU算法会将最近最少用的缓存移除，让给最新使用的缓存。而往往最常读取的，也就是读取次数最多的，所以利用好LRU算法，我们能够提供对热点数据的缓存效率，能够提高缓存服务的内存使用率。</p>
<h4 id="那如何来实现呢？"><a href="#那如何来实现呢？" class="headerlink" title="那如何来实现呢？"></a>那如何来实现呢？</h4><p>我们先来梳理一下，需要实现几个什么功能？</p>
<ol>
<li>限制缓存大小</li>
<li>查询出最近最晚用的缓存</li>
<li>给最近最少用的缓存做一个标识</li>
</ol>
<p>其实，实现的思路非常简单，就像下面这张图种描述的一样。</p>
<p><img src="/images/blog/lru/lru.png" alt="LRU"></p>
<p>今天我就利用<code>Java</code>的<code>LinkedHashMap</code>用非常简单的代码来实现基于LRU算法的Cache功能。</p>
<p>实现代码如下，加上<code>import</code>语句、注释和空行，也才不到20行的代码，就能够实现一个LRU算法的Cache：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 简单用LinkedHashMap来实现的LRU算法的缓存</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>, (<span class="keyword">float</span>) <span class="number">0.75</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Ignore;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LRUCacheTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LRUCache&lt;String, Integer&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.put(<span class="string">"k"</span> + i, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String key = <span class="string">"k"</span> + RandomUtil.getNum(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"all cache :'&#123;&#125;'"</span>,cache);</span><br><span class="line"></span><br><span class="line">        cache.put(<span class="string">"k"</span> + <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"After running the LRU algorithm cache :'&#123;&#125;'"</span>, cache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重新安装Homebrew]]></title>
      <url>http://tonydeng.github.io/2015/07/11/brew-reinstall/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/homebrew.png" alt="Homebrew"></p>
<p>Mac Book用了几年之后，基本上其他的笔记本都已经看不上了，这个看不上不仅仅是设计感、硬件性价比等原因，更多是对工作效率的提高（尤其对于一个多年的互联网工作者），工作效率极有可能会成为一个公司成功或失败的一个不可忽视的原因。<a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a>是我在Mac下一直使用的包管理系统，而且我觉得<a href="http://brew.sh" target="_blank" rel="external">Homebrew</a>是提高工作效率的非常重要的组成部分。</p>
<a id="more"></a>
<p>前段时间给<a href="http://janehao.github.io" target="_blank" rel="external">媳妇</a>也买了一台13寸的Mac Book Pro，当天就配置好了<a href="http://brew.sh" target="_blank" rel="external">Homebrew</a>环境，但是不知怎么回事，今天在使用brew时，提示下面的错误信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh: <span class="built_in">command</span> not found: brew</span><br></pre></td></tr></table></figure>
<p>进入brew的工作目录<code>/usr/local</code>一看，原来<code>/usr/local/bin</code>都没有了，难怪系统找不到brew这个命令。</p>
<p>那么怎么办？最简单的办法就是重新安装<a href="http://bash.sh" target="_blank" rel="external">Homebrew</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby <span class="_">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<p>但是执行安装命令之后，发现提示brew已经安装了。</p>
<p>查看<code>/usr/local</code>目录发现，原来还有一个关键目录还在，就是<code>.git</code>目录。用过Git的同学都应知道，<code>.git</code>目录是你本地仓库的，存储了所有该仓库的信息和历史。安装脚本检测到有brew之前的信息，当然会提示你brew已经安装了。</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">$ ls -al /usr/local/</span><br><span class="line">drwxrwxr-<span class="keyword">x</span>  <span class="number">15</span> root      admin   <span class="number">510</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> .</span><br><span class="line">drwxr-xr-<span class="keyword">x</span>@ <span class="number">12</span> root      wheel   <span class="number">408</span>B  <span class="number">3</span>  <span class="number">7</span> <span class="number">22</span>:<span class="number">59</span> ..</span><br><span class="line">drwxr-xr-<span class="keyword">x</span>  <span class="number">14</span> tonydeng  admin   <span class="number">476</span>B  <span class="number">7</span> <span class="number">12</span> <span class="number">00</span>:<span class="number">17</span> .git</span><br><span class="line">-rw-<span class="keyword">r</span>--<span class="keyword">r</span>--   <span class="number">1</span> tonydeng  admin   <span class="number">301</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> .gitignore</span><br><span class="line">-rw-<span class="keyword">r</span>--<span class="keyword">r</span>--   <span class="number">1</span> tonydeng  admin   <span class="number">261</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> .yardopts</span><br><span class="line">drwxr-xr-<span class="keyword">x</span>   <span class="number">4</span> tonydeng  admin   <span class="number">136</span>B  <span class="number">7</span> <span class="number">11</span> <span class="number">23</span>:<span class="number">50</span> share</span><br></pre></td></tr></table></figure>
<p>好吧，找到问题关键了，那么我们就解决问题吧。</p>
<p>执行下面的命令，brew就回来了，又可以愉快的玩耍了~~</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">rm -rf <span class="regexp">/usr/</span>local<span class="regexp">/.git &amp;&amp; ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTPie:超爽的HTTP命令行客户端]]></title>
      <url>http://tonydeng.github.io/2015/07/10/httpie-howto/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/httpie/httpie-logo.png" alt="HTTPie Logo"></p>
<p>之前在命令行下进行HTTP服务的调试和信息查看都是使用经典的<a href="http://curl.haxx.se" target="_blank" rel="external">cURL</a>，不过前段时间发现一个交互更加友好的工具，就是<a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">HTTPie</a>。</p>
<a id="more"></a>
<p>先放一个HTTPie官方的一个HTTPie VS cURL的图给大家看看。</p>
<p><img src="/images/blog/httpie/httpie-vs-curl.png" alt="HTTPie VS cURL"></p>
<p>如果你经常需要用终端以非交互模式访问网络服务器（比如，下载文件、测试REST服务），可能你会选择的工具是wget或curl，通过大量的选项，这两种工具也都可以处理很多非交互网络访问的情况（比如，<a href="http://xmodulo.com/how-to-download-multiple-files-with-wget.html" target="_blank" rel="external">如何通过wget下载多个文件</a>，<a href="http://xmodulo.com/how-to-use-custom-http-headers-with-wget.html" target="_blank" rel="external">如何在wget中设置自定义的http头</a>，<a href="https://linux.cn/article-4957-1.html" target="_blank" rel="external">如何在curl中设置自定义的HTTP头</a>）。然而，除非你很精通这些繁复的语法细节，这些工具对于你来说，不过是简单的下载工具而已。</p>
<p>“Its goal is to make CLI interaction with web services as <strong>human-friendly</strong> as possible. It provides a simple http command that allows for sending arbitrary HTTP requests using <strong>a simple and natural syntax</strong>, and <strong>displays colorized output</strong>. “</p>
<p>HTTPie则在使用时的表现力、人性化做得比wget、curl好得多，就像在官网上宣传的那样，它追求的是人性化、简单自然的语法，以及彩色的输出。而且HTTPie还有一些不错的优点，比如对JSON的良好支撑、持久性会话等特性。</p>
<p>上面说了那么多，咱们废话少说，先来了解并展示一下<a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="external">HTTPie</a>。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h5 id="Linux上安装"><a href="#Linux上安装" class="headerlink" title="Linux上安装"></a>Linux上安装</h5><p>Debian, Ubuntu或Linux Mint</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install httpie</span><br></pre></td></tr></table></figure>
<p>Fedora，CentOS/RHEL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install httpie</span><br></pre></td></tr></table></figure>
<p>或者使用python的方式来安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo  pip install --upgrade httpie</span><br></pre></td></tr></table></figure>
<h5 id="Mac-OSX"><a href="#Mac-OSX" class="headerlink" title="Mac OSX"></a>Mac OSX</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install httpie</span><br></pre></td></tr></table></figure>
<h3 id="安装开发版本"><a href="#安装开发版本" class="headerlink" title="安装开发版本"></a>安装开发版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mac OSX</span></span><br><span class="line">brew install httpie --HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python安装方式</span></span><br><span class="line">pip install --upgrade https://github.com/jkbrzt/httpie/tarball/master</span><br></pre></td></tr></table></figure>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><h4 id="定制头部"><a href="#定制头部" class="headerlink" title="定制头部"></a>定制头部</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http tonydeng.github.io/blog/2015/07/10/httpie-howto/ User-Agent:Xmodlo/1.0 Referer:http://tonydeng.github.io</span><br></pre></td></tr></table></figure>
<p>这个HTTP请求看起是这样。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/blog/2015/07/10/httpie-howto/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">Referer</span>: http://tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: Xmodlo/1.0</span><br></pre></td></tr></table></figure>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p>你也可以把HTTPie作为文件下载器来使用。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">http tonydeng.github.io<span class="regexp">/blog/</span><span class="number">2015</span><span class="regexp">/07/</span><span class="number">10</span><span class="regexp">/httpie-howto/</span> &gt; httpie-howto.html</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">http --download tonydeng.github.io<span class="regexp">/blog/</span><span class="number">2015</span><span class="regexp">/07/</span><span class="number">10</span><span class="regexp">/httpie-howto/</span></span><br></pre></td></tr></table></figure>
<h4 id="使用其他HTTP方法"><a href="#使用其他HTTP方法" class="headerlink" title="使用其他HTTP方法"></a>使用其他HTTP方法</h4><p>除了默认的GET方法，你还可以使用其他方法（比如PUT、POST、DELETE、HEAD）</p>
<h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">http PUT tonydeng<span class="selector-class">.github</span><span class="selector-class">.io</span> name=<span class="string">'Tony Deng'</span> email=<span class="string">'tonydeng@email.com'</span></span><br></pre></td></tr></table></figure>
<h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">http -f POST tonydeng<span class="selector-class">.github</span><span class="selector-class">.io</span> name=<span class="string">'Tony Deng'</span> email=<span class="string">'tonydeng@email.com'</span></span><br></pre></td></tr></table></figure>
<p><code>-f</code> 选项使http命令序列化数据字段，并将<code>Content-Type</code>设置为<code>application/x-www-form-urlencoded;charset=utf-8</code></p>
<p>这个HTTP POST请求看起这样：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 41</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded; charset=utf-8</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: HTTPie/0.9.2</span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">name</span>=Tony+Deng&amp;email=tonydeng%<span class="number">40</span>email.com</span></span><br></pre></td></tr></table></figure>
<h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">http HEAD tonydeng<span class="selector-class">.github</span><span class="selector-class">.io</span></span><br></pre></td></tr></table></figure>
<p><code>HEAD</code>这个方法只会让服务器返回<code>http response headers</code>。</p>
<p>这个命令结果如下：</p>
<h6 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h6><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: HTTPie/0.9.2</span><br></pre></td></tr></table></figure>
<h6 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h6><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: *</span><br><span class="line"><span class="attribute">Age</span>: 0</span><br><span class="line"><span class="attribute">Cache-Control</span>: max-age=600</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 36794</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Date</span>: Wed, 15 Jul 2015 09:26:22 GMT</span><br><span class="line"><span class="attribute">Expires</span>: Wed, 15 Jul 2015 09:36:22 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span>: Sun, 12 Jul 2015 11:32:15 GMT</span><br><span class="line"><span class="attribute">Server</span>: GitHub.com</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding</span><br><span class="line"><span class="attribute">Via</span>: 1.1 varnish</span><br><span class="line"><span class="attribute">X-Cache</span>: MISS</span><br><span class="line"><span class="attribute">X-Cache-Hits</span>: 0</span><br><span class="line"><span class="attribute">X-Served-By</span>: cache-fra1227-FRA</span><br><span class="line"><span class="attribute">X-Timer</span>: S1436952382.011631,VS0,VE99</span><br></pre></td></tr></table></figure>
<h4 id="JSON支持"><a href="#JSON支持" class="headerlink" title="JSON支持"></a>JSON支持</h4><p>HTTPie内置JSON的支持。事实上HTTPie默认使用的<code>Content-Type</code>就是<code>application/json</code>。因此，当你不指定<code>Content-Type</code>发送请求参数时，它们就会自动序列化为JSON对象。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">http POST tonydeng<span class="selector-class">.github</span><span class="selector-class">.io</span> name=<span class="string">'Tony Deng'</span> email=<span class="string">'tonydeng@email.com'</span></span><br></pre></td></tr></table></figure>
<p>这个请求看起来就是这样：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 52</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Host</span>: tonydeng.github.io</span><br><span class="line"><span class="attribute">User-Agent</span>: HTTPie/0.9.2</span><br><span class="line"></span><br><span class="line"><span class="json">&#123;</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"tonydeng@email.com"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Tony Deng"</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p>HTTPie的另外一个友好特性就是输入重定向，你可以使用缓冲数据提供HTTP请求内容。例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">http</span> <span class="selector-tag">POST</span> <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span> &lt; <span class="selector-tag">my_info</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">echo '&#123;<span class="string">"name"</span>: <span class="string">"Tony Deng"</span>,<span class="string">"email"</span>: <span class="string">"tonydeng@email.com"</span>&#125;' <span class="string">| http POST tonydeng.github.io</span></span><br></pre></td></tr></table></figure>
<p>好了，暂时演示这么多吧，估计大家对HTTPie也有了一个基本的了解。如果大家想看看更多的HTTPie的特性和功能，可以看看<a href="https://github.com/jkbrzt/httpie/blob/master/README.rst" target="_blank" rel="external">HTTPie的README</a>，并且自己安装一个尝试使用一下。估计到时候你也和我一样对其爱不释手，立马抛弃了wget和curl。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git的各种Undo技巧]]></title>
      <url>http://tonydeng.github.io/2015/07/08/how-to-undo-almost-anything-with-git/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/git-undo/git-undo.jpg" alt="git undo"></p>
<p><a href="https://github.com" target="_blank" rel="external">GitHub</a>的<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">How to undo (almost) anything with Git</a>这篇文章介绍了<a href="https://git-scm.com" target="_blank" rel="external">Git</a>使用中的各种Undo技巧。</p>
<p>任何版本控制系统中最有用的功能之一就是能够<strong>“撤销（undo）”</strong>你之前的错误。在Git中<strong>“undo”</strong>功能可能因为场景的不同而有些许的差异。</p>
<p>当你进行一个新的提交时，Git会保存你在这个特定时间点的快照到本地的仓库中，之后，你可以通过Git来回到你早期的某个版本。</p>
<p>我们来先看看一些需要你“撤销”的常见场景，你可以尝试使用Git来用最佳的方式来解决它。</p>
<a id="more"></a>
<h2 id="撤销已经推送到远程的变更"><a href="#撤销已经推送到远程的变更" class="headerlink" title="撤销已经推送到远程的变更"></a>撤销已经推送到远程的变更</h2><h4 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h4><p>你已经执行<strong>git push</strong>,把你的修改推送到远程的仓库，现在你意识到之前推送的<strong>commit</strong>中有一个有些错误，想要撤销该commit。</p>
<h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>&lt;SHA&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p><strong>git revert</strong> 会创建一个新的<strong>commit</strong>，它和指定SHA对应的<strong>commit</strong>是相反的（或者说是反转的）。如果原型的commit是“物质”，那么新的<strong>commit</strong>就是“反物质”。</p>
<p>任何从原来的commit里删除的内容都会再新的<strong>commit</strong>里被加回去，任何原来的<strong>commit</strong>中加入的内容都会在新的commit里被删除。</p>
<p>这是Git中最安全、最基本的撤销场景，因为它并不会改变历史。所以你现在可以<strong>git push</strong>新的<strong>“反转”commit</strong>来抵消你错误提交的commit。</p>
<h2 id="修正最后一个commit的消息"><a href="#修正最后一个commit的消息" class="headerlink" title="修正最后一个commit的消息"></a>修正最后一个commit的消息</h2><h4 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h4><p>你在最后一条commit消息里有一个笔误，已经执行了 <strong>git commit -m ‘Fixes bug #42’</strong> ,但是在git push之前你意识到这个消息应该是<strong>“Fix bug #43”</strong>。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>你可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit --amend -m <span class="string">'Fixes bug #43'</span></span><br></pre></td></tr></table></figure>
<h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p><strong>git commit –amend</strong> 会用一个新的commit更新并替换最近的<strong>commit</strong>，这个新的<strong>commit</strong>会把任何修改内容和上一个<strong>commit</strong>的内容结合起来。如果当前没有提出任何修改，这个操作就只会把上次的<strong>commit</strong>重写一遍。</p>
<h2 id="撤销“本地的”修改"><a href="#撤销“本地的”修改" class="headerlink" title="撤销“本地的”修改"></a>撤销“本地的”修改</h2><h4 id="场景：-2"><a href="#场景：-2" class="headerlink" title="场景："></a>场景：</h4><p>一只喵从键盘上走过（在我们家就是儿子小手在键盘上划拉），无意中保存了修改，然后破坏了编辑器。不过，你还没有<strong>commit</strong>这些修改。你想要恢复被修改文件里的所有内容–就像上次<strong>commit</strong>的时候一模一样。</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- &lt;bad filename&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>git checkout</code>会把工作目录中的文件修改到Git之前记录的某个状态。你可以提供你想返回的分支或者特定的SHA，或者在缺省情况下，GIt会认为你希望checkout的是<strong>HEAD</strong>，当前checkout分支的<strong>最后一次commit</strong>。</p>
<p>记住： <strong>你用这种方法“撤销”的任何修改真的会完全消失</strong>。因为它们从来没有被提交过，所以之后Git也无法帮助我们恢复它们。你一定要确保自己了解在这个操作中丢掉的东西是什么？（也行可以利用<code>git diff</code>先确认一下）</p>
<h2 id="重置“本地的”修改"><a href="#重置“本地的”修改" class="headerlink" title="重置“本地的”修改"></a>重置“本地的”修改</h2><h4 id="场景：-3"><a href="#场景：-3" class="headerlink" title="场景："></a>场景：</h4><p>你在本地提交了一下东西（还没有push），但是所有这些东西都很糟糕，你希望撤销前面的三次提交（就像它们从来没有发生过一样）。</p>
<h4 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> &lt;<span class="keyword">last</span> good <span class="keyword">SHA</span>&gt;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">reset</span> --hard &lt;<span class="built_in">last</span> good SHA&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h4><p><code>git reset</code>会把你的代码库历史返回到指定的SHA状态。这样就像是这些提交从来没有发生过。缺省情况下，<code>git reset</code>会保留工作目录。这样，提交是没有了，但是修改内容还在磁盘上。这是一种安全的选择，但通常我们会希望一步就“撤销”提交已经修改内容(这就是<code>--hard</code>选项的功能)。</p>
<h2 id="在撤销“本地修改”之后再恢复"><a href="#在撤销“本地修改”之后再恢复" class="headerlink" title="在撤销“本地修改”之后再恢复"></a>在撤销“本地修改”之后再恢复</h2><h4 id="场景：-4"><a href="#场景：-4" class="headerlink" title="场景："></a>场景：</h4><p>你提交了几个commit，然后用<code>git reset --hard</code>撤销了这些修改（见上一段），接着你又意识到：你希望还原这些修改！</p>
<h4 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> reflog</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">reset</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout</span><br></pre></td></tr></table></figure>
<h4 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h4><p><code>git reflog</code>对于恢复项目历史是一个超棒的方式。你可以恢复几乎任何（commit过的）东西。</p>
<p>你可以能熟悉<code>git log</code>命令，它会显示commit的列表。 git reflog也是类似的，不过它显示的是一个HEAD发生改变的时间列表。</p>
<p>一些注意事项：</p>
<ul>
<li>它涉及的只是HEAD的改变。在你切换分支、用git commit进行提交、以及用git reset撤销commit时，HEAD会发生改变，但当你使用<code>git checkout -- &lt;bad filename&gt;</code>撤销时，HEAD并不会发生改变。就像我们在上面说的，这些修改从来没有被提交过，因此reflog也无法帮助我们恢复它们。</li>
<li><code>git reflog</code>不会永远保持。Git会定期清理那些“用不到的”对象。不要指望几个月前的提交还一直躺着那里。</li>
<li>你的reflog就是你的，只是你的，你不能用<code>git reflog</code>来恢复另外一个开发者没有push过的commit。</li>
</ul>
<p><img src="/images/blog/git-undo/reflog.png" alt="git reflog"></p>
<p>那么…你如何来利用reflog来“恢复”之前“撤销”的commit呢？它取决于你想做到的到底是什么。</p>
<ul>
<li>如果你希望准确的恢复项目的历史到某个时间点，用<code>git reset --hard &lt;SHA&gt;</code></li>
<li>如果你希望重建工作目录里的一个或多个文件，让它们恢复到某个时间点的状态，用<code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code></li>
<li>如果你希望把这些commit里的某个重新提交到你的代码库里，用<code>git cherry-pick &lt;SHA&gt;</code></li>
</ul>
<h2 id="利用分支的另一种做法"><a href="#利用分支的另一种做法" class="headerlink" title="利用分支的另一种做法"></a>利用分支的另一种做法</h2><h4 id="场景：-5"><a href="#场景：-5" class="headerlink" title="场景："></a>场景：</h4><p>你进行了一些提交，然后意识到你开始checkout的是master分支。希望这些提交进入到另外一个特性（feature）分支。</p>
<h4 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git branch <span class="built_in">feature</span></span><br><span class="line">git <span class="built_in">reset</span> --hard <span class="built_in">origin</span>/master</span><br><span class="line">git checkout <span class="built_in">feature</span></span><br></pre></td></tr></table></figure>
<h4 id="原理：-4"><a href="#原理：-4" class="headerlink" title="原理："></a>原理：</h4><p>你可能习惯用 <code>git checkout -b &lt;name&gt;</code>创建一个新的分支（这是创建新分支并马上checkout的流行捷径），但是你不希望马上切换分支。这里，<code>git branch feature</code>创建了一个叫做feature的新分支，并指向你最近的commit，但是还是让你checkout在master分支上。</p>
<p>下一步，在提交任何新的commit之前，用<code>git reset --hard</code> 把master分支倒回origin/master。不过别担心，那些commit还在feature分支里。</p>
<p>最后，用<code>git checkout</code>切换到新的feature分支，并让你最近所有的工作成果都完好无损。</p>
<h2 id="及时分支，省去繁琐"><a href="#及时分支，省去繁琐" class="headerlink" title="及时分支，省去繁琐"></a>及时分支，省去繁琐</h2><h4 id="场景：-6"><a href="#场景：-6" class="headerlink" title="场景："></a>场景：</h4><p>你在master分支的基础上创建一个feature分支，但是master分支已经滞后于origin/master很多。现在master分支已经和origin/master同步，你希望在feature上的提交从现在开始，而不是从滞后很多的地方开始。</p>
<h4 id="方法：-4"><a href="#方法：-4" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git checkout <span class="built_in">feature</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git rebase <span class="literal">master</span></span><br></pre></td></tr></table></figure>
<h4 id="原理：-5"><a href="#原理：-5" class="headerlink" title="原理："></a>原理：</h4><p>要达到这个效果，你本来可以通过<code>git reset</code>（不加<code>--hard</code>，这样可以再磁盘上保留修改）和<code>git checkout -b &lt;new branch name&gt;</code>然后再重新提交修改，不过这样做的话，你就失去提交历史。我们有更好的办法。</p>
<p><code>git rebase master</code>会做下面的这些事情：</p>
<ol>
<li>首先它会找到你当前checkout的分支和master分支的共同祖先。</li>
<li>然后它reset当前checkout的分支到那个共同祖先 ，在一个临时保存区存放所有之前的提交。</li>
<li>然后它把当前checkout的分支提到master的末尾部分，并从临时保存区重新把存放的commit提交到master分支的最后 一个commit之后。</li>
</ol>
<h2 id="大量的撤销-恢复"><a href="#大量的撤销-恢复" class="headerlink" title="大量的撤销/恢复"></a>大量的撤销/恢复</h2><h4 id="场景：-7"><a href="#场景：-7" class="headerlink" title="场景："></a>场景：</h4><p>你向某个方向开始实现一个特性，但是你半路意识到另一个方案更好。你已经进行了十几次的提交，但是你现在只需要其中的一部分。你希望其他不需要的提交统统消失。</p>
<h4 id="方案：-1"><a href="#方案：-1" class="headerlink" title="方案："></a>方案：</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git rebase -<span class="selector-tag">i</span> &lt;carlier SHA&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原理：-6"><a href="#原理：-6" class="headerlink" title="原理："></a>原理：</h4><p><code>-i</code> 参数会让rebase进入“交互模式”。它开始类似于签名讨论的rebase，但在重新进行任何提交之前，它会暂停下来并允许你详细的修改每一个提交。</p>
<p><code>rebase -i</code> 会打开你缺省的文本编辑器，里面列出候选的提交。</p>
<p><img src="/images/blog/git-undo/rebase_1.png" alt="rebase -i"></p>
<p>前面两列是键： 第一个是选定的命令，对应第二列里的SHA确定的commit。缺省情况下，<code>rebase -i</code>假定每个commit都要通过pick命令被运行。</p>
<p>要丢弃一个commit，只要在编辑器中删除那一行就行了。如果你不再需要项目里面的那几个错误的提交， 删除你想删除的几行。</p>
<p>如果你需要暴漏commit的内容，而是对commit消息进行编辑，你可以使用reword命令，将第一列的pick替换成reword（或者直接使用r）。有人会觉得再这里直接重写commit消息就行了，但是这样是不管用的（rebase -i会忽略SHA列前面的任何东西，它后面的文本只是用来帮助我们记住那一串SHA代表什么）。当你完成rebase -i的操作之后，你会被提示输入需要编写的任何commit消息。</p>
<p>如果你需要把两个commit合并在一起，你可以使用squash或者fixup命令。</p>
<p><img src="/images/blog/git-undo/rebase_edit.png" alt="rebase -i"></p>
<p>squash和fixup会“向上”合并（带有这两个命令的commit会被合并到他的签一个commit里）。上面的这个例子里，<code>0835fe2</code>和<code>6943e85</code>会合并成一个commit，<code>38f5c4c</code>和<code>af67f82</code>会被合并成另一个。</p>
<p>如果你选择了squash，Git会提示我们给新合并的commit一个新的commit消息； fixup则会把合并清单里的第一个commit的消息直接给新合并的commit。</p>
<p>在你保存并推出编辑器的时候，Git会按从顶部到底部的顺序运用你的commit。你可以通过在保存前修改commit顺序来改变运用的顺序。如果你愿意，你也可以同如下安排把<code>af67f82</code>和<code>0835fe2</code>合并到一起。</p>
<p><img src="/images/blog/git-undo/rebase_fixup.png" alt="rebase -i"></p>
<h2 id="修复更早期的commit"><a href="#修复更早期的commit" class="headerlink" title="修复更早期的commit"></a>修复更早期的commit</h2><h4 id="场景：-8"><a href="#场景：-8" class="headerlink" title="场景："></a>场景：</h4><p>你在一个更早期的commit里忘记了加入一个文件，如果更早的commit能包含这个忘记的文件就太棒了。你还没有push，但这个commit不是最近的，所以你还没法用commit –amend</p>
<h4 id="方法：-5"><a href="#方法：-5" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--squash &lt;SHA of the earlier commit&gt;</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git rebase --autosquash -<span class="selector-tag">i</span> &lt;even earlier SHA&gt;</span><br></pre></td></tr></table></figure>
<h4 id="原理：-7"><a href="#原理：-7" class="headerlink" title="原理："></a>原理：</h4><p><code>git commit --squash</code>会创建一个新的commit，它带有一个commit消息，类似于squash! Earlier commit。(你也可以手工创建一个带有类似commit消息的commit，但是 commit –squash 可以帮你省下输入的工作)</p>
<p>如果你不想被提示为新合并的commit输入一条新的commit消息，你也可以利用 <code>git commit --fixup</code>。在这个情况下，你很有可能会用<code>commit --fixup</code>，因为你只是希望在rebase的适合，使用早期commit的commit消息。</p>
<p><code>rebase --autosquash -i</code> 会激活一个交互式的rebase编辑器，但是编辑器打开的适合，在commit清单里任何squash!和fixup！的commit都已经配对到目标commit上了。</p>
<p><img src="/images/blog/git-undo/rebase_autosquash.png" alt="rebase --autosquash -i"></p>
<p>在使用 <code>--squash</code> 和 <code>--fixup</code>的适合，你可能不记得想要修正的commit的SHA了（只是记得它是前面的第1个或者第5个commit）。你会发现Git的<code>^</code>和<code>~</code>操作符特别好用。<code>HEAD~</code>是HEAD的前一个commit。<code>HEAD~4</code>是HEAD往前第4个（或者一起算，倒数第5个commit）。</p>
<h2 id="停止追踪一个文件"><a href="#停止追踪一个文件" class="headerlink" title="停止追踪一个文件"></a>停止追踪一个文件</h2><h4 id="场景：-9"><a href="#场景：-9" class="headerlink" title="场景："></a>场景：</h4><p>你偶然把application.log加到代码库里了，现在每次你运行应用，Git都会报告在application.log里有未提交的修改。你把 *.log放到了.gitignore文件里，可文件还是在代码库里，你怎样才能让Git“撤销”对这个文件的追踪呢？</p>
<h4 id="方法：-6"><a href="#方法：-6" class="headerlink" title="方法："></a>方法：</h4><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">rm</span> --cached application.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><p>虽然.gitignore会阻止Git追踪文件的修改，甚至不关注文件是否存在，但这只是针对那些以前从来没有追踪过的文件。一旦有个文件被加入并提交了，Git就会持续关注改文件的改变。类似地，如果你利用<code>git add -f</code>来强制或覆盖了.gitignore，Git还会持续追踪改变的情况。之后你就不必用-f来添加这个文件了。</p>
<p>如果你希望从Git的追踪对象中删除那个本应忽略的文件，<code>git rm --cached</code>会从追踪对象中删除它，但让文件在磁盘上保持原封不动。因为现在它已经被忽略了，你在<code>git status</code>里就不会再看见这个文件，也不回再偶然提交该文件的修改了。</p>
<p>这就是如何在Git里撤销任何操作的方法。要了解更多关于本文中用到的Git命令，请查看下面的相关文档。</p>
<ul>
<li><a href="http://git-scm.com/docs/git-checkout" target="_blank" rel="external">checkout</a></li>
<li><a href="http://git-scm.com/docs/git-commit" target="_blank" rel="external">commit</a></li>
<li><a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="external">rebase</a></li>
<li><a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="external">reflog</a></li>
<li><a href="http://git-scm.com/docs/git-reset" target="_blank" rel="external">reset</a></li>
<li><a href="http://git-scm.com/docs/git-revert" target="_blank" rel="external">revert</a></li>
<li><a href="http://git-scm.com/docs/git-rm" target="_blank" rel="external">rm</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux TCP/IP调优]]></title>
      <url>http://tonydeng.github.io/2015/05/25/linux-tcpip-tuning/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/tcpip.png" alt="tcp/ip"></p>
<p>根据 <a href="http://yangrong.blog.51cto.com/6945369/1321594" target="_blank" rel="external">杨云1028的Blog</a> 整理的参数的说明：</p>
<a id="more"></a>
<h2 id="Linux内核参数注释"><a href="#Linux内核参数注释" class="headerlink" title="Linux内核参数注释"></a>Linux内核参数注释</h2><h3 id="固定文件的内核参数"><a href="#固定文件的内核参数" class="headerlink" title="固定文件的内核参数"></a>固定文件的内核参数</h3><h4 id="下列文件所在目录："><a href="#下列文件所在目录：" class="headerlink" title="下列文件所在目录："></a>下列文件所在目录：</h4><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>建议值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>tcpsyn_retries</strong></td>
<td>5</td>
<td>1</td>
<td><strong>对于一个新建连接，内核要发送多少个SYN连接请求才决定放弃</strong>。不应该大于255,默认值是5，对应于180毫秒左右时间。（对于大负载而物理通信良好的网络来说，这个值偏高，可以修改为2。这个值仅仅是针对对外的连接，对进来的连接，是由<strong>tcp_retries1</strong>决定）</td>
</tr>
<tr>
<td><strong>tcp_synack_retries</strong></td>
<td>5</td>
<td>1</td>
<td><strong>对于远端的连接请求SYN，内核会发送SYN+ACK数据包，以确认收到上一个SYN连接请求包</strong>。这是所谓的三次握手机制的第二个步骤。这里决定内核再放弃之前所发送出的SYN+ACK数目。不应该大于255，默认值是5，对应于180秒左右时间。</td>
</tr>
<tr>
<td><strong>tcp_keepalive_time</strong></td>
<td>7200</td>
<td>600</td>
<td><strong>TCP发送keepalive探测消息的间隔时间（秒）</strong>，用于确认TCP连接是否有效。防止两边建立连接但不发送数据的攻击。</td>
</tr>
<tr>
<td><strong>tcp_keepalive_probes</strong></td>
<td>9</td>
<td>3</td>
<td>T<strong>CP发送keepalive探测消息的间隔时间（秒）</strong>，用于确认TCP连接是否有效。</td>
</tr>
<tr>
<td><strong>tcp_keepalive_intvl</strong></td>
<td>74</td>
<td>15</td>
<td><strong>探测消息未获得响应时，重发该消息的间隔时间（秒）</strong>。默认值为75秒。 (对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值,15是个比较合适的值)</td>
</tr>
<tr>
<td><strong>tcp_retries1</strong></td>
<td>3</td>
<td>3</td>
<td><strong>放弃回应一个TCP连接请求前﹐需要进行多少次重试</strong>。RFC 规定最低的数值是3</td>
</tr>
<tr>
<td><strong>tcp_retries2</strong></td>
<td>15</td>
<td>5</td>
<td><strong>在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试</strong>。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒).(这个值根据目前的网络设置,可以适当地改小,我的网络内修改为了5)</td>
</tr>
<tr>
<td><strong>tcp_orphan_retries</strong></td>
<td>7</td>
<td>3</td>
<td><strong>在近端丢弃TCP连接之前﹐要进行多少次重试。</strong>默认值是7个﹐相当于 50秒 - 16分钟﹐视 RTO 而定。如果您的系统是负载很大的web服务器﹐那么也许需要降低该值﹐这类 sockets 可能会耗费大量的资源。另外参的考tcp_max_orphans。(事实上做NAT的时候,降低该值也是好处显著的,我本人的网络环境中降低该值为3)</td>
</tr>
<tr>
<td><strong>tcp_fin_timeout</strong></td>
<td>60</td>
<td>2</td>
<td><strong>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间</strong>。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。默认值为 60 秒</td>
</tr>
<tr>
<td><strong>tcp_max_tw_buckets</strong></td>
<td>180000</td>
<td>36000</td>
<td><strong>系统在同时所处理的最大 timewait sockets 数目</strong>。如果超过此数的话﹐time-wait socket 会被立即砍除并且显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐不过﹐如果网络条件需要比默认值更多﹐则可以提高它(或许还要增加内存)。(事实上做NAT的时候最好可以适当地增加该值)</td>
</tr>
<tr>
<td><strong>tcp_tw_recycle</strong></td>
<td>0</td>
<td>1</td>
<td><strong>打开快速 TIME-WAIT sockets 回收</strong>。除非得到技术专家的建议或要求﹐请不要随意修改这个值。(做NAT的时候，建议打开它)</td>
</tr>
<tr>
<td><strong>tcp_tw_reuse</strong></td>
<td>0</td>
<td>1</td>
<td><strong>表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接</strong>(这个对快速重启动某些服务,而启动后提示端口已经被使用的情形非常有帮助)</td>
</tr>
<tr>
<td><strong>tcp_max_orphans</strong></td>
<td>8192</td>
<td>32768</td>
<td><strong>系统所能处理不属于任何进程的TCP sockets最大数量</strong>。假如超过这个数量﹐那么不属于任何进程的连接会被立即reset，并同时显示警告信息。之所以要设定这个限制﹐纯粹为了抵御那些简单的 DoS 攻击﹐千万不要依赖这个或是人为的降低这个限制。如果内存大更应该增加这个值。(这个值Redhat AS版本中设置为32768,但是很多防火墙修改的时候,建议该值修改为2000)</td>
</tr>
<tr>
<td><strong>tcp_abort_on_overflow</strong></td>
<td>0</td>
<td>0</td>
<td><strong>当守护进程太忙而不能接受新的连接，就象对方发送reset消息，默认值是false</strong>。这意味着当溢出的原因是因为一个偶然的猝发，那么连接将恢复状态。只有在你确信守护进程真的不能完成连接请求时才打开该选项，该选项会影响客户的使用。(对待已经满载的sendmail,apache这类服务的时候,这个可以很快让客户端终止连接,可以给予服务程序处理已有连接的缓冲机会,所以很多防火墙上推荐打开它)</td>
</tr>
<tr>
<td><strong>tcp_synookies</strong></td>
<td>0</td>
<td>1</td>
<td><strong>只有在内核编译时选择了CONFIG_SYNCOOKIES时才会发生作用</strong>。当出现syn等候队列出现溢出时象对方发送syncookies。目的是为了防止syn flood攻击。</td>
</tr>
<tr>
<td><strong>tcp_stdurg</strong></td>
<td>0</td>
<td>0</td>
<td><strong>使用 TCP urg pointer 字段中的主机请求解释功能</strong>。大部份的主机都使用老旧的 BSD解释，因此如果您在 Linux 打开它﹐或会导致不能和它们正确沟通。</td>
</tr>
<tr>
<td><strong>tcp_max_syn_backlog</strong></td>
<td>1024</td>
<td>16384</td>
<td><strong>对于那些依然还未获得客户端确认的连接请求﹐需要保存在队列中最大数目</strong>。对于超过 128Mb 内存的系统﹐默认值是 1024 ﹐低于 128Mb 的则为 128。如果服务器经常出现过载﹐可以尝试增加这个数字。警告﹗假如您将此值设为大于 1024﹐最好修改include/net/tcp.h里面的TCP_SYNQ_HSIZE﹐以保持TCP_SYNQ_HSIZE*16(SYN Flood攻击利用TCP协议散布握手的缺陷，伪造虚假源IP地址发送大量TCP-SYN半打开连接到目标系统，最终导致目标系统Socket队列资源耗尽而无法接受新的连接。为了应付这种攻击，现代Unix系统中普遍采用多连接队列处理的方式来缓冲(而不是解决)这种攻击，是用一个基本队列处理正常的完全连接应用(Connect()和Accept() )，是用另一个队列单独存放半打开连接。这种双队列处理方式和其他一些系统内核措施(例如Syn-Cookies/Caches)联合应用时，能够比较有效的缓解小规模的SYN Flood攻击(事实证明)</td>
</tr>
<tr>
<td><strong>tcp_window_scaling</strong></td>
<td>1</td>
<td>1</td>
<td><strong>该文件表示设置tcp/ip会话的滑动窗口大小是否可变</strong>。参数值为布尔值，为1时表示可变，为0时表示不可变。tcp/ip通常使用的窗口最大可达到 65535 字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp/ip滑动窗口大小增大数个数量级，从而提高数据传输的能力(RFC 1323)。（对普通地百M网络而言，关闭会降低开销，所以如果不是高速网络，可以考虑设置为0）</td>
</tr>
<tr>
<td><strong>tcp_timestamps</strong></td>
<td>1</td>
<td>1</td>
<td><strong>Timestamps 用在其它一些东西中﹐可以防范那些伪造的 sequence 号码</strong>。一条1G的宽带线路或许会重遇到带 out-of-line数值的旧sequence 号码(假如它是由于上次产生的)。Timestamp 会让它知道这是个 ‘旧封包’。(该文件表示是否启用以一种比超时重发更精确的方法（RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。)</td>
</tr>
<tr>
<td><strong>tcp_sack</strong></td>
<td>1</td>
<td>1</td>
<td><strong>使用 Selective ACK﹐它可以用来查找特定的遗失的数据报— 因此有助于快速恢复状态</strong>。该文件表示是否启用有选择的应答（Selective Acknowledgment），这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）。(对于广域网通信来说这个选项应该启用，但是这会增加对 CPU 的占用。)</td>
</tr>
<tr>
<td><strong>tcp_fack</strong></td>
<td>1</td>
<td>1</td>
<td><strong>打开FACK拥塞避免和快速重传功能</strong>。(注意，当tcp_sack设置为0的时候，这个值即使设置为1也无效)[<strong>这个是TCP连接靠谱的核心功能</strong>]</td>
</tr>
<tr>
<td><strong>tcp_dsack</strong></td>
<td>1</td>
<td>1</td>
<td><strong>允许TCP发送”两个完全相同”的SACK</strong>。</td>
</tr>
<tr>
<td><strong>tcp_ecn</strong></td>
<td>0</td>
<td>0</td>
<td><strong>TCP的直接拥塞通告功能</strong>。</td>
</tr>
<tr>
<td><strong>tcp_reordering</strong></td>
<td>3</td>
<td>6</td>
<td><strong>TCP流中重排序的数据报最大数量</strong>。 (一般有看到推荐把这个数值略微调整大一些,比如5)</td>
</tr>
<tr>
<td><strong>tcp_retans_collapse</strong></td>
<td>1</td>
<td>0</td>
<td><strong>对于某些有bug的打印机提供针对其bug的兼容性</strong>。(一般不需要这个支持,可以关闭它)</td>
</tr>
<tr>
<td><strong>tcp_wmem：mindefaultmax</strong></td>
<td>4096 16384 131072</td>
<td>8192 131072 16777216</td>
<td><strong>发送缓存设置</strong>。 <strong>min</strong>：为TCP socket预留用于发送缓冲的内存最小值。每个tcp socket都可以在建议以后都可以使用它。默认值为4096(4K)。 <strong>default</strong>：为TCP socket预留用于发送缓冲的内存数量，默认情况下该值会影响其它协议使用的net.core.wmem_default 值，一般要低于net.core.wmem_default的值。默认值为16384(16K)。 <strong>max</strong>: 用于TCP socket发送缓冲的内存最大值。该值不会影响net.core.wmem_max，”静态”选择参数SO_SNDBUF则不受该值影响。默认值为131072(128K)。（对于服务器而言，增加这个参数的值对于发送数据很有帮助,在我的网络环境中,修改为了51200 131072 204800）</td>
</tr>
<tr>
<td><strong>tcprmem：mindefaultmax</strong></td>
<td>4096 87380 174760</td>
<td>32768 131072 16777216</td>
<td><strong>接收缓存设置</strong>。同tcp_wmem</td>
</tr>
<tr>
<td><strong>tcp_mem：mindefaultmax</strong></td>
<td>根据内存计算</td>
<td>786432 1048576 1572864</td>
<td><strong>low</strong>：当TCP使用了低于该值的内存页面数时，TCP不会考虑释放内存。即低于此值没有内存压力。(理想情况下，这个值应与指定给 tcp_wmem 的第 2 个值相匹配 - 这第 2 个值表明，最大页面大小乘以最大并发请求数除以页大小 (131072 300 / 4096)。 ) <strong>pressure</strong>：当TCP使用了超过该值的内存页面数量时，TCP试图稳定其内存使用，进入pressure模式，当内存消耗低于low值时则退出pressure状态。(理想情况下这个值应该是 TCP 可以使用的总缓冲区大小的最大值 (204800 300 / 4096)。 ) <strong>high</strong>：允许所有tcp sockets用于排队缓冲数据报的页面量。(如果超过这个值，TCP 连接将被拒绝，这就是为什么不要令其过于保守 (512000 <em> 300 / 4096) 的原因了。 在这种情况下，提供的价值很大，它能处理很多连接，是所预期的 2.5 倍；或者使现有连接能够传输 2.5 倍的数据。 我的网络里为192000 300000 732000) <em>*一般情况下这些值是在系统启动时根据系统内存数量计算得到的</em></em>。</td>
</tr>
<tr>
<td><strong>tcp_app_win</strong></td>
<td>31</td>
<td>31</td>
<td><strong>保留max(window/2^tcp_app_win, mss)数量的窗口由于应用缓冲</strong>。当为0时表示不需要缓冲。</td>
</tr>
<tr>
<td><strong>tcp_adv_win_scale</strong></td>
<td>2</td>
<td>2</td>
<td><strong>计算缓冲开销</strong>。 bytes/2^tcp_adv_win_scale(如果tcp_adv_win_scale &gt; 0)或者bytes-bytes/2^(-tcp_adv_win_scale)(如果tcp_adv_win_scale BOOLEAN&gt;0)</td>
</tr>
<tr>
<td><strong>tcp_low_latency</strong></td>
<td>0</td>
<td>0</td>
<td><strong>允许 TCP/IP 栈适应在高吞吐量情况下低延时的情况；这个选项一般情形是的禁用</strong>。(但在构建Beowulf 集群的时候,打开它很有帮助)</td>
</tr>
<tr>
<td><strong>tcp_westwood</strong></td>
<td>0</td>
<td>0</td>
<td><strong>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化；对于 WAN 通信来说应该启用这个选项</strong>。</td>
</tr>
<tr>
<td><strong>tcp_bic</strong></td>
<td>0</td>
<td>0</td>
<td><strong>为快速长距离网络启用 Binary Increase Congestion</strong>；这样可以更好地利用以 GB 速度进行操作的链接；对于 WAN 通信应该启用这个选项。</td>
</tr>
<tr>
<td><strong>ip_forward</strong></td>
<td>0</td>
<td>1</td>
<td><strong>NAT必须开启IP转发支持，把该值写1</strong></td>
</tr>
<tr>
<td><strong>ip_local_port_range:minmax</strong></td>
<td>32768 61000</td>
<td>1024 65000</td>
<td><strong>表示用于向外连接的端口范围</strong>，默认比较小，这个范围同样会间接用于NAT表规模。</td>
</tr>
<tr>
<td><strong>ip_conntrack_max</strong></td>
<td>65535</td>
<td>65535</td>
<td><strong>系统支持的最大ipv4连接数，默认65536（事实上这也是理论最大值）</strong>，同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536</td>
</tr>
</tbody>
</table>
<h4 id="下列文件所在目录：-1"><a href="#下列文件所在目录：-1" class="headerlink" title="下列文件所在目录："></a>下列文件所在目录：</h4><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4<span class="meta-keyword">/netfilter/</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>建议值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ip_conntrack_max</strong></td>
<td>65535</td>
<td>65535</td>
<td><strong>系统支持的最大ipv4连接数，默认65536</strong>（事实上这也是理论最大值），同时这个值和你的内存大小有关，如果内存128M，这个值最大8192，1G以上内存这个值都是默认65536,这个值受/proc/sys/net/ipv4/ip_conntrack_max限制</td>
</tr>
<tr>
<td><strong>ip_conntrack_tcp_timeout_established</strong></td>
<td>432000</td>
<td>180</td>
<td><strong>已建立的tcp连接的超时时间，默认432000，也就是5天</strong>。影响：这个值过大将导致一些可能已经不用的连接常驻于内存中，占用大量链接资源，从而可能导致NAT ip_conntrack: table full的问题。建议：对于NAT负载相对本机的 NAT表大小很紧张的时候，可能需要考虑缩小这个值，以尽早清除连接，保证有可用的连接资源；如果不紧张，不必修改</td>
</tr>
<tr>
<td><strong>ip_conntrack_tcp_timeout_time_wait</strong></td>
<td>120</td>
<td>120</td>
<td><strong>time_wait状态超时时间，超过该时间就清除该连接</strong></td>
</tr>
<tr>
<td><strong>ip_conntrack_tcp_timeout_close_wait</strong></td>
<td>60</td>
<td>60</td>
<td><strong>close_wait状态超时时间，超过该时间就清除该连接</strong></td>
</tr>
<tr>
<td><strong>ip_conntrack_tcp_timeout_fin_wait</strong></td>
<td>120</td>
<td>120</td>
<td><strong>fin_wait状态超时时间，超过该时间就清除该连接</strong></td>
</tr>
</tbody>
</table>
<h4 id="下列文件所在目录：-2"><a href="#下列文件所在目录：-2" class="headerlink" title="下列文件所在目录："></a>下列文件所在目录：</h4><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>core/</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>建议值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>netdev_max_backlog</strong></td>
<td>1024</td>
<td>16384</td>
<td><strong>每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</strong>，对重负载服务器而言，该值需要调高一点。</td>
</tr>
<tr>
<td><strong>somaxconn</strong></td>
<td>128</td>
<td>16384**</td>
<td>用来限制监听(LISTEN)队列最大数据包的数量，超过这个数量就会导致链接超时或者触发重传机制**。web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。对繁忙的服务器,增加该值有助于网络性能</td>
</tr>
<tr>
<td><strong>wmem_default</strong></td>
<td>129024</td>
<td>129024</td>
<td><strong>默认的发送窗口大小</strong>（以字节为单位）</td>
</tr>
<tr>
<td><strong>rmem_default</strong></td>
<td>129024</td>
<td>129024</td>
<td><strong>默认的接收窗口大小</strong>（以字节为单位）</td>
</tr>
<tr>
<td><strong>rmem_max</strong></td>
<td>129024</td>
<td>873200</td>
<td><strong>最大的TCP数据接收缓冲</strong></td>
</tr>
<tr>
<td><strong>wmem_max</strong></td>
<td>129024</td>
<td>873200</td>
<td><strong>最大的TCP数据发送缓冲</strong></td>
</tr>
</tbody>
</table>
<h3 id="修改内核参数的方法"><a href="#修改内核参数的方法" class="headerlink" title="修改内核参数的方法"></a>修改内核参数的方法</h3><ol>
<li>使用 <code>echo value</code> 方式直接追加到文件中。 如 <code>echo &quot;1&quot; &gt; /proc/sys/net/ipv4/tcp_syn_retries</code> ，但是这种方式设备重启后，会恢复成默认值。</li>
<li>把参数添加到 <code>/etc/sysctl.conf</code> 中，然后执行 <code>sysctl -p</code> 使参数生效。这种方式是永久有效的。</li>
</ol>
<h3 id="生产环境常用的参数"><a href="#生产环境常用的参数" class="headerlink" title="生产环境常用的参数"></a>生产环境常用的参数</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_syn_retries</span> = <span class="number">1</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_synack_retries</span> = <span class="number">1</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_keepalive_time</span> = <span class="number">600</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_keepalive_probes</span> = <span class="number">3</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_keepalive_intvl</span> =<span class="number">15</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_retries2</span> = <span class="number">5</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_fin_timeout</span> = <span class="number">2</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_max_tw_buckets</span> = <span class="number">36000</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_tw_recycle</span> = <span class="number">1</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_tw_reuse</span> = <span class="number">1</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_max_orphans</span> = <span class="number">32768</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_syncookies</span> = <span class="number">1</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_max_syn_backlog</span> = <span class="number">16384</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_wmem</span> = <span class="number">8192</span> <span class="number">131072</span> <span class="number">16777216</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_rmem</span> = <span class="number">32768</span> <span class="number">131072</span> <span class="number">16777216</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_mem</span> = <span class="number">786432</span> <span class="number">1048576</span> <span class="number">1572864</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_local_port_range</span> = <span class="number">1024</span> <span class="number">65000</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.ip_conntrack_max</span> = <span class="number">65536</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.netfilter</span><span class="selector-class">.ip_conntrack_max</span>=<span class="number">65536</span></span><br><span class="line">net<span class="selector-class">.ipv4</span><span class="selector-class">.netfilter</span><span class="selector-class">.ip_conntrack_tcp_timeout_established</span>=<span class="number">180</span></span><br><span class="line">net<span class="selector-class">.core</span><span class="selector-class">.somaxconn</span> = <span class="number">16384</span></span><br><span class="line">net<span class="selector-class">.core</span><span class="selector-class">.netdev_max_backlog</span> = <span class="number">16384</span></span><br></pre></td></tr></table></figure>
<p>不同的生产环境需要优化的参数基本差不多，只是值有相应的变化。 具体的优化值要参考应用场景，这儿所列出的只是常用的优化参数，是否适合可以参考上面的参数说明描述。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><a href="http://www.sudops.com/linux-kernel-tcp-ip-sysctl-optimize.html" target="_blank" rel="external">sudops网站提供的优化例子</a>：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">net.core.netdev_max_backlog = <span class="number">400000</span></span><br><span class="line"><span class="meta">#该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span></span><br><span class="line"></span><br><span class="line">net.core.optmem_max = <span class="number">10000000</span></span><br><span class="line"><span class="meta">#该参数指定了每个套接字所允许的最大缓冲区的大小</span></span><br><span class="line"></span><br><span class="line">net.core.rmem_default = <span class="number">10000000</span></span><br><span class="line"><span class="meta">#指定了接收套接字缓冲区大小的缺省值（以字节为单位）。</span></span><br><span class="line"></span><br><span class="line">net.core.rmem_max = <span class="number">10000000</span></span><br><span class="line"><span class="meta">#指定了接收套接字缓冲区大小的最大值（以字节为单位）。</span></span><br><span class="line"></span><br><span class="line">net.core.somaxconn = <span class="number">100000</span></span><br><span class="line"><span class="meta">#Linux kernel参数，表示socket监听的backlog(监听队列)上限</span></span><br><span class="line"></span><br><span class="line">net.core.wmem_default = <span class="number">11059200</span></span><br><span class="line"><span class="meta">#定义默认的发送窗口大小；对于更大的 BDP 来说，这个大小也应该更大。</span></span><br><span class="line"></span><br><span class="line">net.core.wmem_max = <span class="number">11059200</span></span><br><span class="line"><span class="meta">#定义发送窗口的最大大小；对于更大的 BDP 来说，这个大小也应该更大。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.rp_filter = <span class="number">1</span></span><br><span class="line">net.ipv4.conf.<span class="keyword">default</span>.rp_filter = <span class="number">1</span></span><br><span class="line"><span class="meta">#严谨模式 1 (推荐)</span></span><br><span class="line"><span class="meta">#松散模式 0</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_congestion_control = bic</span><br><span class="line"><span class="meta">#默认推荐设置是 htcp</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_window_scaling = <span class="number">0</span></span><br><span class="line"><span class="meta">#关闭tcp_window_scaling</span></span><br><span class="line"><span class="meta">#启用 RFC 1323 定义的 window scaling；要支持超过 64KB 的窗口，必须启用该值。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_ecn = <span class="number">0</span></span><br><span class="line"><span class="meta">#把TCP的直接拥塞通告(tcp_ecn)关掉</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_sack = <span class="number">1</span></span><br><span class="line"><span class="meta">#关闭tcp_sack</span></span><br><span class="line"><span class="meta">#启用有选择的应答（Selective Acknowledgment），</span></span><br><span class="line"><span class="meta">#这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；</span></span><br><span class="line"><span class="meta">#（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">10000</span></span><br><span class="line"><span class="meta">#表示系统同时保持TIME_WAIT套接字的最大数量</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">8192</span></span><br><span class="line"><span class="meta">#表示SYN队列长度，默认1024，改成8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line"><span class="meta">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_timestamps = <span class="number">1</span></span><br><span class="line"><span class="meta">#开启TCP时间戳</span></span><br><span class="line"><span class="meta">#以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line"><span class="meta">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line"><span class="meta">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">10</span></span><br><span class="line"><span class="meta">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">1800</span></span><br><span class="line"><span class="meta">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为30分钟。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_probes = <span class="number">3</span></span><br><span class="line"><span class="meta">#如果对方不予应答，探测包的发送次数</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = <span class="number">15</span></span><br><span class="line"><span class="meta">#keepalive探测包的发送间隔</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_mem</span><br><span class="line"><span class="meta">#确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。</span></span><br><span class="line"><span class="meta">#第一个值是内存使用的下限。</span></span><br><span class="line"><span class="meta">#第二个值是内存压力模式开始对缓冲区使用应用压力的上限。</span></span><br><span class="line"><span class="meta">#第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_rmem</span><br><span class="line"><span class="meta">#与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_wmem = <span class="number">30000000</span> <span class="number">30000000</span> <span class="number">30000000</span></span><br><span class="line"><span class="meta">#为自动调优定义每个 socket 使用的内存。</span></span><br><span class="line"><span class="meta">#第一个值是为 socket 的发送缓冲区分配的最少字节数。</span></span><br><span class="line"><span class="meta">#第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。</span></span><br><span class="line"><span class="meta">#第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.ip_local_port_range = <span class="number">1024</span> <span class="number">65000</span></span><br><span class="line"><span class="meta">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_max=<span class="number">204800</span></span><br><span class="line"><span class="meta">#设置系统对最大跟踪的TCP连接数的限制</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = <span class="number">0</span></span><br><span class="line"><span class="meta">#关闭tcp的连接传输的慢启动，即先休止一段时间，再初始化拥塞窗口。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.route.gc_timeout = <span class="number">100</span></span><br><span class="line"><span class="meta">#路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syn_retries = <span class="number">1</span></span><br><span class="line"><span class="meta">#在内核放弃建立连接之前发送SYN包的数量。</span></span><br><span class="line"></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = <span class="number">1</span></span><br><span class="line"><span class="meta"># 避免放大攻击</span></span><br><span class="line"></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = <span class="number">1</span></span><br><span class="line"><span class="meta"># 开启恶意icmp错误消息保护</span></span><br><span class="line"></span><br><span class="line">net.inet.udp.checksum=<span class="number">1</span></span><br><span class="line"><span class="meta">#防止不正确的udp包的攻击</span></span><br><span class="line"></span><br><span class="line">net.ipv4.conf.<span class="keyword">default</span>.accept_source_route = <span class="number">0</span></span><br><span class="line"><span class="meta">#是否接受含有源路由信息的ip包。参数值为布尔值，1表示接受，0表示不接受。</span></span><br><span class="line"><span class="meta">#在充当网关的linux主机上缺省值为1，在一般的linux主机上缺省值为0。</span></span><br><span class="line"><span class="meta">#从安全性角度出发，建议你关闭该功能。</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CP命令不为人知的特殊使用]]></title>
      <url>http://tonydeng.github.io/2015/05/14/cp-usage/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/linux-command.jpg" alt="linux command"></p>
<p>就算如司空见惯的 <strong>cp</strong> 命令，某些用法我们或许也不了解。</p>
<a id="more"></a>
<h2 id="快速复制"><a href="#快速复制" class="headerlink" title="快速复制"></a>快速复制</h2><p>说是快速复制，实则只是少打几个字而已。该复制利用 <strong>Shell</strong> 的花括号展开特性。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp file&#123;1,2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="保留文件属性"><a href="#保留文件属性" class="headerlink" title="保留文件属性"></a>保留文件属性</h2><p>在复制时，可以保留源文件的时间戳、模式、所有权等属性。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp --preserve=timestamps file file1 <span class="comment"># 保留时间戳</span></span><br><span class="line">cp --preserve=mode file file1       <span class="comment"># 保留模式</span></span><br><span class="line">cp --preserve=ownership file file1  <span class="comment"># 保留所有权</span></span><br><span class="line">cp -p file file1                    <span class="comment"># 包括上述三者</span></span><br></pre></td></tr></table></figure>
<h2 id="创建软-硬链接"><a href="#创建软-硬链接" class="headerlink" title="创建软/硬链接"></a>创建软/硬链接</h2><p>在 <strong>Linux</strong> 下，创建软/硬链接本是 <strong>ln</strong> 的专职，但 <strong>cp</strong> 却可以代劳。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp <span class="_">-l</span> file file1 <span class="comment"># 创建硬链</span></span><br><span class="line">cp <span class="_">-s</span> file file1 <span class="comment"># 创建软链接</span></span><br></pre></td></tr></table></figure>
<h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><p>仅当源文件比目标文件更新时才复制。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp -u file1 file2</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OSX下编译Tengine+SSL错误的解决办法]]></title>
      <url>http://tonydeng.github.io/2015/03/09/tengine-ssl-osx-make-error/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/nginx-ssl.jpg" alt="Nginx+SSL"></p>
<p><a href="http://tengine.taobao.org/" target="_blank" rel="external">Tengine</a>（Tengine是由淘宝基于<a href="http://nginx.org/" target="_blank" rel="external">Nignx</a>开发的Web服务器）是一个非常要用的Web服务器，我基本上在测试及生产环境中都使用它来代替Nginx。不过之前都是在Linux下来编译和安装，这几天由于要调试之前已经离职的工程师的PHP项目，需要在自己的Mac配置一个可以使用的PHP开发调试环境。于是开始了OSX下的PHP+Nginx之旅。</p>
<a id="more"></a>
<p>由于我不太希望用<strong>brew</strong>来安装PHP和Tengine，还是使用最原始的编译安装的方式。安装PHP时基本上没有遇到任何问题，在安装Tengine时却碰到这样的错误。</p>
<p>原来的编译的参数</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="keyword">local</span>/tengine<span class="number">-2.1</span><span class="number">.0</span> --<span class="keyword">with</span>-http_ssl_module</span><br></pre></td></tr></table></figure>
<p>configure阶段没有任何问题，但是在进行make编译的时候，却报了下面的错误。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">src<span class="regexp">/core/</span>ngx_crypt.<span class="string">c:</span><span class="number">82</span>:<span class="number">5</span>: <span class="string">error:</span> <span class="string">'MD5_Init'</span> is <span class="string">deprecated:</span> first deprecated <span class="keyword">in</span> OS X <span class="number">10.7</span> [-Werror,-Wdeprecated-declarations]</span><br><span class="line">    ngx_md5_init(&amp;md5);</span><br><span class="line">    ^</span><br></pre></td></tr></table></figure>
<p>MD5的其他函数，比如<strong>MD5_Update</strong>,<strong>MD5_Final</strong>也在其中。</p>
<p>万能的google大神告知了错误的原因及解决方案，由于之前在编译参数中加入对ssl的支持，需要使用MD5算法，但是由于Nginx和OpenSSL的兼容性问题，某些api已经被建议废弃了，编译时不停的报警告并最终错误，无法编译完成。</p>
<p>其实解决办法也挺简单的，在编译时加上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">./configure --prefix=/usr/local/tengine-2.1.0 --with-http_ssl_module --with-cc-opt=&quot;-Wno-deprecated-declarations&quot;</span><br></pre></td></tr></table></figure></p>
<p>错误的原因及解决办法参见：</p>
<p><a href="http://trac.nginx.org/nginx/ticket/587" target="_blank" rel="external">http://trac.nginx.org/nginx/ticket/587</a></p>
<p><a href="https://www.ruby-forum.com/topic/2193556#1012378" target="_blank" rel="external">https://www.ruby-forum.com/topic/2193556#1012378</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Go项目的目录结构]]></title>
      <url>http://tonydeng.github.io/2015/02/10/golang-project-directory-structure/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/GoLangKulani.jpg" alt="Golang"></p>
<p>项目结构如何来组织，一般的开发语言都没有在语言层面上做规定，基本上都是在项目生命周期管理工具上对项目结构来做规定。不过Go在这方面做了相应地规定，这样可以在Go的开发者中保持一致。</p>
<a id="more"></a>
<h2 id="一、一个Go项目在GOPATH下，会有如下三个目录"><a href="#一、一个Go项目在GOPATH下，会有如下三个目录" class="headerlink" title="一、一个Go项目在GOPATH下，会有如下三个目录"></a>一、一个Go项目在GOPATH下，会有如下三个目录</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">./<span class="keyword">bin</span><br><span class="line"></span>./pkg</span><br><span class="line">./src</span><br></pre></td></tr></table></figure>
<p>其中，bin存放编译后的可执行文件；pkg存放编译后的包文件；src存放项目源文件。</p>
<p>一般，bin和pkg目录可以不创建，go命令会自动创建(如 <figure class="highlight go"><figcaption><span>install```)，只需要创建src目录即可。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">对于pkg目录，曾有人问：“我把Go中的包放入pkg下面，怎么不行啊？“，他时直接将Go包得源文件放入pkg中，这显然是不对的。pkg中的文件是Go编译生成的，而不是手动放进去的。（一般文件后缀名为<span class="string">``</span><span class="string">`.a`</span><span class="string">``</span>）。</span><br><span class="line"></span><br><span class="line">对于src目录，存放源文件，Go中的源文件以包（<span class="keyword">package</span>）的形式组织。通常，新建一个包就在src目录中新建一个文件夹。</span><br><span class="line"></span><br><span class="line">## 二、举例说明</span><br><span class="line"></span><br><span class="line">比如：我新建一个项目<span class="string">``</span><span class="string">`test`</span><span class="string">``</span>，开始的目录结构如下：</span><br></pre></td></tr></table></figure></p>
<p>test/<br>|– src/<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">为了编译方便，我在其中加入了一个<span class="keyword">install</span>文件，目录结构如下：</span><br></pre></td></tr></table></figure></p>
<p>test/<br>|– install<br>`– src/<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中install的内容如下：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span><br><span class="line"></span></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="_">-f</span> install ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'install must be run within its container folder'</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">CURDIR=`<span class="built_in">pwd</span>`</span><br><span class="line">OLDGOPATH=<span class="string">"<span class="variable">$GOPATH</span>"</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">"<span class="variable">$CURDIR</span>"</span></span><br><span class="line"></span><br><span class="line">gofmt -w src</span><br><span class="line"></span><br><span class="line">go install <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">"<span class="variable">$OLDGOPATH</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'finished'</span></span><br></pre></td></tr></table></figure></p>
<p>之所以加上这个install，而不用配置GOPATH（避免新增一个GO项目就要往GOPATH中添加一个路径）</p>
<p>接下来，增加一个包： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>test/<br>|– install<br><code>-- src/
    |-- config
    |</code>– config.go<br>    <code>-- test</code>– main.go<br><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">注意，<span class="keyword">config</span><span class="variable">.go</span>中的**<span class="keyword">package</span>**名称最好和目录**<span class="keyword">config</span>**一致，而文件名可以随意。main<span class="variable">.go</span>表示**main包**，文件名建议为**main<span class="variable">.go</span>**。（注：不一致时，生成的<span class="variable">.a</span>文件和目录名一致，这样，在<span class="keyword">import</span>时，应该是目录名，而引用包时，需要包名。例如：目录为myconfig，包名为<span class="keyword">config</span>，则生成的静态包文件是myconfig<span class="variable">.a</span>，引用该包:<span class="keyword">import</span> <span class="string">"myconfg"</span>,使用包中成员：<span class="keyword">config</span><span class="variable">.LoadConfig</span>()）</span><br><span class="line"></span><br><span class="line"><span class="keyword">config</span><span class="variable">.go</span>和main<span class="variable">.go</span>的代码如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">config</span><span class="variable">.go</span>代码：</span><br><span class="line"><span class="meta">```go</span></span><br><span class="line"><span class="keyword">package</span> <span class="keyword">config</span></span><br><span class="line">func LoadConfig()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main.go代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"config"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    config.LoadConfig()</span><br><span class="line">    fmt.Println(<span class="string">"Hello,GO!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，在项目根目录执行./install</p>
<p>这时候的目录结构如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">test</span><br><span class="line">|<span class="comment">-- bin</span></span><br><span class="line">|   `<span class="comment">-- test</span></span><br><span class="line">|<span class="comment">-- install</span></span><br><span class="line">|<span class="comment">-- pkg</span></span><br><span class="line">|   `<span class="comment">-- linux_amd64</span></span><br><span class="line">|       `<span class="comment">-- config.a</span></span><br><span class="line">`<span class="comment">-- src</span></span><br><span class="line">    |<span class="comment">-- config</span></span><br><span class="line">    |   `<span class="comment">-- config.go</span></span><br><span class="line">    `<span class="comment">-- test</span></span><br><span class="line">        `<span class="comment">-- main.go</span></span><br></pre></td></tr></table></figure>
<p>其中config.a是包config编译后生成的；bin/test是生成的可执行的二进制文件。</p>
<p>这是可以执行：bin/test。 输出结果为”Hello,GO!”</p>
<h2 id="三、补充说明"><a href="#三、补充说明" class="headerlink" title="三、补充说明"></a>三、补充说明</h2><p>1、 包可以有多层目录，比如net/http包，表示源文件再src/net/http目录下，不过源文件中的包名是最后一个目录的名字，比如http。 而在import包是，必须完整的路径，比如: immport “net/http”</p>
<p>2、有时候会见到local import(不建议使用)，语法类似这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./config"</span></span><br></pre></td></tr></table></figure>
<p>当代码有这样的语句是，很多时候都会见到类似的错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">local <span class="keyword">import</span> <span class="string">"./config"</span> in non-local <span class="keyword">package</span></span><br></pre></td></tr></table></figure>
<p>我所了解的这种导入方式的使用是：当写入一个简单地测试脚本，想要使用go run命令时，可以使用这种导入方式。</p>
<p>比如上面的例子，把test/main.go移到src目录中，test目录删除，修改main.go中的import “config”为import “./config”，然后可以在src目录下执行： go run main.go</p>
<p>可见，local import不依赖GOPATH</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于稳定]]></title>
      <url>http://tonydeng.github.io/2015/01/19/about-the-stability/</url>
      <content type="html"><![CDATA[<p>为什么大部分的人都喜欢稳定呢？</p>
<p>比如想要一份稳定的工作，考公务员，进国企，端铁饭碗。</p>
<p>稳定不是平衡，稳定也不是持久，稳定的科学定义是对<strong>外界干扰的抵抗能力</strong>。</p>
<p>换而言之，稳定不关乎状态的好坏，<strong>稳定只关乎是否能够保持原来的状态</strong>，哪怕这个状态并不是那么理想。</p>
<a id="more"></a>
<h3 id="我们来看看下面的三个小球。"><a href="#我们来看看下面的三个小球。" class="headerlink" title="我们来看看下面的三个小球。"></a>我们来看看下面的三个小球。</h3><p><img src="/images/blog/stability/tree_ball_1.jpg" alt="稳定的三个小球"></p>
<p>这三个小球是三种<strong>平衡</strong>的状态。</p>
<p>左边这个小球是“稳定”的，如果它被挪动一定距离，只要这段距离不是太远，它都能够恢复原状。</p>
<p>中间这个小球无所谓稳定不稳定，如果它被挪动一定距离，它可以在新的地方安居乐业。</p>
<p>右边这个小球是不稳定的，哪怕稍微轻轻的碰一下，它也会一路滑落，再也回不到最初的地方。</p>
<h3 id="为什么左边的小球稳定呢？"><a href="#为什么左边的小球稳定呢？" class="headerlink" title="为什么左边的小球稳定呢？"></a>为什么左边的小球稳定呢？</h3><p>因为它的能量最小。它所处在所有可能的位置中最低的那个位置，所以重力势能最小。一旦它被扰动，只可能被扰动到重力势能更高的地方，因为没有比它现在的位置重力势能更低的地方。这样，只要外界干扰一去除，在重力的作用下，小球就会自动回到原来的平衡位置，所以我们说它使最稳定的。它不需要任何外部能量，单靠自己的重力就能够保持再这个位置。</p>
<p>右边的小球是不稳定的，一点点风吹草动就能让它万劫不复。从左边到右边，它需要付出大量的努力才能达到现在的位置。为了保持这样的位置，它还必须要持续的输入外部能量来抵抗任何可能的扰动。换言之，它必须枕戈待旦，一直抗争不止，否则，就会从这个位置滑落。</p>
<h3 id="那这个和人们喜不喜欢稳定有什么关系呢？"><a href="#那这个和人们喜不喜欢稳定有什么关系呢？" class="headerlink" title="那这个和人们喜不喜欢稳定有什么关系呢？"></a>那这个和人们喜不喜欢稳定有什么关系呢？</h3><p>如果你觉得自己稳定，自己不需要任何努力就可以保持现在的位置，那是因为你就处在<strong>最小能量</strong>状态。你不努力，你也不会下落，也没有什么后果，那并不是因为你不会下落，只是因为你已经到了<strong>极低点</strong>。没错，我说的是<strong>极低点</strong>，而不是<strong>最低点</strong>。</p>
<p><img src="/images/blog/stability/two_ball_1.jpg" alt="two ball"></p>
<p><strong>所有动物生而平等，但有些动物比其他动物更平等</strong>。也许你的极低点，比很多人的极高点还要搞。也许你意识不到，<strong>你生来就有的，却有可能是别人苦苦追寻的</strong>。也许你会明白，<strong>你拼命追赶的，却也不过是别人的起点</strong>。</p>
<p>我不觉得<strong>向上爬</strong>就一定是好的，我更不觉得“人往高处走，水往低处流”这句话是有道理的。</p>
<p><strong>我只是觉得，这样的“稳定”无形中是一个牢笼，是一个束缚。哪怕你自己想出去看看，有时候也会被自己的重力压垮，自己又把自己拉回原来的位置。</strong></p>
<p><strong>“稳定”意味着失去了改变的可能性</strong>，不管这个改变是好的还是坏的。“稳定”有好处，因为它杜绝了变坏的可能；但是稳定也有坏处，因为它把变化的可能也一并屏蔽了。是利大于弊，还是弊大于利，需要你自己掂量。</p>
<p>我个人觉得，人生的路那么宽，又有那么多的可能，有意或无意的把自己束缚在“稳定”的这一洼盆地里，或多或少有坐井观天之嫌。多走走，多看看，扯起风帆去看看真正的大海，哪怕需要多付出很多的力气，哪怕有遇到风暴的可能，也胜过舒服的躺在“稳定”的避风港里。</p>
<p><img src="/images/blog/stability/one_ball_1.jpg" alt="image"></p>
<p>当有一天，你克服了“稳定”的枷锁，克服了自己的懒惰和惯性，一番苦战之后，终于站在不稳定的极高点。你也许会觉得，剩下的人生就是一片坦途了。</p>
<p>但是人生不是二维的，你要面临的问题太多太多了。</p>
<p><img src="/images/blog/stability/one_ball_2.jpg" alt="image"></p>
<p>也许，你会发现，一个方向的峰顶，只不过是另一个方向的谷底。前面的路还有太长太长。</p>
<p><img src="/images/blog/stability/one_ball_3.jpg" alt="image"></p>
<p>终于有一天，你回发现，原来生活是这样的。起起伏伏，曲曲折折，又是陷入谷底，有时又柳暗花明。</p>
<p>知道了生活的现实，却依然愿意走出“稳定”的小绿洲，踏上那荆棘满地却又风景如画的路途，我觉得这才是真正的勇敢和乐观。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用HTML5的应用缓存]]></title>
      <url>http://tonydeng.github.io/2015/01/13/using-html5-application-cache/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/manifest.png" alt="manifest"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> <a href="https://html5.org/" target="_blank" rel="external">HTML5</a> 提供一种 <strong>应用缓存</strong> 机制，使得基于web的应用程序可以离线运行。开发者可以使用 Application Cache (AppCache) 接口设定浏览器缓存的数据并使得数据离线有效。 在处于离线状态时，即使用户点击刷新按钮，应用也能正常加载与工作。</p>
<p>使用应用缓存可以得到以下益处：</p>
<ul>
<li>离线浏览: 用户可以在离线状态下浏览网站内容。</li>
<li>更快的速度: 因为数据被存储在本地，所以速度会更快.</li>
<li>减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。</li>
</ul>
<a id="more"></a>
<h1 id="应用缓存如何工作"><a href="#应用缓存如何工作" class="headerlink" title="应用缓存如何工作"></a>应用缓存如何工作</h1><h2 id="开启应用缓存"><a href="#开启应用缓存" class="headerlink" title="开启应用缓存"></a>开启应用缓存</h2><p>若想为应用开启应用缓存，你需要在应用页面中的 <html> 元素上增加 manifest 特性，请看下面的例子：</html></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"example.appcache"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>manifest 特性与 <strong>缓存清单(cache manifest)</strong> 文件关联，这个文件包含了浏览器<strong>需要为你的应用缓存的资源(文件)列表</strong>。</p>
<p>你应当在每一个意图缓存的页面上添加 <strong>manifest</strong> 特性。浏览器不会缓存不带有<strong>manifest</strong> 特性的页面，除非这个页面已经被写在清单文件内的列表里了。你没有必要添加所有你意图缓存的页面的清单文件，浏览器会将用户访问过的并带有 manifest 特性的所有页面添加进应用缓存中。</p>
<h2 id="加载文档"><a href="#加载文档" class="headerlink" title="加载文档"></a>加载文档</h2><p>使用了应用缓存机制以后加载文档的顺序是这样的：</p>
<ul>
<li>如果应用缓存存在，浏览器直接从缓存中加载文档与相关资源，不会访问网络。这会提升文档加载速度。</li>
<li>浏览器检查清单文件列出的资源是否在服务器上被修改。</li>
<li>如果清单文件被更新了, 浏览器会下载新的清单文件和相关的资源。 这都是在后台执行的，基本不会影响到webapp的性能。</li>
</ul>
<p>下面详细描述了加载文档与更新应用缓存的流程：</p>
<ol>
<li>当浏览器访问一个包含 manifest 特性的文档时，如果应用缓存不存在，浏览器会加载文档，然后获取所有在清单文件中列出的文件，生成应用缓存的第一个版本。</li>
<li>对该文档的后续访问会使浏览器直接从应用缓存(而不是服务器)中加载文档与其他在清单文件中列出的资源。此外，浏览器还会向 window.applicationCache 对象发送一个 checking 事件，在遵循合适的 HTTP 缓存规则前提下，获取清单文件。</li>
<li>如果当前缓存的清单副本是最新的，浏览器将向 applicationCache 对象发送一个 noupdate 事件，到此，更新过程结束。注意，如果你在服务器修改了任何缓存资源，同时也应该修改清单文件，这样浏览器才能知道它需要重新获取资源。</li>
<li>如果清单文件已经改变，文件中列出的所有文件—也包括通过调用 applicationCache.add() 方法添加到缓存中的那些文件—会被获取并放到一个临时缓存中，遵循适当的 HTTP 缓存规则。对于每个加入到临时缓存中的文件，浏览器会向 applicationCache 对象发送一个 progress 事件。如果出现任何错误，浏览器会发送一个 error 事件，并暂停更新。</li>
<li>一旦所有文件都获取成功，它们会自动移送到真正的离线缓存中，并向  applicationCache 对象发送一个 cached 事件。鉴于文档早已经被从缓存加载到浏览器中，所以更新后的文档不会重新渲染，直到页面重新加载(可以手动或通过程序).</li>
</ol>
<h1 id="存储位置与清除离线缓存"><a href="#存储位置与清除离线缓存" class="headerlink" title="存储位置与清除离线缓存"></a>存储位置与清除离线缓存</h1><p>在 Chrome 中，你可以在设置中选择 「清除浏览器数据…」 或访问 <a href="chrome://appcache-internals" target="_blank" rel="external">chrome://appcache-internals</a> 来清除缓存。</p>
<p>Safari 在设置中有一个类似的”清空缓存” 选项，但是需要重启浏览器后才能生效。</p>
<p>在 Firefox 中，离线缓存数据与 Firefox 配置文件是分开存储的—紧挨着硬盘缓存：</p>
<ul>
<li>Windows Vista/7: C:\Users\<username>\AppData\Local\Mozilla\Firefox\Profiles\<salt>.<profile name="">\OfflineCache</profile></salt></username></li>
<li>Mac/Linux: /Users/<username>/Library/Caches/Firefox/Profiles/<salt>.<profile name="">/OfflineCache</profile></salt></username></li>
</ul>
<p>应用缓存可以变成废弃的。如果从服务器上移除一个应用的清单文件，浏览器将会清除所有清单中列出的应用缓存，并向 applicationCache 对象发送一个「obsolete」事件。这将使得应用缓存的状态变为 OBSOLETE。</p>
<h1 id="缓存清单文件"><a href="#缓存清单文件" class="headerlink" title="缓存清单文件"></a>缓存清单文件</h1><h2 id="引用一个缓存清单文件"><a href="#引用一个缓存清单文件" class="headerlink" title="引用一个缓存清单文件"></a>引用一个缓存清单文件</h2><p>web 应用中的 manifest 特性可以指定为缓存清单文件的相对路径或一个绝对 URL(绝对 URL 必须与应用同源)。缓存清单文件可以使用任意扩展名，但传输它的 MIME 类型必须为 text/cache-manifest。</p>
<p>Apache配置对manifest支持，在根目录或应用的同级目录下的<strong>.htaccess</strong>中加入下面的配置</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">AddType <span class="built_in">text</span>/cache-manifest .appcache</span><br></pre></td></tr></table></figure>
<p>Nginx配置对manifest支持，在<strong>conf/mime.types</strong>中加入下面的配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">text/<span class="keyword">cache</span>-manifest                  appcache manifest;</span><br></pre></td></tr></table></figure>
<h2 id="缓存清单文件中的记录"><a href="#缓存清单文件中的记录" class="headerlink" title="缓存清单文件中的记录"></a>缓存清单文件中的记录</h2><p>缓存清单文件是一个纯文本文件，它列出了所有浏览器应该缓存起来的资源，以便能够离线访问。资源使用 URI 来标识。在缓存清单文件中列出的所有记录必须拥有相同的协议、主机名与端口号。</p>
<h1 id="示例-1：一个简单的缓存清单文件"><a href="#示例-1：一个简单的缓存清单文件" class="headerlink" title="示例 1：一个简单的缓存清单文件"></a>示例 1：一个简单的缓存清单文件</h1><p>下面是一个简单的缓存清单文件，example.appcache，适用于一个虚拟的网站 www.example.com。</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="meta"># v1 - 2011-08-13</span></span><br><span class="line"><span class="meta"># This is a comment.</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.example.com/index.html</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.example.com/header.png</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//www.example.com/blah/blah</span></span><br></pre></td></tr></table></figure>
<p>一个缓存清单文件可以包含三段内容 (CACHE， NETWORK， 和 FALLBACK， 下面详细讨论)。 在上面的例子中，没有段落标题，因此所有数据行都认为是属于显式 (CACHE) 段落，这意味着浏览器应该在应用缓存中缓存所有列出的资源。资源可以使用绝对或者相对 URL 来指定(例如 index.html)。</p>
<p>上面例子中的注释 「v1」很有必要存在。只有当清单文件发生变化时，浏览器才会去更新应用缓存。如果你要更改缓存资源(比如说，你使用了一张新的 header.png 图片)，你必须同时修改清单文件中的内容，以便让浏览器知道它们需要更新缓存。你可以对清单文件做任何改动，但大家都认同的最佳实践则是修正版本号。</p>
<blockquote>
<p>重要：不要在清单文件中指定清单文件本身，否则将无法让浏览器得知清单文件有新版本出现。</p>
</blockquote>
<h2 id="缓存清单文件中的段落：-CACHE，-NETWORK，与-FALLBACK"><a href="#缓存清单文件中的段落：-CACHE，-NETWORK，与-FALLBACK" class="headerlink" title="缓存清单文件中的段落： CACHE， NETWORK，与 FALLBACK"></a>缓存清单文件中的段落： CACHE， NETWORK，与 FALLBACK</h2><p>清单文件可以分为三段： CACHE， NETWORK，与 FALLBACK.</p>
<p><strong>CACHE:</strong><br>    这是缓存文件中记录所属的默认段落。在 CACHE: 段落标题后(或直接跟在 CACHE MANIFEST 行后)列出的文件会在它们第一次下载完毕后缓存起来。</p>
<p><strong>NETWORK:</strong><br>    在 NETWORK: 段落标题下列出的文件是需要与服务器连接的白名单资源。所有类似资源的请求都会绕过缓存，即使用户处于离线状态。可以使用通配符。</p>
<p><strong>FALLBACK:</strong><br>    FALLBACK: 段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。</p>
<p>CACHE， NETWORK， 和 FALLBACK 段落可以以任意顺序出现在缓存清单文件中，并且每个段落可以在同一清单文件中出现多次。</p>
<h1 id="示例-2：-一个复杂且完整的缓存清单文件"><a href="#示例-2：-一个复杂且完整的缓存清单文件" class="headerlink" title="示例 2： 一个复杂且完整的缓存清单文件"></a>示例 2： 一个复杂且完整的缓存清单文件</h1><p>下面是一个更加完整的缓存清单文件，适用于一个虚拟的网站 www.example.com：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="meta"># v1 2011-08-14</span></span><br><span class="line"><span class="meta"># This is another comment</span></span><br><span class="line">index.html</span><br><span class="line">cache.html</span><br><span class="line">style.css</span><br><span class="line">image1.png</span><br><span class="line"></span><br><span class="line"><span class="meta"># Use from network if available</span></span><br><span class="line">NETWORK:</span><br><span class="line">network.html</span><br><span class="line"></span><br><span class="line"><span class="meta"># Fallback content</span></span><br><span class="line">FALLBACK:</span><br><span class="line">/ fallback.html</span><br></pre></td></tr></table></figure>
<p>该例子使用了 NETWORK 与 FALLBACK 段落，指明了 network.html 页面必须始终从网络获取，fallback.html 页面应该作为后备资源来提供(例如，当无法与服务器建立连接时)。</p>
<h2 id="缓存清单文件的结构"><a href="#缓存清单文件的结构" class="headerlink" title="缓存清单文件的结构"></a>缓存清单文件的结构</h2><p>缓存清单文件必须以 <strong>text/cache-manifest</strong> MIME 类型来传输。所有通过 MIME 类型传输的文件必须符合本节中定义的适用于应用缓存清单的语法。</p>
<p>缓存清单是 UTF-8 格式的文本文件，有可能包含一个 BOM 字符。新行可能使用换行符(U+000A)，回车(U+000D)，或回车加换行符来表示。</p>
<p>缓存清单文件的第一行必须包含字符串 CACHE MANIFEST (两个单词间使用一个 U+0020 空白)，紧接着是零或多个空白或制表符。本行的其他文本会被忽略。</p>
<p>缓存清单文件的余下内容必须包含零或多个下面的行：</p>
<p><strong>空行</strong><br>    你可以使用包含零或多个空白与制表符的空行。</p>
<p><strong>注释</strong><br>    注释包括零或多个制表符或空白字符，紧接着是一个 # 字符，再然后是零或多个注释文本字符。注释只能在所在行起作用，不能追加到其他行上。这意味着你无法使用片段标识符。</p>
<p><strong>段落标题</strong><br>    段落标题指定了缓存文件即将操作的段落。有三个可选的标题：</p>
<pre><code>CACHE:         切换到缓存清单的显式段落(默认段落)。
NETWORK:     切换到缓存清单的在线白名单段落。
FALLBACK:     切换到缓存清单的后备资源段落。
</code></pre><p>缓存清单可以在段落内任意切换(每个段落标题可以使用多次)，而且段落允许为空。</p>
<h1 id="一个应用缓存中的资源"><a href="#一个应用缓存中的资源" class="headerlink" title="一个应用缓存中的资源"></a>一个应用缓存中的资源</h1><p>一个应用缓存至少会包含一个资源，由 URI 指定。所有资源都属于下列类别之一：</p>
<p><strong>主记录</strong><br>    这些资源被加入缓存的原因是：用户浏览的一个上下文中包含一个文档，该文档用 manifest 特性明确指明了它属于该缓存。</p>
<p><strong>显式记录</strong><br>    这些是在应用缓存清单文件中显式列出的资源。</p>
<p><strong>网络记录</strong><br>    这些是在应用缓存清单文件中作为网络记录列出的资源。</p>
<p><strong>后备记录</strong><br>    这些是在应用缓存清单文件中作为后备记录列出的资源。</p>
<h2 id="主记录"><a href="#主记录" class="headerlink" title="主记录"></a>主记录</h2><p>任意在 <html> 元素上包含一个 manifest 特性的 HTML 文件都可以是主记录。例如，我们拥有 HTML 文件 <a href="http://www.example.com/entry.html" target="_blank" rel="external">http://www.example.com/entry.html</a> ，它看起来是这样的：</html></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"example.appcache"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Application Cache Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果 entry.html 没有在 example.appcache 缓存清单文件中列出来，那么访问 entry.html 页面会使得 entry.html 作为一条主记录加入到应用缓存中。</p>
<h2 id="显式记录"><a href="#显式记录" class="headerlink" title="显式记录"></a>显式记录</h2><p>显式记录就是在缓存清单文件的 CACHE 段落显式列出的资源。</p>
<h2 id="网络记录"><a href="#网络记录" class="headerlink" title="网络记录"></a>网络记录</h2><p>缓存清单文件的 NETWORK 段落指定了 web 应用需要在线访问的资源。一个应用缓存中的网络记录本质上来说是一个「在线白名单」—在 NETWORK 段落指定的 URI 会从服务器而不是缓存加载。这使得浏览器的安全模型通过限制用户让其只访问经过验证的资源来避免潜在的安全漏洞。</p>
<p>举例来说，你可以使用网络记录来从服务器而不是缓存中加载并执行脚本或其他代码：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="symbol">NETWORK:</span></span><br><span class="line">/api</span><br></pre></td></tr></table></figure>
<p>上面列出的缓存清单段落能够保证对 <a href="http://www.example.com/api/" target="_blank" rel="external">http://www.example.com/api/</a> 子目录中资源的请求始终通过网络加载，而不会去访问缓存。</p>
<blockquote>
<p>注意： 简单的从清单文件中过滤主记录(在 html 元素中拥有 manifest 特性的文件)并不会产生同样的结果，因为主记录会被添加到—后续访问的获取也会从—应用缓存中。</p>
</blockquote>
<h2 id="后备记录"><a href="#后备记录" class="headerlink" title="后备记录"></a>后备记录</h2><p>当尝试请求资源失败时会使用后备记录。例如，缓存清单文件 <a href="http://www.example.com/example.appcache" target="_blank" rel="external">http://www.example.com/example.appcache</a> 包含如下内容：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"><span class="symbol">FALLBACK:</span></span><br><span class="line">example<span class="meta-keyword">/bar/</span> example.html</span><br></pre></td></tr></table></figure>
<p>任何访问 <a href="http://www.example.com/example/bar/" target="_blank" rel="external">http://www.example.com/example/bar/</a> 或它的任意子目录及内容都会使浏览器发出请求，去尝试加载请求的资源。如果尝试失败(可能是由于网络连接失败或服务器问题)，浏览器将会加载 example.html。</p>
<h1 id="缓存状态"><a href="#缓存状态" class="headerlink" title="缓存状态"></a>缓存状态</h1><p>每个应用缓存都有一个状态，标示着缓存的当前状况。共享同一清单 URI 的缓存拥有相同的缓存状态，可能是其中之一：</p>
<p><strong>UNCACHED(未缓存)</strong><br>    一个特殊的值，用于表明一个应用缓存对象还没有完全初始化。</p>
<p><strong>IDLE(空闲)</strong><br>    应用缓存此时未处于更新过程中。</p>
<p><strong>CHECKING(检查)</strong><br>    清单已经获取完毕并检查更新。</p>
<p><strong>DOWNLOADING(下载中)</strong><br>    下载资源并准备加入到缓存中，这是由于清单变化引起的。</p>
<p><strong>UPDATEREADY(更新就绪)</strong><br>    一个新版本的应用缓存可以使用。有一个对应的事件 updateready，当下载完毕一个更新，并且还未使用 swapCache() 方法激活更新时，该事件触发，而不会是 cached 事件。</p>
<p><strong>OBSOLETE(废弃)</strong><br>    应用缓存现在被废弃。</p>
<h1 id="测试缓存清单的更新"><a href="#测试缓存清单的更新" class="headerlink" title="测试缓存清单的更新"></a>测试缓存清单的更新</h1><p>你可以使用 JavaScript 来写程序检测应用是否拥有一个可以更新的缓存清单文件。因为缓存清单文件可能会在脚本添加事件前完成更新，所以脚本应该始终检测 <code>window.applicationCache.status</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onUpdateReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'found new version!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.applicationCache.addEventListener(<span class="string">'updateready'</span>, onUpdateReady);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.applicationCache.status === <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">  onUpdateReady();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 若要手动测试一个新的清单文件，你可以使用 <code>window.applicationCache.update()</code> 。</p>
<h1 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h1><ul>
<li><p>永远不要使用传统 GET 参数(例如 <code>other-cached-page.html?parameterName=value</code>) 来访问缓存文件。这会使浏览器绕过缓存，直接从网络获取。若想链接一个参数需要在 JavaScript 中解析的资源，你可以将参数放到链接的 hash 部分，例如 <code>other-cached-page.html#whatever?parameterName=value</code> 。</p>
</li>
<li><p>当应用被缓存后，仅仅更新在 web 页面中使用的资源(文件)还不足以更新被缓存的文件。你需要在浏览器获取和使用更新的文件前，去更新缓存清单文件本身。你可以使用 <code>window.applicationCache.swapCache()</code> 以编程的方式完成上述目的，虽然这无法影响到已经加载完毕的资源。为了保证资源从应用缓存的最新版本中加载，最理想的办法就是刷新页面。</p>
</li>
<li><p>通过在 web 服务器上设置 <code>expires header</code> 来使 <code>*.appcache</code> 文件立即过期是个好主意。这避免了将清单文件缓存的风险。例如，在 Apache 中，你可以指定下面的配置项：</p>
</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">ExpiresByType <span class="built_in">text</span>/cache-manifest <span class="string">"access plus 0 seconds"</span></span><br></pre></td></tr></table></figure>
<h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul>
<li><a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/" target="_blank" rel="external">HTML5Rocks - A Beginner’s Guide to Using the Application Cache</a></li>
<li><a href="http://appcachefacts.info/" target="_blank" rel="external">appcachefacts.info</a> - detailed information on AppCache idiosyncrasies</li>
<li><a href="http://hacks.mozilla.org/2010/01/offline-web-applications/" target="_blank" rel="external">offline web applications</a> at hacks.mozilla.org - showcases an offline app demo and explains how it works.</li>
<li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#offline" target="_blank" rel="external">HTML 5 working draft: Offline web applications</a></li>
<li><a href="http://developer.teradata.com/blog/js186040/2011/11/html5-cache-manifest-an-off-label-usage" target="_blank" rel="external">HTML5 Cache Manifest: An Off-label Usage</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCache" target="_blank" rel="external">nsIApplicationCache</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheNamespace" target="_blank" rel="external">nsIApplicationCacheNamespace</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheContainer" target="_blank" rel="external">nsIApplicationCacheContainer</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheChannel" target="_blank" rel="external">nsIApplicationCacheChannel</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIApplicationCacheService" target="_blank" rel="external">nsIApplicationCacheService</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/XPCOM_Interface_Reference/nsIDOMOfflineResourceList" target="_blank" rel="external">nsIDOMOfflineResourceList</a></li>
<li><a href="http://www.ibm.com/developerworks/web/library/wa-ffox3/" target="_blank" rel="external">Get ready for Firefox 3.0 - A Web developer’s guide to the many new features in this popular browser, especially the offline application features</a> (IBM developerWorks)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你是咸鱼吗？]]></title>
      <url>http://tonydeng.github.io/2015/01/13/are-you-a-salted-fish/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/salted_fish.jpg" alt="咸鱼"></p>
<p>我在05年的时候，写了一篇《你是咸鱼吗？》的Blog，转眼十年过去了。回头看看这十年来走过的路程，虽然有些弯弯绕绕、曲曲折折，但是很欣慰的是，我还记得当初的梦想，我没有变成咸鱼。</p>
<a id="more"></a>
<p>下面是我05年写得blog，整理并转载一下。</p>
<p>时间过的真快啊！过了今天，我来北京就整整三年了！</p>
<p>“做人如果没梦想，那跟咸鱼有什么分别？”，这句话是周星星同学在《少林足球》中的经典明言，还好现在的我还没有放弃我的理想和追求，还没有变成“咸鱼”！</p>
<p>希望能够用下文来激励自己不要忘记自己最初的梦想！</p>
<pre><code>我劝你呀，脚踏实地地做人吧，这里有一份洗厕所的工作你先做着，你就别做梦了。

做人如果没梦想，那跟咸鱼有什么分别啊？

你连鞋都没有，那不就是咸鱼一条啦，学人家讲理想。

话不能这么讲，我心中的一团火是不会熄地。
</code></pre><p>当我看到这里的时候，心里禁不住颤抖了一下。这段话是周星星同学在《少林足球》里对大师兄说的一段话。</p>
<p>个人最喜欢的周星星的三部影片分别是《大话西游》，《喜剧之王》以及这部《少林足球》。如果说《大话西游》是以一种荒诞的形式表达了个人梦想与个人情感之间的冲突，爱情与道义之不能两全的命题。《喜剧之王》描述的是一个处于社会底层的人追求自己的理想和爱情而奋斗不息的故事。而《少林足球》说的是这样一个处于底层的群体坚持自己的信念，为了自己的理想奋力拼搏并最终获得成功的故事。</p>
<p>当我第一次看这部影片的时候，带给我的是笑声，当我第二次看的时候，带给我了思考，但我今夜再看的时候，带给了我泪水。</p>
<p>也许我们每个人心里都有一个梦，梦想对我们来说，有时候是那么的真切，有时候是那么的遥远。世上有几个人又能梦想成真呢？当现实和自己的理想冲突的时候，我们是坚持自己的信念还是做一条没有梦想的咸鱼？</p>
<p>人生的路很曲折，也很反复。当昔日高高在上，不可一世的“黄金右脚”沦落到替他人擦鞋。当昔日的轻功高手现在却拿不到放到头顶的一圈纸。当嘴里说着“奔驰被人开走了，一分钟几十万的业务”的三师兄躲在小店里吃小面的时候。我看到了人生无常，人生悲哀。但是这世界上多少的人是这样活着的？</p>
<p>人与咸鱼的区别，起码有一点就是人是有梦想的，而咸鱼没有。《少林足球》里的足球，其实只是一个具体的符号。这个足球和我们踢的足球是没有关系的。这个符号其实是一个通用的东西，在每个人心里的足球都是不一样的。你的足球又是什么?</p>
<p>周星星拍《喜剧之王》的时候，是他感情有折的时候，拍《少林足球》是他事业受挫的时期。不同心情拍出的影片就会有不同的感受。但是有一点，都是对情感理想的不屈追求。所以才会引起大众的共鸣，拨动普通人的心弦。</p>
<p>如果有一天，失败降临在你我身上。在最万分无助的时候，想想他在片中对阿梅那样说的“要有自信，你是最好的”，是的，我们是最好的。</p>
<pre><code>不坠那青云之志！梦想就是心里的那团火！
</code></pre><p>朋友，你还记得自己最初的梦想吗？不要变成“咸鱼”哦！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle依赖范围介绍]]></title>
      <url>http://tonydeng.github.io/2015/01/12/gradle-dependency-scope/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/gradle.png" alt="Gradle Logo"></p>
<p>自从Google推出Android的集成开发环境（IDE）– <a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="external">Android Studio</a>，默认集成了<a href="http://www.gradle.org" target="_blank" rel="external">Gradle</a>来进行对Android项目生命周期的管理。那我们也需要从原来的Ant转成Gradle。</p>
<p>对于开发工程师来说，像Gradle这样的工具，第一体验是对依赖的管理。团队里面有不少原来是使用<a href="http://maven.apache.org" target="_blank" rel="external">Maven</a>的同学，会有这样的问题：“maven的依赖管理除了最基本的坐标体系（groupId、artifactId、version、packaging）以外，还有一个scope的概念。那作为继承了maven的依赖体系的gradle，它的依赖范围又有哪些？”</p>
<a id="more"></a>
<h3 id="那我们来看看Gradle的依赖范围（dependent-scope到底有哪些）。"><a href="#那我们来看看Gradle的依赖范围（dependent-scope到底有哪些）。" class="headerlink" title="那我们来看看Gradle的依赖范围（dependent scope到底有哪些）。"></a>那我们来看看Gradle的依赖范围（dependent scope到底有哪些）。</h3><h4 id="war插件使用的依赖范围"><a href="#war插件使用的依赖范围" class="headerlink" title="war插件使用的依赖范围"></a>war插件使用的依赖范围</h4><ul>
<li><p>providedCompile</p>
<pre><code>war插件提供的范围类型:与compile作用类似,但不会被添加到最终的war包中这是由于编译、测试阶段代码需要依赖此类jar包，而运行阶段容器已经提供了相应的支持，所以无需将这些文件打入到war包中了;例如Servlet API就是一个很明显的例子.
</code></pre></li>
<li><p>providedRuntime</p>
<pre><code>同providedCompile类似，也是war插件提供的范围类型。它的范围和jar插件的runtime基本一样，。
</code></pre></li>
</ul>
<p>相关说明可以看看Gradle官方文档的<a href="http://www.gradle.org/docs/current/userguide/war_plugin.html#N131A1" target="_blank" rel="external">第26章第4节 The War Plugin</a></p>
<h4 id="java插件使用的依赖范围"><a href="#java插件使用的依赖范围" class="headerlink" title="java插件使用的依赖范围"></a>java插件使用的依赖范围</h4><ul>
<li><p>compile</p>
<pre><code>编译范围依赖在所有的classpath中可用，同时它们也会被打包。
</code></pre></li>
<li><p>runtime</p>
<pre><code>runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。
</code></pre></li>
<li><p>testCompile</p>
<pre><code>测试期编译需要的附加依赖
</code></pre></li>
<li><p>testRuntime</p>
<pre><code>测试期编译需要的附加依赖
</code></pre></li>
<li><p>archives</p>
<pre><code>项目构件时会使用的依赖范围
</code></pre></li>
<li><p>default</p>
<pre><code>配置默认依赖范围，用在这个项目上一个项目依赖的默认配置。包含本项目在运行时所需的构件和依赖。
</code></pre></li>
</ul>
<p>相关说明可以查看Gradle官方文档的<a href="http://www.gradle.org/docs/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management" target="_blank" rel="external">第23章第5节 The Java Plugin</a></p>
<p>其他插件的依赖范围基本上也就是这两个插件的子集了，了解了上述的依赖范围也就等于了解Gradle所有的依赖范围了。</p>
<h3 id="Gradle的依赖范围与Tasks之间的关系"><a href="#Gradle的依赖范围与Tasks之间的关系" class="headerlink" title="Gradle的依赖范围与Tasks之间的关系"></a>Gradle的依赖范围与Tasks之间的关系</h3><p><img src="/images/blog/javaPluginConfigurations.png" alt="依赖范围与Gradle Tasks之间的关系"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端解耦原则]]></title>
      <url>http://tonydeng.github.io/2015/01/05/frontend-decoupling-principle/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/decoupling.png" alt="解耦"></p>
<h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><p>当你能够做到修改一个组件而不需要更改其他组件时，就做到了松耦合，松耦合对于代码可维护性来说是至关重要的。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>不要使用 css 表达式。（这种方式应该已经废弃了）</li>
<li>javascript 和 css 之间只通过 className 进行通信。</li>
<li>不要使用 html 的 on 属性，如：onclick。应该使用 id 保持 javascript 和 html 的沟通。</li>
<li>使用模板。</li>
</ul>
<a id="more"></a>
<h2 id="将-javascript-从-css-中抽离"><a href="#将-javascript-从-css-中抽离" class="headerlink" title="将 javascript 从 css 中抽离"></a>将 <strong>javascript</strong> 从 <strong>css</strong> 中抽离</h2><p>在 ie8 和更早版本的浏览器中有一个特性，即 <strong>css 表达式</strong> 。如下：</p>
<h3 id="不好的写法"><a href="#不好的写法" class="headerlink" title="不好的写法"></a>不好的写法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">expression</span>(document.body.offsetWidth + <span class="string">"px"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，现在ie9 已经不再支持 <strong>css 表达式</strong> 了。<br>而且，这种写法自2013年以来，我再没有见过。</p>
<h2 id="将-css-从-javascript-中抽离"><a href="#将-css-从-javascript-中抽离" class="headerlink" title="将 css 从 javascript 中抽离"></a>将 <strong>css</strong> 从 <strong>javascript</strong> 中抽离</h2><h3 id="不好的写法-1"><a href="#不好的写法-1" class="headerlink" title="不好的写法"></a>不好的写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.style.color = <span class="string">"red"</span>;</span><br><span class="line">element.style.left = <span class="string">"10"</span>px;</span><br><span class="line">element.style.visibility = <span class="string">"visible"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="好的写法"><a href="#好的写法" class="headerlink" title="好的写法"></a>好的写法</h3><p>在 css 中定义样式 ， 在 javascript 中 通过 className 通信<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.reveal</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>javascript</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.className += <span class="string">"reveal"</span>;    <span class="comment">// 原生写法</span></span><br><span class="line">$(element).addClass(<span class="string">"reveal"</span>);    <span class="comment">// 如果是 jQuery</span></span><br></pre></td></tr></table></figure>
<h2 id="将-javascript-从-html-中抽离"><a href="#将-javascript-从-html-中抽离" class="headerlink" title="将 javascript 从 html 中抽离"></a>将 <strong>javascript</strong> 从 <strong>html</strong> 中抽离</h2><h3 id="不好的写法-2"><a href="#不好的写法-2" class="headerlink" title="不好的写法"></a>不好的写法</h3><figure class="highlight hsp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onclick</span>=<span class="string">"doSomething()"</span> id=<span class="string">"action"</span>&gt;click me&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们要避免使用 onclick 等 on 属性来绑定一个事件处理程序。<br>应该使用 id 保持 javascript 和 html 的沟通。</p>
<h3 id="好的写法-如使用-jQuery"><a href="#好的写法-如使用-jQuery" class="headerlink" title="好的写法, 如使用 jQuery"></a>好的写法, 如使用 jQuery</h3><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"<span class="subst">#action</span>"</span>).<span class="literal">on</span>(<span class="string">"click"</span>,doSomething);</span><br></pre></td></tr></table></figure>
<h2 id="将-html-从-javascript-中抽离"><a href="#将-html-从-javascript-中抽离" class="headerlink" title="将 html 从 javascript 中抽离"></a>将 <strong>html</strong> 从 <strong>javascript</strong> 中抽离</h2><p>注释中包含模板文本</p>
<figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">&lt;ul id="mylist"&gt;</span><span class="attribute">&lt;!--&lt;li id="item%s"&gt;</span><span class="attribute">&lt;a href="%s"&gt;</span>%s<span class="attribute">&lt;/a&gt;</span><span class="attribute">&lt;/li&gt;</span></span><br><span class="line">    <span class="attribute">&lt;li&gt;</span><span class="attribute">&lt;a href="1"&gt;</span>First item<span class="attribute">&lt;/a&gt;</span><span class="attribute">&lt;/li&gt;</span></span><br><span class="line">    <span class="attribute">&lt;li&gt;</span><span class="attribute">&lt;a href="2"&gt;</span>Second item<span class="attribute">&lt;/a&gt;</span><span class="attribute">&lt;/li&gt;</span></span><br><span class="line">    <span class="attribute">&lt;li&gt;</span><span class="attribute">&lt;a href="3"&gt;</span>Third item<span class="attribute">&lt;/a&gt;</span><span class="attribute">&lt;/li&gt;</span></span><br><span class="line"><span class="attribute">&lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="注释也是-DOM-的一部分"><a href="#注释也是-DOM-的一部分" class="headerlink" title="注释也是 DOM 的一部分"></a>注释也是 <strong>DOM</strong> 的一部分</h3><p>function addItem(url, text) {<br>    var mylist = document.getElementById(“mylist”),<br>        templateText = mylist.firstChild.nodeValue;<br>        result = sprintf(template, url, text);<br>    div.innerHTML = result;<br>    mylist.insertAdjacentHTML(“beforeend”, result);<br>}<br>addItem(“4”, “Four item”);</p>
<h3 id="使用一个带有自定义-type-属性的-script-元素。"><a href="#使用一个带有自定义-type-属性的-script-元素。" class="headerlink" title="使用一个带有自定义 type 属性的 script 元素。"></a>使用一个带有自定义 <strong>type</strong> 属性的 <strong>script</strong> 元素。</h3><p>浏览器会默认地将 <strong>script</strong> 元素中的内容识别为 <strong>JavaScript</strong> 代码， 但你可以通过给 <strong>type</strong> 赋值为浏览器不识别的类型，来告诉浏览器这不是一段 javascript 脚本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-my-template"</span> <span class="attr">id</span>=<span class="string">"list-item"</span>&gt;</span><span class="javascript"></span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以通过 <strong>script</strong> 标签的 <strong>text</strong> 属性来提取模板文本。<br>这样 <strong>addItem()</strong> 函数就会变成这样。</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItem</span>(<span class="params">url, text</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">var</span> mylist = <span class="built_in">document</span>.getElementById(<span class="string">"mylist"</span>),</span><br><span class="line">        script = <span class="built_in">document</span>.getElementById(<span class="string">"list-item"</span>),</span><br><span class="line">        templateText = script.test,</span><br><span class="line">        result = sprintf(template, <span class="built_in">url</span>, text),</span><br><span class="line">        div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    div.innerHTML = result.replace(<span class="regexp">/^\s*/</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="built_in">list</span>.appendChild(div.firstChild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">addItem(<span class="string">"/item/4"</span>, <span class="string">"Four item"</span>);</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[互联网项目生命周期]]></title>
      <url>http://tonydeng.github.io/2014/12/31/project-life-cycle/</url>
      <content type="html"><![CDATA[<p>下面这张图是我在google+中无意看到的，虽然有失偏颇，但是也经历过不少这样的互联网项目。</p>
<p>当你碰到这样的项目时，你该怎么办？这是一个需要深思的问题……</p>
<a id="more"></a>
<p><img src="/images/blog/project_life_cycle.jpg" alt="项目生命周期"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[brew update失败处理方法]]></title>
      <url>http://tonydeng.github.io/2014/12/31/brew-update-error/</url>
      <content type="html"><![CDATA[<p>使用<code>brew update</code>时报错，错误如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">error: Your <span class="built_in">local</span> changes <span class="built_in">to</span> <span class="keyword">the</span> following <span class="built_in">files</span> would be overwritten <span class="keyword">by</span> <span class="built_in">merge</span>:</span><br></pre></td></tr></table></figure>
<p>我看了diff，代码变更和网站上的代码变更一致，但是版本控制没有跟踪到。</p>
<p>解决办法就是同步到最新的版本，或者如果有自行修改或者第三方的修改要保留，可以merge</p>
<a id="more"></a>
<p>方法1.删除这些更改的文件，然后<code>brew update</code></p>
<p>方法2.重新获取最新的文件，并且<code>hardreset</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard FETCH_HEAD</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">cd /usr/<span class="keyword">local</span> &amp;&amp; sudo git reset <span class="comment">--hard FETCH_HEAD</span></span><br></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">cd `brew --<span class="built_in">prefix</span>`</span><br><span class="line">git remote add <span class="built_in">origin</span> https://github.com/mxcl/homebrew.git</span><br><span class="line">git fetch <span class="built_in">origin</span></span><br><span class="line">git <span class="built_in">reset</span> --hard <span class="built_in">origin</span>/master</span><br></pre></td></tr></table></figure>
<p><code>方法3.保留更改，</code>brew update`，再应用更改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">You have made some changes in the brew repository.</span><br><span class="line"></span><br><span class="line">You can either <span class="keyword">do</span> a git stash, brew <span class="keyword">update</span>, git stash pop <span class="keyword">to</span> <span class="keyword">keep</span> your changes, <span class="keyword">or</span> git <span class="keyword">reset</span> –hard <span class="keyword">HEAD</span>, brew <span class="keyword">update</span> <span class="keyword">to</span> <span class="keyword">reset</span> the changes.</span><br></pre></td></tr></table></figure>
<p>接着<code>brew doctor</code>又提示</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Warning: The /usr/local directory <span class="keyword">is</span> <span class="keyword">not</span> writable.</span><br><span class="line">Even <span class="keyword">if</span> <span class="keyword">this</span> directory was writable <span class="keyword">when</span> you installed Homebrew, other</span><br><span class="line">software may change permissions <span class="literal">on</span> <span class="keyword">this</span> directory. Some versions <span class="keyword">of</span> the</span><br><span class="line">“InstantOn” component <span class="keyword">of</span> Airfoil are known <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">this</span>.</span><br></pre></td></tr></table></figure>
<p>是group的问题，默认group是wheel，brew要求是admin</p>
<p>view source</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sudo chgrp -R admin /usr/<span class="keyword">local</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Sublime开发Golang]]></title>
      <url>http://tonydeng.github.io/2014/12/22/use-sublime-develop-golang/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/golang.jpg" alt="golang logo"></p>
<h2 id="安装Golang"><a href="#安装Golang" class="headerlink" title="安装Golang"></a>安装Golang</h2><p>在<a href="http://golang.org" target="_blank" rel="external">官网</a>上直接下载安装包就可以了。下载pkg格式的最新安装包 ，直接双击运行，一路按照提示操作就可以完成安装。</p>
<p>或者使用brew进行安装 <code>brew install go</code></p>
<p>完成安装之后，打开终端，输入 <code>go version</code> ，检查golang sdk是否安装成功。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  ~  <span class="keyword">go</span> version</span><br><span class="line"><span class="keyword">go</span> version go1<span class="number">.3</span><span class="number">.3</span> darwin/amd64</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>GOPATH是用来告诉Golang命令和其他相关工具 ，在哪儿可以找到你的Go包目录。</p>
<p>GOPATH是一个路径列表，类似PATH的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GOPATH=~/workspace/demo/go-demo</span><br></pre></td></tr></table></figure>
<p>我将Golang的相关配置都写在一个独立的.golangrc的文件中，然后在.zshrc中引入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.golangrc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你在GOLANG中配置了多个目录的话，当你下载开源包是(<code>go get *****</code>)，开源包默认会找到第一个目录，会统一下到第一个目录的pkg目录下。</p>
</blockquote>
<h2 id="go官方推荐的项目结构"><a href="#go官方推荐的项目结构" class="headerlink" title="go官方推荐的项目结构"></a>go官方推荐的项目结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                          <span class="comment"># command executable</span></span><br><span class="line">    outyet                         <span class="comment"># command executable</span></span><br><span class="line">pkg/</span><br><span class="line">    linux_amd64/</span><br><span class="line">        github.com/golang/example/</span><br><span class="line">            stringutil.a           <span class="comment"># package object</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">	hello/</span><br><span class="line">	    hello.go               <span class="comment"># command source</span></span><br><span class="line">	outyet/</span><br><span class="line">	    main.go                <span class="comment"># command source</span></span><br><span class="line">	    main_test.go           <span class="comment"># test source</span></span><br><span class="line">	stringutil/</span><br><span class="line">	    reverse.go             <span class="comment"># package source</span></span><br><span class="line">	    reverse_test.go        <span class="comment"># test source</span></span><br></pre></td></tr></table></figure>
<p>参考</p>
<blockquote>
<p><a href="http://golang.org/doc/code.html" target="_blank" rel="external">http://golang.org/doc/code.html</a></p>
</blockquote>
<h2 id="Sublime安装GoSublime"><a href="#Sublime安装GoSublime" class="headerlink" title="Sublime安装GoSublime"></a>Sublime安装GoSublime</h2><p>Package Control如何安装我就不说了。直接安装<a href="https://github.com/DisposaBoy/GoSublime" target="_blank" rel="external">GoSublime</a>插件</p>
<p>Mac OSX下使用Command + Shift + P打开<code>Package Control</code>，然后输入 <code>pcip</code> (Package Control:Install Package的缩写)</p>
<p>在随后的界面中输入<code>GoSublime</code>，回车，就开始安装GoSubmlime了。</p>
<p>当你可以在Sublime的 <code>Preferences -&gt; Package Settings</code> 看到 <code>GoSublime</code> ，那么恭喜你，你的基于Sublime的Golang开发环境就搭建完成了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grunt项目脚手架]]></title>
      <url>http://tonydeng.github.io/2014/12/11/grunt-project-scaffolding/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文： <a href="https://github.com/gruntjs/grunt-docs/blob/master/Project-Scaffolding.md" target="_blank" rel="external">https://github.com/gruntjs/grunt-docs/blob/master/Project-Scaffolding.md</a></p>
</blockquote>
<h1 id="1-grunt-init"><a href="#1-grunt-init" class="headerlink" title="1. grunt-init"></a>1. grunt-init</h1><p>grunt-init 是一个脚手架工具，用于自动创建项目。基于当前的环境和几个问题的答案创建一个完整的目录结构。确切的文件和内容取决于所选的模板，和模板提出的问题的答案。</p>
<p>注：本独立程序曾经作为“init”任务内置于 Grunt。关于该变化的更多信息查看 Grunt 从 0.3 升级到 0.4 指南。</p>
<a id="more"></a>
<h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>为了使用 <strong>grunt-init</strong> ，你需要全局安装它。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g grunt-init</span><br></pre></td></tr></table></figure>
<p>这将把将命令 <code>grunt-init</code> 放入系统路径中，从而可以从任意目录运行它。</p>
<p>注：你可能需要使用指令 sudo 或者以管理员身份运行命令解释程序来做到这一点。</p>
<h1 id="3-用法"><a href="#3-用法" class="headerlink" title="3. 用法"></a>3. 用法</h1><ul>
<li>使用 <code>grunt-init --help</code> 获取程序帮助和可用的模板列表。</li>
<li>使用 <code>grunt-init TEMPLATE</code> 基于一个可用的模板创建一个项目。</li>
<li>使用 <code>grunt-init /path/to/TEMPLATE</code> 基于一个任意位置的模板创建一个项目。</li>
</ul>
<p>需要注意的是，大多数模板在当前目录中生成它们的文件，因此一定要先切换到一个新目录，如果不希望覆盖已有文件的话。</p>
<h1 id="4-安装模板"><a href="#4-安装模板" class="headerlink" title="4. 安装模板"></a>4. 安装模板</h1><p>一旦模板被安装到 <code>~/.grunt-init/</code> 目录（在 Windows 上是 <code>(%USERPROFILE%\.grunt=init\）</code>，就可以通过 grunt-init 使用它们。使用你使用 git 拷贝一个模范到该目录中。例如，可以这样安装 <a href="https://github.com/gruntjs/grunt-init-jquery" target="_blank" rel="external">grunt-init-jquery</a> 模板：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git clone git@github<span class="selector-class">.com</span>:gruntjs/grunt-init-jquery<span class="selector-class">.git</span> ~/.grunt-init/jquery</span><br></pre></td></tr></table></figure>
<p>注：如果你想以<em>“foobarbaz”</em>在本地使用模板，你可以在拷贝时指定<code>~/.grunt-init/foobarbaz</code>。grunt-init 将使用模板在目录 <code>~/.grunt-init/</code> 中的实际目录名。</p>
<p>一些 grunt-init 模板由官方维护：</p>
<ul>
<li><a href="https://github.com/gruntjs/grunt-init-commonjs" target="_blank" rel="external">grunt-init-commonjs</a> - 创建一个 commonjs 模块，包括 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-commonjs-sample/tree/generated" target="_blank" rel="external">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-commonjs-sample#project-creation-transcript" target="_blank" rel="external">创建记录</a>）</li>
<li><a href="https://github.com/gruntjs/grunt-init-gruntfile" target="_blank" rel="external">grunt-init-gruntfile</a> - 创建一个基本的 Gruntfile。（<a href="https://github.com/gruntjs/grunt-init-gruntfile-sample/tree/generated" target="_blank" rel="external">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-gruntfile-sample#project-creation-transcript" target="_blank" rel="external">创建记录</a>）</li>
<li><a href="https://github.com/gruntjs/grunt-init-gruntplugin" target="_blank" rel="external">grunt-init-gruntplugin</a> -创建一个 Grunt 插件，包含 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-gruntplugin-sample/tree/generated" target="_blank" rel="external">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-gruntplugin-sample#project-creation-transcript" target="_blank" rel="external">创建记录</a>）</li>
<li><a href="https://github.com/gruntjs/grunt-init-jquery" target="_blank" rel="external">grunt-init-jquery</a> - 创建一个 jQuery 插件，包含 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-jquery-sample/tree/generated" target="_blank" rel="external">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-jquery-sample#project-creation-transcript" target="_blank" rel="external">创建记录</a>）</li>
<li><a href="https://github.com/gruntjs/grunt-init-node" target="_blank" rel="external">grunt-init-node</a> - 创建一个 Node.js 模块，包含 Nodeunit 单元测试。（<a href="https://github.com/gruntjs/grunt-init-node-sample/tree/generated" target="_blank" rel="external">生成的样本库</a> | <a href="https://github.com/gruntjs/grunt-init-node-sample#project-creation-transcript" target="_blank" rel="external">创建记录</a>）</li>
</ul>
<h1 id="5-自定义模板"><a href="#5-自定义模板" class="headerlink" title="5. 自定义模板"></a>5. 自定义模板</h1><p>你可以创建和使用自定义模板。你的模板必须遵循与上述模板同样的结构。</p>
<p>一个命名为 <code>my-template</code> 的模板要遵循下面的通用文件结构：</p>
<ul>
<li>my-template/template.js - 主模板文件.</li>
<li>my-template/rename.json - 模板特定的命名规则，作为模板处理。</li>
<li>my-template/root/ - 拷贝到目标位置的文件。</li>
</ul>
<p>假设这些文件已经在 <code>/path/to/my-template</code>，可以用命令 <code>grunt-init /path/to/my-template</code> 处理该模板。多个不重名的模板可以存在于同一个目录项，就像内置模板一样。</p>
<blockquote>
<p>没有在内置模板中找到多个不重名模板，疑问中</p>
</blockquote>
<p>此外，如果将自定义模板放入 <code>~/.grunt-init/</code> 目录（Windows 上是 <code>%USERPROFILE%\.grunt-init\</code>），运行 <code>grunt-init my-template</code> 将自动被使用。</p>
<h2 id="5-1-拷贝文件"><a href="#5-1-拷贝文件" class="headerlink" title="5.1 拷贝文件"></a>5.1 拷贝文件</h2><p>当 init 模板运行时，只要一个模板使用方法 <code>init.filesToCopy</code> 和 <code>init.copyAndProcess</code>，目录 <code>root/</code> 中的所有文件将被复制到当前目录。</p>
<p>请注意，所以拷贝文件会被当作模板处理，模板 <code>{ % % }</code> 将在收集的 <code>props</code> 数据对象下处理，除非设置了选项 <code>noProcess</code>。看看 <a href="https://github.com/gruntjs/grunt-init-jquery" target="_blank" rel="external">jQuery 模板</a>例子。</p>
<h2 id="5-2-重命名或不包括模板文件"><a href="#5-2-重命名或不包括模板文件" class="headerlink" title="5.2 重命名或不包括模板文件"></a>5.2 重命名或不包括模板文件</h2><p><code>rename.json</code> 描述 <code>sourcepath</code> 到 <code>destpath</code> 的重命名映射。<code>sourcepath</code> 必须是 <code>root/</code> 文件夹下将被拷贝文件的路径，而 <code>destpath</code> 值可以包含 <code>{ % % }</code> 模板，描述目标路径是什么。</p>
<p>如果指定 <code>destpath</code> 为 <code>false</code>，该文件不会被复制。此外，<code>srcpath</code> 支持通配符。</p>
<h1 id="6-指定默认提示答案"><a href="#6-指定默认提示答案" class="headerlink" title="6. 指定默认提示答案"></a>6. 指定默认提示答案</h1><p>没有初始化提示或者有一个硬编码的默认值，或者产看当前环境来尝试判断默认值。如果你想覆盖个别提示的默认值，你可以在选项文件 <code>~/.grunt-init/defaults.json</code>（OS X 或 Linux）或 <code>%USERPROFILE%\.grunt-init\defaults.json</code>（Window）中这么做。</p>
<p>例如，我的 <code>defaults.json</code> 文件看起来就像这样，因为我想用一个稍微不同的名称而不是默认名称，想要排除我的电子邮件地址，想自动指定一个作者网址。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"author_name"</span>: <span class="string">"\"Cowboy\" Ben Alman"</span>,</span><br><span class="line">  <span class="attr">"author_email"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"author_url"</span>: <span class="string">"http://benalman.com/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在所有内置提示被文档化之前，你可以在<a href="https://github.com/gruntjs/grunt-init/blob/master/tasks/init.js" target="_blank" rel="external">源代码</a>中找到它们的名称和默认值。</p>
<h1 id="7-定义一个初始化模板"><a href="#7-定义一个初始化模板" class="headerlink" title="7. 定义一个初始化模板"></a>7. 定义一个初始化模板</h1><blockquote>
<p>对照 ~/.grunt-init/node/template.js 理解。</p>
</blockquote>
<h2 id="7-1-exports-description"><a href="#7-1-exports-description" class="headerlink" title="7.1 exports.description"></a>7.1 exports.description</h2><p>当用户运行 <code>grunt init</code> 或 <code>grunt-init</code> 来显示所有有效的初始化模板列表时，简短的模板描述随模板名称一起显示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.description = descriptionString;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-exports-notes"><a href="#7-2-exports-notes" class="headerlink" title="7.2 exports.notes"></a>7.2 exports.notes</h2><p>如果指定了，该可选的扩展描述将在所有提示之前显示。这是一个很好的向用户提供一点点帮助解释命名约定的地方，哪些提示是必须或可选的，等等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.notes = notesString;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-exports-warnOn"><a href="#7-3-exports-warnOn" class="headerlink" title="7.3 exports.warnOn"></a>7.3 exports.warnOn</h2><p>如果该可选（但是推荐）的通配符或通配符数组被（已存在的文件或目录）匹配，Grunt 将中止，并导致一条警告信息，用户可以使用 <code>--force</code> 覆盖该行为。这些初试化模板可能潜在的覆盖已存在文件时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.warnOn = wildcardPattern;</span><br></pre></td></tr></table></figure>
<p>而最常见的值是 ‘*’，匹配所有文件或文件夹，使用的 <a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">minimatch</a> 通配符语法允许很大的灵活性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.warnOn = <span class="string">'Gruntfile.js'</span>;    <span class="comment">// Warn on a Gruntfile.js file.</span></span><br><span class="line">exports.warnOn = <span class="string">'*.js'</span>;            <span class="comment">// Warn on any .js file.</span></span><br><span class="line">exports.warnOn = <span class="string">'*'</span>;               <span class="comment">// Warn on any non-dotfile or non-dotdir.</span></span><br><span class="line">exports.warnOn = <span class="string">'.*'</span>;              <span class="comment">// Warn on any dotfile or dotdir.</span></span><br><span class="line">exports.warnOn = <span class="string">'&#123;.*,*&#125;'</span>;          <span class="comment">// Warn on any file or dir (dot or non-dot).</span></span><br><span class="line">exports.warnOn = <span class="string">'!*/**'</span>;           <span class="comment">// Warn on any file (ignoring dirs).</span></span><br><span class="line">exports.warnOn = <span class="string">'*.&#123;png,gif,jpg&#125;'</span>; <span class="comment">// Warn on any image file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is another way of writing the last example.</span></span><br><span class="line">exports.warnOn = [<span class="string">'*.png'</span>, <span class="string">'*.gif'</span>, <span class="string">'*.jpg'</span>];</span><br></pre></td></tr></table></figure>
<h2 id="7-4-exports-template"><a href="#7-4-exports-template" class="headerlink" title="7.4 exports.template"></a>7.4 exports.template</h2><p>虽然 <code>exports</code> 属性定义在该函数之外，但是所有实际的初始化代码在该函数内指定。三个参数被传给该函数。参数 <code>grunt</code> 指向 grunt，包含了所有的 <a href="http://gruntjs.com/api/grunt" target="_blank" rel="external">grunt 方法和库</a>。参数 <code>init</code> 是一个包含了特定于该初始化模板的方法和属性的对象。参数 <code>done</code> 是一个函数，当初始化模板执行完成时必须调用该函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.template = <span class="function"><span class="keyword">function</span>(<span class="params">grunt, init, done</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// See the "Inside an init template" section.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="8-初始化模板内部"><a href="#8-初始化模板内部" class="headerlink" title="8. 初始化模板内部"></a>8. 初始化模板内部</h1><h2 id="8-1-init-addLicenseFiles"><a href="#8-1-init-addLicenseFiles" class="headerlink" title="8.1 init.addLicenseFiles"></a>8.1 init.addLicenseFiles</h2><p>添加适当命名的许可证文件到 files 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> files = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> licenses = [<span class="string">'MIT'</span>];</span><br><span class="line">init.addLicenseFiles(files, licenses);</span><br><span class="line"><span class="comment">// files === &#123;'LICENSE-MIT': 'licenses/LICENSE-MIT'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="8-2-init-availableLicenses"><a href="#8-2-init-availableLicenses" class="headerlink" title="8.2 init.availableLicenses"></a>8.2 init.availableLicenses</h2><p>返回有效许可证数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> licenses = init.availableLicenses();</span><br><span class="line"><span class="comment">// licenses === [ 'Apache-2.0', 'GPL-2.0', 'MIT', 'MPL-2.0' ]</span></span><br></pre></td></tr></table></figure>
<h2 id="8-3-init-copy"><a href="#8-3-init-copy" class="headerlink" title="8.3 init.copy"></a>8.3 init.copy</h2><p>复制一个文件，指定一个绝对或相对源路径和一个可选的相对目标路径，可以通过传入的回调函数处理复制的文件。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.copy(srcpath[, destpath], options)</span><br></pre></td></tr></table></figure></p>
<h2 id="8-4-init-copyAndProcess"><a href="#8-4-init-copyAndProcess" class="headerlink" title="8.4 init.copyAndProcess"></a>8.4 init.copyAndProcess</h2><p>遍历传入的对象中的所有文件，拷贝源文件到目标地址，并处理文件内容。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.copyAndProcess(files, props[, options])</span><br></pre></td></tr></table></figure></p>
<h2 id="8-5-init-defaults"><a href="#8-5-init-defaults" class="headerlink" title="8.5 init.defaults"></a>8.5 init.defaults</h2><p><code>defaults.json</code> 中用户指定的默认初始值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.defaults</span><br></pre></td></tr></table></figure></p>
<h2 id="8-6-init-destpath"><a href="#8-6-init-destpath" class="headerlink" title="8.6 init.destpath"></a>8.6 init.destpath</h2><p>绝对目标文件路径。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.destpath()</span><br></pre></td></tr></table></figure></p>
<h2 id="8-7-init-expand"><a href="#8-7-init-expand" class="headerlink" title="8.7 init.expand"></a>8.7 init.expand</h2><p>与 <a href="https://github.com/gruntjs/grunt/wiki/grunt.file#wiki-grunt-file-expand" target="_blank" rel="external">grunt.file.expand</a> 一致。</p>
<p>返回一个不重复数组，含有匹配通配符模式的所有文件和目录路径。该方法接收逗号分割的痛佩服模式，或者通配符模式数组。匹配以 ! 开头的模式的路径将从返回值中排除。模式被顺序处理，所以包含和排除的顺序是重要的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.expand([options, ] patterns)</span><br></pre></td></tr></table></figure>
<h2 id="8-8-init-filesToCopy"><a href="#8-8-init-filesToCopy" class="headerlink" title="8.8 init.filesToCopy"></a>8.8 init.filesToCopy</h2><p>返回一个包含了待复制文件的对象，包含绝对源路径和相对目标路径，按照 <code>rename.json</code>（如果存在的话）中的规则重命名（或忽略）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> files = init.filesToCopy(props);</span><br><span class="line"><span class="comment">/* files === &#123; '.gitignore': 'template/root/.gitignore',</span><br><span class="line">  '.jshintrc': 'template/root/.jshintrc',</span><br><span class="line">  'Gruntfile.js': 'template/root/Gruntfile.js',</span><br><span class="line">  'README.md': 'template/root/README.md',</span><br><span class="line">  'test/test_test.js': 'template/root/test/name_test.js' &#125; */</span></span><br></pre></td></tr></table></figure>
<h2 id="8-9-init-getFile"><a href="#8-9-init-getFile" class="headerlink" title="8.9 init.getFile"></a>8.9 init.getFile</h2><p>返回单个任务文件路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.getFile(filepath[, ...])</span><br></pre></td></tr></table></figure>
<h2 id="8-10-init-getTemplates"><a href="#8-10-init-getTemplates" class="headerlink" title="8.10 init.getTemplates"></a>8.10 init.getTemplates</h2><p>返回含有所有有效模板的对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.getTemplates()</span><br></pre></td></tr></table></figure></p>
<h2 id="8-11-init-initSearchDirs"><a href="#8-11-init-initSearchDirs" class="headerlink" title="8.11 init.initSearchDirs"></a>8.11 init.initSearchDirs</h2><p>初始化目录来搜索初始化模板。这里的<code>模板</code>是指模板路径。会包括 <code>~/.grunt-init/</code> 和 <code>grunt-init</code> 中的核心初始化任务。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.initSearchDirs([filename])</span><br></pre></td></tr></table></figure></p>
<h2 id="8-12-init-process"><a href="#8-12-init-process" class="headerlink" title="8.12 init.process"></a>8.12 init.process</h2><p>启动进程，开始提示输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.process(options, prompts, done)</span><br><span class="line"></span><br><span class="line">init.process(&#123;&#125;, [</span><br><span class="line">  <span class="comment">// Prompt for these values</span></span><br><span class="line">  init.prompt(<span class="string">'name'</span>),</span><br><span class="line">  init.prompt(<span class="string">'description'</span>),</span><br><span class="line">  init.prompt(<span class="string">'version'</span>)</span><br><span class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">err, props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// All finished, do something with the properties</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="8-13-init-prompt"><a href="#8-13-init-prompt" class="headerlink" title="8.13 init.prompt"></a>8.13 init.prompt</h2><p>提示用户输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.prompt(name[, <span class="keyword">default</span>])</span><br></pre></td></tr></table></figure>
<h2 id="8-14-init-prompts"><a href="#8-14-init-prompts" class="headerlink" title="8.14 init.prompts"></a>8.14 init.prompts</h2><p>含有所有提示的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prompts = init.prompts;</span><br></pre></td></tr></table></figure>
<h2 id="8-15-init-readDefaults"><a href="#8-15-init-readDefaults" class="headerlink" title="8.15 init.readDefaults"></a>8.15 init.readDefaults</h2><p>从任务文件（如果存在的话）读取 JSON 默认值，并合并到一个数据对象中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.readDefaults(filepath[, ...])</span><br></pre></td></tr></table></figure>
<h2 id="8-16-init-renames"><a href="#8-16-init-renames" class="headerlink" title="8.16 init.renames"></a>8.16 init.renames</h2><p>模板的重命名规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> renames = init.renames;</span><br><span class="line"><span class="comment">// renames === &#123; 'test/name_test.js': 'test/\&#123;\%= name \%\&#125;_test.js' &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="8-17-init-searchDirs"><a href="#8-17-init-searchDirs" class="headerlink" title="8.17 init.searchDirs"></a>8.17 init.searchDirs</h2><p>目录数组，用于在其中搜索模板。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dirs = init.searchDirs;</span><br><span class="line"><span class="comment">/* dirs === [ '/Users/shama/.grunt-init',</span><br><span class="line">  '/usr/local/lib/node_modules/grunt-init/templates' ] */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-18-init-srcpath"><a href="#8-18-init-srcpath" class="headerlink" title="8.18 init.srcpath"></a>8.18 init.srcpath</h2><p>通过文件名搜索初始化模板路径，并返回一个绝对路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.srcpath(filepath[, ...])</span><br></pre></td></tr></table></figure>
<h2 id="8-19-init-userDir"><a href="#8-19-init-userDir" class="headerlink" title="8.19 init.userDir"></a>8.19 init.userDir</h2><p>返回用户模板路径的绝对路径。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dir = init.userDir();</span><br><span class="line"><span class="comment">// dir === '/Users/shama/.grunt-init'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="8-20-init-writePackageJSON"><a href="#8-20-init-writePackageJSON" class="headerlink" title="8.20 init.writePackageJSON"></a>8.20 init.writePackageJSON</h2><p>保存一个 package.json 文件到目标目录。回调函数可以用来后置处理属性，或添加或移除或其他任何操作。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">init.writePackageJSON(filename, props[, callback])</span><br></pre></td></tr></table></figure></p>
<h1 id="9-内置提示"><a href="#9-内置提示" class="headerlink" title="9. 内置提示"></a>9. 内置提示</h1><h2 id="9-1-author-email"><a href="#9-1-author-email" class="headerlink" title="9.1 author_email"></a>9.1 author_email</h2><p>Author’s email address to use in the <code>package.json</code>. Will attempt to find a default value from the user’s git config.</p>
<h2 id="9-2-author-name"><a href="#9-2-author-name" class="headerlink" title="9.2 author_name"></a>9.2 author_name</h2><p>Author’s full name to use in the <code>package.json</code> and copyright notices. Will attempt to find a default value from the user’s git config.</p>
<h2 id="9-3-author-url"><a href="#9-3-author-url" class="headerlink" title="9.3 author_url"></a>9.3 author_url</h2><p>A public URL to the author’s website to use in the <code>package.json</code>.</p>
<h2 id="9-4-bin"><a href="#9-4-bin" class="headerlink" title="9.4 bin"></a>9.4 bin</h2><p>A relative path from the project root for a cli script.</p>
<h2 id="9-5-bugs"><a href="#9-5-bugs" class="headerlink" title="9.5 bugs"></a>9.5 bugs</h2><p>A public URL to the project’s issues tracker. Will default to the github issue tracker if the project has a github repository.</p>
<h2 id="9-6-description"><a href="#9-6-description" class="headerlink" title="9.6 description"></a>9.6 description</h2><p>A description of the project. Used in the package.json and README files.</p>
<h2 id="9-7-grunt-version"><a href="#9-7-grunt-version" class="headerlink" title="9.7 grunt_version"></a>9.7 grunt_version</h2><p>A valid semantic version range descriptor of Grunt the project requires.</p>
<h2 id="9-8-homepage"><a href="#9-8-homepage" class="headerlink" title="9.8 homepage"></a>9.8 homepage</h2><p>A public URL to the project’s home page. Will default to the github url if a github repository.</p>
<h2 id="9-9-jquery-version"><a href="#9-9-jquery-version" class="headerlink" title="9.9 jquery_version"></a>9.9 jquery_version</h2><p>If a jQuery project, the version of jQuery the project requires. Must be a valid semantic version range descriptor.</p>
<h2 id="9-10-licenses"><a href="#9-10-licenses" class="headerlink" title="9.10 licenses"></a>9.10 licenses</h2><p>The license(s) for the project. Multiple licenses are separated by spaces. The licenses built-in are: MIT, MPL-2.0, GPL-2.0, and Apache-2.0. Defaults to MIT. Add custom licenses with init.addLicenseFiles.</p>
<h2 id="9-11-main"><a href="#9-11-main" class="headerlink" title="9.11 main"></a>9.11 main</h2><p>The primary entry point of the project. Defaults to the project name within the lib folder.</p>
<h2 id="9-12-name"><a href="#9-12-name" class="headerlink" title="9.12 name"></a>9.12 name</h2><p>The name of the project. Will be used heavily throughout the project template. Defaults to the current working directory.</p>
<h2 id="9-13-node-version"><a href="#9-13-node-version" class="headerlink" title="9.13 node_version"></a>9.13 node_version</h2><p>The version of Node.js the project requires. Must be a valid semantic version range descriptor.</p>
<h2 id="9-14-npm-test"><a href="#9-14-npm-test" class="headerlink" title="9.14 npm_test"></a>9.14 npm_test</h2><p>The command to run tests on your project. Defaults to grunt.</p>
<h2 id="9-15-repository"><a href="#9-15-repository" class="headerlink" title="9.15 repository"></a>9.15 repository</h2><p>Project’s git repository. Defaults to a guess of a github url.<br>9.16 title ⬆</p>
<p>A human readable project name. Defaults to the actual project name altered to be more human readable.</p>
<h2 id="9-17-version"><a href="#9-17-version" class="headerlink" title="9.17 version"></a>9.17 version</h2><p>The version of the project. Defaults to the first valid semantic version, 0.1.0.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux performance tools]]></title>
      <url>http://tonydeng.github.io/2014/12/09/linux-performance-tools/</url>
      <content type="html"><![CDATA[<p>先挖个坑，慢慢填。</p>
<p><img src="/images/blog/linux_observability_tools.png" alt="Linux Performace Tools"></p>
<p><a href="http://www.brendangregg.com/blog/2014-11-22/linux-perf-tools-2014.html" target="_blank" rel="external">原文链接</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[zsh在scp时不能使用通配符的原因和解决方案]]></title>
      <url>http://tonydeng.github.io/2014/12/09/zsh-scp-wildcard/</url>
      <content type="html"><![CDATA[<p>scp是我们经常使用的一个本地与远程服务器相互cp数据的命令，zsh是我最喜欢的shell，但是在zsh下使用scp来cp远程服务器的文件时，却出现这样的错误。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">scp <span class="string">ip:</span><span class="regexp">/home/</span>tonydeng<span class="regexp">/logs/</span>*.log .</span><br><span class="line"><span class="string">zsh:</span> no matches <span class="string">found:</span> <span class="string">ip:</span><span class="regexp">/home/</span>tonydeng<span class="regexp">/logs/</span>*.log</span><br></pre></td></tr></table></figure>
<p>同样地命令，在bash下确实可以执行的，这个原因是什么呢？</p>
<a id="more"></a>
<p>由于zsh不会按照远程地址上的文件去扩展参数，当你使用<figure class="highlight plain"><figcaption><span>在匹配失败时就使用原来的内容，zsh 则报告一个```no matches```的错误。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在zsh中执行```setopt nonomatch```，告诉它不要报告```no matches```的错误，而是当匹配失败时直接使用原来的内容。</span><br><span class="line"></span><br><span class="line">实际上，不管是 bash 还是 zsh，不管设置了什么选项，只要把```ip:/home/tonydeng/logs/*.log```加上引号，如```&quot;ip:/home/tonydeng/logs/*.log&quot;```，就可解决问题。</span><br><span class="line"></span><br><span class="line">当然根本的解决办法还是告诉zsh不要报告```no matches```错误。</span><br><span class="line"></span><br><span class="line">建议你执行下面的命令一劳永逸，好好享受zsh给你带来的快乐和便利吧。</span><br></pre></td></tr></table></figure></p>
<p>echo “setopt nonomatch” &gt;&gt; ~/.zshrc<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">或</span><br></pre></td></tr></table></figure></p>
<p>echo “set -o nonomatch” &gt;&gt; ~/.zshrc<br>```</p>
<p>其实我之前的<a href="/blog/2014/12/07/octopress-can-not-create-new-post-on-zsh/">这篇blog</a>也是同样的原因。</p>
<p>参考</p>
<p>stackoverflow的问答<a href="http://stackoverflow.com/questions/20037364/why-zsh-tries-to-expand-and-bash-does-not" target="_blank" rel="external">Why zsh tries to expand * and bash does not?</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PSSH基本使用介绍]]></title>
      <url>http://tonydeng.github.io/2014/12/08/pssh/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/pssh.png" alt="PSSH"></p>
<p>pssh是一个用python编写的可以在多台服务器上执行命令的工具，同时支持拷贝文件等功能，在同类工具中还是很方便使用的。项目地址：<a href="https://code.google.com/p/parallel-ssh/" target="_blank" rel="external">parallel-ssh</a><br><a id="more"></a></p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>Mac下可以直接使用brew来安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew  install pssh</span><br><span class="line">==&gt; Downloading https://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; python setup.py install --prefix=/usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1 --install-data=/usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1/share</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Python modules have been installed and Homebrew<span class="string">'s site-packages is not</span><br><span class="line">in your Python sys.path, so you will not be able to import the modules</span><br><span class="line">this formula installed. If you plan to develop with these modules,</span><br><span class="line">please run:</span><br><span class="line">  mkdir -p /Users/tonydeng/Library/Python/2.7/lib/python/site-packages</span><br><span class="line">  echo '</span>import site; site.addsitedir(<span class="string">"/usr/local/lib/python2.7/site-packages"</span>)<span class="string">' &gt;&gt; /Users/tonydeng/Library/Python/2.7/lib/python/site-packages/homebrew.pth</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/pssh/2.3.1: 40 files, 228K, built in 9 seconds</span></span><br></pre></td></tr></table></figure>
<p>其他平台安装方法类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://parallel-ssh.googlecode.com/files/pssh-2.3.1.tar.gz</span><br><span class="line">tar zxvf pssh-2.3.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pssh-2.3.1</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>pssh安装包给我们提供了多个非常实用的工具，我们可以查看一下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  pssh  ll /usr/<span class="built_in">local</span>/Cellar/pssh/2.3.1/bin</span><br><span class="line">total 48</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   141B 12  8 15:32 pnuke</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   142B 12  8 15:32 prsync</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   140B 12  8 15:32 pscp</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   142B 12  8 15:32 pslurp</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   140B 12  8 15:32 pssh</span><br><span class="line">-r-xr-xr-x  1 tonydeng  admin   148B 12  8 15:32 pssh-askpass</span><br></pre></td></tr></table></figure>
<p>提供的工具作用如下：</p>
<ol>
<li>parallel-ssh （pssh） 在多个主机上并行地运行命令。</li>
<li>parallel-scp （pscp）把文件并行地复制到多个主机上。</li>
<li>parallel-rsync （psync）通过 rsync 协议把文件高效地并行复制到多个主机上。</li>
<li>parallel-slurp （pslurp）把文件并行地从多个远程主机复制到中心主机上。</li>
<li>parallel-nuke （pnuke）并行地在多个远程主机上杀死进程。</li>
</ol>
<h2 id="pssh基本使用方法"><a href="#pssh基本使用方法" class="headerlink" title="pssh基本使用方法"></a>pssh基本使用方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pssh -h host.txt -P <span class="string">"command"</span></span><br></pre></td></tr></table></figure>
<p>如果对pssh的参数不太明白的话，可使用–help来获得帮助。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  pssh  pssh --help</span><br><span class="line">Usage: pssh [OPTIONS] <span class="built_in">command</span> [...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --version             show program<span class="string">'s version number and exit</span><br><span class="line">  --help                show this help message and exit</span><br><span class="line">  -h HOST_FILE, --hosts=HOST_FILE</span><br><span class="line">                        hosts file (each line "[user@]host[:port]")</span><br><span class="line">  -H HOST_STRING, --host=HOST_STRING</span><br><span class="line">                        additional host entries ("[user@]host[:port]")</span><br><span class="line">  -l USER, --user=USER  username (OPTIONAL)</span><br><span class="line">  -p PAR, --par=PAR     max number of parallel threads (OPTIONAL)</span><br><span class="line">  -o OUTDIR, --outdir=OUTDIR</span><br><span class="line">                        output directory for stdout files (OPTIONAL)</span><br><span class="line">  -e ERRDIR, --errdir=ERRDIR</span><br><span class="line">                        output directory for stderr files (OPTIONAL)</span><br><span class="line">  -t TIMEOUT, --timeout=TIMEOUT</span><br><span class="line">                        timeout (secs) (0 = no timeout) per host (OPTIONAL)</span><br><span class="line">  -O OPTION, --option=OPTION</span><br><span class="line">                        SSH option (OPTIONAL)</span><br><span class="line">  -v, --verbose         turn on warning and diagnostic messages (OPTIONAL)</span><br><span class="line">  -A, --askpass         Ask for a password (OPTIONAL)</span><br><span class="line">  -x ARGS, --extra-args=ARGS</span><br><span class="line">                        Extra command-line arguments, with processing for</span><br><span class="line">                        spaces, quotes, and backslashes</span><br><span class="line">  -X ARG, --extra-arg=ARG</span><br><span class="line">                        Extra command-line argument</span><br><span class="line">  -i, --inline          inline aggregated output and error for each server</span><br><span class="line">  --inline-stdout       inline standard output for each server</span><br><span class="line">  -I, --send-input      read from standard input and send as input to ssh</span><br><span class="line">  -P, --print           print output as we get it</span><br><span class="line"></span><br><span class="line">Example: pssh -h hosts.txt -l irb2 -o /tmp/foo uptime</span></span><br></pre></td></tr></table></figure>
<p>简单解释一下pssh help提供的例子。在hosts.txt中列出来的服务器上远程执行uptime命令，并将执行结果输出到/tmp/uptime目录下相应地服务器的文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pssh -h hosts.txt <span class="_">-l</span> root -o /tmp/uptime uptime</span><br></pre></td></tr></table></figure>
<p>其中相关参数说明：</p>
<blockquote>
<p>-h hosts.txt 指定服务器列表的文件为hosts.txt</p>
<p>-l root 指定远程用户为root</p>
<p>-o /tmp/uptime 指定远程命令执行返回结果输出目录为/tmp/uptime</p>
<p>uptime 指定远程服务器上执行的命令为uptime</p>
</blockquote>
<p>我们执行一下看看，执行结果说明在172.18.10.25和172.18.10.24两台服务器上执行成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[1] 09:51:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:51:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure>
<p>查看执行结果输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls <span class="_">-l</span> /tmp/uptime</span><br><span class="line">-rw-r--r--  1 tonydeng  wheel    71B 12  9 09:51 172.18.10.24</span><br><span class="line">-rw-r--r--  1 tonydeng  wheel    71B 12  9 09:51 172.18.10.25</span><br></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">cat /tmp/uptime/<span class="number">172.18</span><span class="meta">.10</span><span class="meta">.24</span></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">26</span> <span class="meta">up</span> <span class="number">59</span> days, <span class="number">13</span>:<span class="number">48</span>,  <span class="number">0</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br><span class="line"></span><br><span class="line">cat /tmp/uptime/<span class="number">172.18</span><span class="meta">.10</span><span class="meta">.25</span></span><br><span class="line"><span class="number">09</span>:<span class="number">51</span>:<span class="number">26</span> <span class="meta">up</span> <span class="number">59</span> days, <span class="number">13</span>:<span class="number">47</span>,  <span class="number">0</span> users,  load average: <span class="number">0.00</span>, <span class="number">0.00</span>, <span class="number">0.00</span></span><br></pre></td></tr></table></figure>
<p>通过这个例子大家应该能够明白pssh的使用方法了吧。</p>
<h2 id="pscp基本用法"><a href="#pscp基本用法" class="headerlink" title="pscp基本用法"></a>pscp基本用法</h2><p><code>pscp</code>用来将文件并行的复制到多个主机上。</p>
<p><code>pscp</code>和<code>pssh</code>的很多参数都是一样的，就不在多说了，举一个简单的例子来说明一下<code>pscp</code>的简单实用。</p>
<p>基本使用方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pscp -h ip文件 本地文件 远程目录</span><br></pre></td></tr></table></figure>
<p>例子:将本机的<code>/tmp/i.txt</code>文件复制到<code>host.txt</code>列出的主机上的<code>/tmp</code>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pscp -h hosts.txt <span class="_">-l</span> root /tmp/i.txt /tmp</span><br><span class="line">[1] 09:52:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:52:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure>
<p><strong>特别参数说明：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-r 用于递归的复制目录</span><br></pre></td></tr></table></figure>
<h2 id="pslurp基本用法"><a href="#pslurp基本用法" class="headerlink" title="pslurp基本用法"></a>pslurp基本用法</h2><p><code>pslurp</code>把文件并行地从多个远程主机复制到中心主机上</p>
<p>基本用法:</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">plurp -<span class="keyword">h</span> ip文件  -<span class="keyword">L</span> 本地目录  远程文件 本地文件名称</span><br></pre></td></tr></table></figure>
<p>例子： 将<code>host.txt</code>列出的主机上的<code>/tmp/i.txt</code>文件复制到本机的<code>/tmp/i.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pslurp -h host.txt <span class="_">-l</span> root -L /tmp /tmp/i.txt i.txt</span><br><span class="line">[1] 09:53:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:53:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure>
<p>特别参数说明：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">-<span class="keyword">L</span> 指定本地存放文件的目录</span><br></pre></td></tr></table></figure>
<p>虽然帮助文档中说 <code>-L</code> 参数是可选的，但是经过我试验 <code>-L</code> 参数是必须的，要不然会报错。</p>
<p>增加 <code>-L</code> 参数后，会在 <code>-L</code> 指定的本地目录下创建<code>[用户@]主机IP[:端口]</code>目录，对应的目录下用于存放从改主机复制过来的文件。</p>
<h2 id="pnuke基本使用"><a href="#pnuke基本使用" class="headerlink" title="pnuke基本使用"></a>pnuke基本使用</h2><p><code>pnuke</code>并行地在多个远程主机上杀死进程。</p>
<p><code>pnuke</code> 的参数与<code>pssh</code>一样,只是最后的字符串为要结束的进程名称</p>
<p>例子： 将<code>host.txt</code>列出的主机上的<code>httpd</code>进程杀死</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnuke -h host.txt <span class="_">-l</span> root httpd</span><br><span class="line">[1] 09:55:28 [SUCCESS] 172.18.10.25</span><br><span class="line">[2] 09:55:28 [SUCCESS] 172.18.10.24</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[效率脚本:删除指定项目的所有feature分支]]></title>
      <url>http://tonydeng.github.io/2014/12/08/auto-delete-feature-branchs/</url>
      <content type="html"><![CDATA[<p>使用Git来管理代码，的确给我们带来很多方便，尤其是使用gitflow流程，让我们开发流程更加清晰，响应需求变化速度更快。</p>
<p>由于我们基于gitlab来进行code review，所有的分支都会push到远程仓库来进行code review。当一个版本完成之后，在远程和本地都会存在一些过期的、无用的分支。对于有些强迫症的我来说，保留这些无用的分支实在很难受，一个一个手工的删除这些分支也不符合我的风格，还是写个脚本来批量处理吧。</p>
<a id="more"></a>
<h2 id="删除哪些分支？"><a href="#删除哪些分支？" class="headerlink" title="删除哪些分支？"></a>删除哪些分支？</h2><p>由于大部分的过期的分支都是feature分支，所以我们就来这些已经合并过的本地和远程的feature分支吧。</p>
<h3 id="Shell脚本如下："><a href="#Shell脚本如下：" class="headerlink" title="Shell脚本如下："></a>Shell脚本如下：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">WORKSPACE=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$WORKSPACE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br><span class="line"></span><br><span class="line">BRANCHS=`git branch -r|awk -F <span class="string">'/'</span> <span class="string">'&#123;if($2=="feature")print $2"/"$3"/"$4&#125;'</span>`</span><br><span class="line"><span class="keyword">for</span> br <span class="keyword">in</span> <span class="variable">$BRANCHS</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span>_result=`git branch <span class="_">-d</span> <span class="variable">$br</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"git branch -d <span class="variable">$br</span> result: <span class="variable">$local_result</span>"</span></span><br><span class="line">        remote_result=`git push origin :<span class="variable">$br</span>`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"git push origin :<span class="variable">$br</span> result: <span class="variable">$remote_result</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$BRANCHS</span></span><br></pre></td></tr></table></figure>
<h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/sh/git/feature_branch_del.sh your_git_project</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Octopress Can Not Create new Post on Zsh]]></title>
      <url>http://tonydeng.github.io/2014/12/07/octopress-can-not-create-new-post-on-zsh/</url>
      <content type="html"><![CDATA[<p>在<strong>zsh</strong>中执行rake new_post[“Title”]时会报错，提示”no matches found”。</p>
<p>原因是<strong>zsh</strong>中若出现下列符合，则将识别为查找文件名的通配符。</p>
<blockquote>
<p>‘*’, ‘(’, ‘|’, ‘&lt;’, ‘[’, or ‘?’</p>
</blockquote>
<p>很不幸的时，我们在octopress中创建新blog的命令就出现了“[”这个符号。</p>
<p>报错信息如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">➜  <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(source)</span> <span class="selector-tag">rake</span> <span class="selector-tag">new_post</span><span class="selector-attr">["title"]</span></span><br><span class="line"><span class="selector-tag">zsh</span>: <span class="selector-tag">no</span> <span class="selector-tag">matches</span> <span class="selector-tag">found</span>: <span class="selector-tag">new_post</span><span class="selector-attr">[title]</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>解决方法有两个：</p>
<p>1、 快速解决法，将rake之后都用双引号“”括起来：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">➜  <span class="selector-tag">tonydeng</span><span class="selector-class">.github</span><span class="selector-class">.io</span> <span class="selector-tag">git</span><span class="selector-pseudo">:(source)</span> <span class="selector-tag">rake</span> "<span class="selector-tag">new_post</span><span class="selector-attr">[title]</span>"</span><br></pre></td></tr></table></figure></p>
<p>2、 彻底解决法，在执行rake时，取消zsh的通配(GLOB)：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">➜  tonydeng<span class="selector-class">.github</span><span class="selector-class">.io</span> git:(source) echo <span class="string">"alias rake='noglob rake'"</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>oh-my-zsh的<a href="https://github.com/robbyrussell/oh-my-zsh/issues/433" target="_blank" rel="external">issue #443</a></p>
<p>Mike Ballou的文章 <a href="http://mikeballou.com/blog/2011/07/18/zsh-and-rake-parameters/" target="_blank" rel="external">ZSH and Rake Parameters</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UNIX设计哲学]]></title>
      <url>http://tonydeng.github.io/2009/10/27/the-design-philosophy-to-UNIX/</url>
      <content type="html"><![CDATA[<p><img src="/images/blog/kiss.png" alt="KISS"></p>
<p>现在所有常用的操作系统基本上都是在Unix的基础上衍生–Mac OSX、Linux（最少是借鉴–Windows）出来的，而且基本上大学的操作系统的课程也是拿Unix系统来讲解的。</p>
<a id="more"></a>
<p>最近在看<a href="http://book.douban.com/subject/1467587/" target="_blank" rel="external">《Unix 编程艺术》</a>这本书，上网搜索了相关的信息，发现好多人都在谈论“UNIX设计哲学”。<a href="http://en.wikipedia.org/wiki/Unix_philosophy#cite_note-0" target="_blank" rel="external">Wikipedia</a>上也列出了好几个版本，不同的人有不同的总结。</p>
<p>不过，这几个版本中所有人都同意<strong> “简单原则”–尽量用简单的方法解决问题–是“Unix哲学”的根本原则 </strong>。这也就是著名的<code>KISS(keep it simple,stupid)</code>，意思是“保持简单和笨拙”。关于KIIS大家可以看<a href="http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html" target="_blank" rel="external">阮一峰大大的Blog</a></p>
<p>Unix哲学中更多的内容不是这些先哲们口头表述出来的，而是由他们所作的一切和Unix本身所作出的榜样体现出来的。</p>
<p>从整体上来说，可以概括为以下几点：</p>
<ol>
<li><p>模块原则：使用简洁的接口拼合简单的部件。</p>
</li>
<li><p>清晰原则：清晰胜于机巧。</p>
</li>
<li><p>组合原则：设计时考虑拼接组合。</p>
</li>
<li><p>分离原则：策略同机制分离，接口同引擎分离。</p>
</li>
<li><p>简洁原则：设计要简洁，复杂度能低则低。</p>
</li>
<li><p>吝啬原则：除非确无他法，不要编写庞大的程序。</p>
</li>
<li><p>透明性原则：设计要可见，以便审查和调试。</p>
</li>
<li><p>健壮原则：健壮源于透明与简洁。</p>
</li>
<li><p>表示原则：把知识叠入数据以求逻辑质朴而健壮。</p>
</li>
<li><p>通俗原则：接口设计避免标新立异。</p>
</li>
<li><p>缄默原则：如果一个程序没什么好说的，就沉默。</p>
</li>
<li><p>补救原则：出现异常时，马上退出并给出足够错误信息。</p>
</li>
<li><p>经济原则：宁花机器一分，不花程序员一秒。</p>
</li>
<li><p>生成原则：避免手工hack，尽量编写程序去生成程序。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你是一个够职业的软件工程师吗？]]></title>
      <url>http://tonydeng.github.io/2009/10/19/are-you-a-professional-engineer/</url>
      <content type="html"><![CDATA[<p>这两天看了一个这样的文章<a href="http://www.programmer.com.cn/1041/" target="_blank" rel="external">《软件工程师的十个“不职业”行为》</a>，是陈尚义老师整理分享的。看完之后，抚心自问，自己还是比较职业的软件工程师。</p>
<p>现在将这十条不职业的行为摘录下来，时刻提醒自己。</p>
<ul>
<li><p>行为一：对外交付半成品。</p>
</li>
<li><p>行为二：不遵守标准和规范。</p>
</li>
<li><p>行为三：不积极帮助他人。</p>
</li>
<li><p>行为四：版权意识不敏感。（这点要注意）</p>
</li>
<li><p>行为五：对待计划不严肃。</p>
</li>
<li><p>行为六：公事私事想混淆。</p>
</li>
<li><p>行为七：不注意更新自己。</p>
</li>
<li><p>行为八：不主动与人沟通。</p>
</li>
<li><p>行为九：不遵守职场规则。</p>
</li>
<li><p>行为十：不够诚实和正直</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一条Linux命令，一段人类文明]]></title>
      <url>http://tonydeng.github.io/2006/03/28/A-Linux-command-a-human-civilization/</url>
      <content type="html"><![CDATA[<p>以前听人说在Linux上可以查到一个很奇怪的月份，只是当时忘了那个特殊的月份。今天在网上搜了一下，发现通过这个命令（月份）了解了一段人类文明历史。呵呵。虽然和Linux没什么关系，但是确实是因为Linux才让我了解到的。</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">~ cal <span class="number">9</span> <span class="number">1752</span></span><br><span class="line"></span><br><span class="line">September <span class="number">1752</span></span><br><span class="line">S M Tu W Th F S</span><br><span class="line"><span class="number">1 2 14 15</span> <span class="number">16</span></span><br><span class="line"><span class="number">1 7 18 19</span> <span class="number">20 21 22 23</span></span><br><span class="line"><span class="number">2 4 25 26</span> <span class="number">27 28 29 30</span></span><br></pre></td></tr></table></figure>
<p>我们发现1752年9月2日的后面竟然是14日，确实很奇怪，通过在网上搜索，找到了答案：</p>
<p>1582年2月，罗马教廷要求从1582 年10月中减去10天，因此1852 年10月4日后面紧跟着就是15日。 在意大利、西班牙等国家都这样处理了。其他天主教国家也很快跟着这么做了，但是新教国家不愿意修改， 而且希腊等东正教国家直到20世纪初才修改，所以这个改革在英国及其殖民地（包括美国）在1752年9月才被执行。这样 1752 年9月2日后面跟着的就是1752 年9月14日。 这就是为什么cal会生成上面输出的原因了。</p>
<p>为什么减去10天得原因是由于地球章动的常年累月的影响累计，历法已经不准了。虽然是罗马教皇宣布的，但是其实是天文学家们计算得出来的。</p>
<p>P.S.：Windows用户是没福气查到这个特殊月份了，因为Windows的纪年范围只是1980-2099。呵呵</p>
]]></content>
    </entry>
    
  
  
</search>
